{"LinkedList.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract LinkedList{\n    mapping(address=\u003emapping(bool=\u003eaddress)) dllIndex;\n    mapping(address =\u003e uint) balances;\n    address head;\n    address tail;\n    uint arraySize = 0;\n    \n    constructor(address _owner) public{\n        head=_owner;\n        dllIndex[head][true]=_owner;\n        dllIndex[head][false]=_owner;\n        tail=_owner;\n        dllIndex[tail][true]=_owner;\n        dllIndex[tail][false]=_owner;\n        arraySize++;\n    }\n    \n    function add(address _addr) public\n    {\n        address nullAddress;\n        \n        if (dllIndex[_addr][false]==nullAddress \u0026\u0026 dllIndex[_addr][true]==nullAddress){\n            //false==PREV\n            //true==NEXT\n            dllIndex[_addr][false] = tail;\n            dllIndex[_addr][true] = _addr;\n        \n            // Insert the new node\n            dllIndex[tail][true] = _addr;\n            tail=_addr;\n            arraySize++;\n            getList();\n        }\n        \n    }\n\n    function remove(address _addr) public\n    {\n        if (arraySize\u003e1){\n            address previous = dllIndex[_addr][false];\n            address next = dllIndex[_addr][true];\n            \n        \n            if (_addr == head){\n                head=next;\n                dllIndex[previous][false]=next;\n            } else if(_addr == tail){\n                tail=previous;\n                dllIndex[next][false]=previous;\n            }else{\n                dllIndex[dllIndex[_addr][false]][true] = next;\n                dllIndex[dllIndex[_addr][true]][false] = previous;\n            }\n            //Delete state storage\n            delete dllIndex[_addr][false];\n            delete dllIndex[_addr][true];\n            delete balances[_addr];\n            arraySize--;\n        }\n        \n    }\n    \n    function getList() public view returns(address[] memory){\n        address[] memory addressList = new address[](arraySize);\n        addressList[0]=head;\n        if(arraySize==1){\n            return addressList;\n        }else{\n            buildList(head, addressList, 1);\n            return addressList;\n        }\n    }\n    \n    function buildList(address currentLink, address[] memory currentList, uint currentIndex) public view{\n        if (currentLink != dllIndex[currentLink][true]){\n            currentList[currentIndex]=dllIndex[currentLink][true];\n            currentIndex++;\n            buildList(dllIndex[currentLink][true], currentList, currentIndex);\n        }\n    }\n    \n    function getElement(address itemAddress) public view returns(address previous, address next){\n        previous = dllIndex[itemAddress][false];\n        next = dllIndex[itemAddress][true];\n    }\n}"},"tfys.sol":{"content":"pragma solidity ^0.5.0;\nimport \"./LinkedList.sol\";\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n}\n\ncontract ERC223ReceivingContract { \n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\n}\n\n\ncontract tfys{\n    mapping (string =\u003e int[]) public resultados;\n    \n    function getResultado(string memory auction) public view returns(int[] memory resultado){\n        resultado=resultados[auction];\n    }\n    \n    function salvarResultados(string memory auction, int[] memory numeros) public{\n        require(isOwner[msg.sender]);\n        resultados[auction]=numeros;\n    }\n    \n    using SafeMath for uint256;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    mapping(uint=\u003emapping (uint=\u003e LinkedList)) public listasDeEscolhas;\n    \n    mapping (uint=\u003evotacao) public listaDeVotacoes;\n    uint public votacaoAtual=0;\n    struct votacao{\n        mapping(address=\u003ebool) votou;\n        mapping(address=\u003euint) votouOnde;\n        mapping(uint=\u003euint) votosNaOpcao;\n        uint blocoInicial;\n        uint blocoFinal;\n        string titulo;\n        escolha[] escolhas;\n        uint quantidadeEscolhas;\n    }\n    struct escolha{\n        string titulo;\n        LinkedList votos;\n    }\n    \n    function abrirVotacao(uint blocoInicial, uint blocoFinal, string memory titulo) public{\n        require(isOwner[msg.sender]);\n        require(blocoInicial \u003e= block.number);\n        require(blocoFinal \u003e blocoInicial);\n        uint inteiroNulo;\n        uint votacaoAtualBlocoFinal = listaDeVotacoes[votacaoAtual].blocoFinal;\n        if (votacaoAtualBlocoFinal != inteiroNulo){\n            require(votacaoAtualBlocoFinal\u003cblock.number);\n        }\n        \n        listaDeVotacoes[votacaoAtual].blocoInicial=blocoInicial;\n        listaDeVotacoes[votacaoAtual].blocoFinal=blocoFinal;\n        listaDeVotacoes[votacaoAtual].titulo=titulo;\n        listaDeVotacoes[votacaoAtual].quantidadeEscolhas=0;\n        \n        votacaoAtual++;\n    }\n    function editarVotacao(uint blocoInicial, uint blocoFinal, string memory titulo) public{\n        require(isOwner[msg.sender]);\n        require(blocoFinal \u003e blocoInicial);\n        listaDeVotacoes[votacaoAtual-1].blocoInicial=blocoInicial;\n        listaDeVotacoes[votacaoAtual-1].blocoFinal=blocoFinal;\n        listaDeVotacoes[votacaoAtual-1].titulo=titulo;\n    }\n    \n    function adicionarUmaEscolha(string memory titulo) public{\n        require(isOwner[msg.sender]);\n        // require(listaDeVotacoes[votacaoAtual-1].blocoInicial\u003e=block.number);\n        uint inteiroNulo;\n        if (listaDeVotacoes[votacaoAtual-1].quantidadeEscolhas==inteiroNulo){\n            listaDeVotacoes[votacaoAtual-1].quantidadeEscolhas=0;\n        }\n        listaDeVotacoes[votacaoAtual-1].quantidadeEscolhas++;\n\n        LinkedList votos;\n        listaDeVotacoes[votacaoAtual-1].escolhas.push(escolha({titulo: titulo, votos:votos}));\n    }\n    \n    function getResultadoDaEscolha(uint _escolha, uint _votacao) public view returns(string memory escolhaTitulo, uint votos){\n        escolhaTitulo = listaDeVotacoes[_votacao].escolhas[_escolha].titulo;\n        votos = listaDeVotacoes[_votacao].votosNaOpcao[_escolha];\n    }\n    \n    function votar(uint _escolha) public {\n        require(listaDeVotacoes[votacaoAtual-1].blocoInicial\u003c=block.number);\n        require(listaDeVotacoes[votacaoAtual-1].blocoFinal\u003e=block.number);\n        listaDeVotacoes[votacaoAtual-1].votosNaOpcao[_escolha]+=users[msg.sender].balance;\n        listaDeVotacoes[votacaoAtual-1].votouOnde[msg.sender]=_escolha;\n        listaDeVotacoes[votacaoAtual-1].votou[msg.sender]=true;\n        LinkedList votos;\n        if (listaDeVotacoes[votacaoAtual-1].escolhas[_escolha].votos==votos){\n            listaDeVotacoes[votacaoAtual-1].escolhas[_escolha].votos = new LinkedList(msg.sender);\n        }else{\n            listaDeVotacoes[votacaoAtual-1].escolhas[_escolha].votos.add(msg.sender);\n        }\n        \n    }\n    \n    function name() public pure returns (string memory _name){\n        _name = \"TradeForYou-S\";\n    }\n    \n    function symbol() public pure returns (bytes32 _symbol){\n        _symbol = \"TFYS\";\n    }\n    \n    function decimals() public pure returns (uint8 _decimals){\n        _decimals = 0;\n    }\n    \n    uint public janelaAtual=0;\n    mapping(uint=\u003ejanela) public listaDeJanelas;\n    struct janela{\n        uint blocoInicial;\n        uint blocoFinal;\n        uint ethEmWei;\n        uint totalTokensTravados;\n        mapping (address=\u003euint) saldoTravado;\n    }\n\n    function abrirJanela(uint blocoInicial, uint blocoFinal, uint ethEmWei) public payable{\n        \n        require(msg.value==ethEmWei);\n        require(isOwner[msg.sender]);\n        require(blocoInicial \u003e= block.number);\n        require(blocoFinal \u003e blocoInicial);\n        uint inteiroNulo;\n        uint janelaAtualBlocoFinal = listaDeJanelas[janelaAtual].blocoFinal;\n        if (janelaAtualBlocoFinal != inteiroNulo){\n            require(janelaAtualBlocoFinal\u003cblock.number);\n        }\n        janelaAtual++;\n        listaDeJanelas[janelaAtual].blocoInicial=blocoInicial;\n        listaDeJanelas[janelaAtual].blocoFinal=blocoFinal;\n        listaDeJanelas[janelaAtual].ethEmWei=ethEmWei;\n        \n    }\n    function editarJanela(uint blocoInicial, uint blocoFinal, uint ethEmWei) public payable{\n        require(msg.value==ethEmWei);\n        require(isOwner[msg.sender]);\n        require(blocoFinal \u003e blocoInicial);\n        listaDeJanelas[janelaAtual].blocoInicial=blocoInicial;\n        listaDeJanelas[janelaAtual].blocoFinal=blocoFinal;\n        uint saldoASacar = listaDeJanelas[janelaAtual].ethEmWei;\n        listaDeJanelas[janelaAtual].ethEmWei=ethEmWei;\n        msg.sender.transfer(saldoASacar);\n    }\n    \n    mapping (address =\u003e bool) public isOwner;\n    uint private _quantidadeOwners = 0;\n    LinkedList private _owners;\n    \n    mapping(address=\u003eaccount) users;\n    \n    struct account{\n        uint balance;\n        uint headDividendos;\n        uint[] dividendos;\n    }\n    \n    function participarDaJanela() public{\n        require(listaDeJanelas[janelaAtual].blocoInicial\u003c=block.number);\n        require(listaDeJanelas[janelaAtual].blocoFinal\u003e=block.number);\n        uint inteiroNulo;\n        if(listaDeJanelas[janelaAtual].saldoTravado[msg.sender]==inteiroNulo){\n            listaDeJanelas[janelaAtual].saldoTravado[msg.sender]=0;\n        }\n        require(users[msg.sender].balance\u003elistaDeJanelas[janelaAtual].saldoTravado[msg.sender]);\n        listaDeJanelas[janelaAtual].saldoTravado[msg.sender]=users[msg.sender].balance;\n        listaDeJanelas[janelaAtual].totalTokensTravados+=users[msg.sender].balance;\n        users[msg.sender].dividendos.push(janelaAtual);\n    }\n    function reclamarDividendos() public payable{\n        require(users[msg.sender].dividendos.length\u003e0);\n        uint head = users[msg.sender].headDividendos;\n        uint dividendos=0;\n        for(uint i=head; i\u003cusers[msg.sender].dividendos.length; i++){\n            janela storage janelaContagem = listaDeJanelas[users[msg.sender].dividendos[i]];\n            if(janelaContagem.blocoFinal\u003cblock.number){\n                users[msg.sender].headDividendos++;\n                uint totalTrancado = janelaContagem.totalTokensTravados;\n                uint meuTrancado = janelaContagem.saldoTravado[msg.sender];\n                uint totalWei = janelaContagem.ethEmWei;\n                dividendos += (totalWei/totalTrancado)*meuTrancado;\n            }\n        }\n        msg.sender.transfer(dividendos);\n    }\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    constructor() public{\n        _totalSupply=10000000;\n        users[msg.sender].balance=_totalSupply;\n        isOwner[msg.sender]=true;\n        _quantidadeOwners++;\n        _owners = new LinkedList(msg.sender);\n        \n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return users[owner].balance;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        bytes memory empty;\n        transfer(to, value, empty);\n        return true;\n    }\n    function transfer(address to, uint256 value, bytes memory data) public returns (bool) {\n        _transfer(msg.sender, to, value, data);\n        return true;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        bytes memory empty;\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n        _transfer(from, to, value, empty);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n    function _transfer(address from, address to, uint256 value, bytes memory data) internal {\n        if(listaDeJanelas[janelaAtual].blocoFinal\u003e=block.number){\n            uint inteiroNulo;\n            if(listaDeJanelas[janelaAtual].saldoTravado[from]==inteiroNulo){\n                listaDeJanelas[janelaAtual].saldoTravado[from]=0;\n            }\n            uint saldoLivre = users[from].balance.sub(listaDeJanelas[janelaAtual].saldoTravado[from]);\n            require(saldoLivre\u003e=value);\n        }\n        if (listaDeVotacoes[votacaoAtual-1].votou[msg.sender]){\n            uint valorDoVoto=listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[msg.sender]];\n            listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[msg.sender]]= valorDoVoto.sub(value);\n        } if (listaDeVotacoes[votacaoAtual-1].votou[to]){\n            uint valorDoVoto = listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[to]];\n            listaDeVotacoes[votacaoAtual-1].votosNaOpcao[listaDeVotacoes[votacaoAtual-1].votouOnde[to]] = valorDoVoto.add(value);\n        }\n        uint codeLength;\n        assembly {\n            // Retrieve the size of the code on target address, this needs assembly .\n            codeLength := extcodesize(to)\n        }\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        users[from].balance = users[from].balance.sub(value);\n        users[to].balance = users[to].balance.add(value);\n        emit Transfer(from, to, value);\n        if(codeLength\u003e0) {\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);\n            receiver.tokenFallback(msg.sender, value, data);\n        }\n        \n    }\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n    \n    function getOwnersList() public view returns(address[] memory){\n         return _owners.getList();\n    }\n    \n    function addOwner(address _newOwner) public returns(bool){\n        require(isOwner[msg.sender]);\n        isOwner[_newOwner]=true;\n        _quantidadeOwners++;\n        _owners.add(_newOwner);\n        return true;\n    }\n    function removeOwner(address _oldOwner) public returns(bool){\n        require(isOwner[msg.sender]);\n        require(_quantidadeOwners\u003e1);\n        isOwner[_oldOwner]=false;\n        _quantidadeOwners--;\n        _owners.remove(_oldOwner);\n        return true;\n    }\n    \n    \n}"}}