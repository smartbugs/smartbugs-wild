{"BrightCoinAdvisorTokenDistribution.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract BrightCoinAdvisorTokenDistribution  is BrightCoinTokenOwner\r\n{\r\n\r\n\r\nusing SafeMath for uint;\r\nmapping(address =\u003e uint256)AdvisorBalances;\r\n\r\n\r\nconstructor() public\r\n{\r\n\r\n}\r\n  //There might be multiple entry to this\r\n uint256 public TotalAllocatedAdvisorToken;\r\n \r\n \r\n struct advisorDistribution {\r\n        address addr;\r\n        uint256 tokenamount;\r\n        uint256 expiryDateTime;\r\n        bool   advisorpartofTeam;\r\n        bool  tokenlocked;\r\n    }\r\n mapping(address =\u003e advisorDistribution) advisorDistributionDetails;\r\n address[] public advisorDistributionAddr;\r\n \r\n \r\n //Advisor Starts\r\n//Adding New Advisor for Token Distribution\r\n function AddAdvisor(address _newAdvisor,uint256 _tokenamount,uint256 _lockexpiryTime,bool _tokenlocked)   internal\r\n  {\r\n    \r\n        advisorDistribution storage  advisorDetails = advisorDistributionDetails[_newAdvisor];\r\n\r\n       advisorDetails.addr = _newAdvisor;\r\n       advisorDetails.tokenamount = _tokenamount;\r\n       advisorDetails.expiryDateTime = _lockexpiryTime;\r\n       advisorDetails.advisorpartofTeam = true;\r\n       advisorDetails.tokenlocked   = _tokenlocked;\r\n\r\n       advisorDistributionAddr.push(_newAdvisor);\r\n \r\n }\r\n\r\nfunction UpdateAdvisorTokenDetails (address _newAdvisor,uint256 _tokenamount,\r\n  uint256 _lockExpiryDateTime) internal\r\n{\r\n require(CheckIfAdvisorActive(_newAdvisor) == true);\r\n  advisorDistribution storage  advisorDetails = advisorDistributionDetails[_newAdvisor];\r\n                  \r\n   //Add new Token amount and Set new locking Period\r\n   advisorDetails.tokenamount  = advisorDetails.tokenamount.add(_tokenamount);\r\n   advisorDetails.expiryDateTime = _lockExpiryDateTime;\r\n\r\n        \r\n}\r\n\r\n //Remove Advisor For Further Investment and from the Team\r\n function RemoveAdvisorFromFurtherInvestment(address _newAdvisorAddr) public onlyTokenOwner  returns(bool)\r\n {\r\n    advisorDistribution storage newAdvisorDetails = advisorDistributionDetails[_newAdvisorAddr];\r\n    newAdvisorDetails.advisorpartofTeam = false;\r\n    return true;\r\n }\r\n\r\n //Ends\r\n\r\n\r\n //check if Advisor Removed \r\n function CheckIfAdvisorActive(address _newAdvisorAddr) view internal returns(bool)\r\n {\r\n\r\n  advisorDistribution storage advisorDetails = advisorDistributionDetails[_newAdvisorAddr];\r\n  if(advisorDetails.advisorpartofTeam == true)\r\n  {\r\n      return true;\r\n  }\r\n  return false;\r\n\r\n }\r\n\r\n//Count total no of Advisors\r\n function TotalAdvisor() public onlyTokenOwner  view returns(uint256) \r\n {\r\n   return advisorDistributionAddr.length;\r\n }\r\n\r\n\r\n //check Amount with Advisor\r\n function CheckAdvisorTokenAmount(address _newAdvisorAddr) public onlyTokenOwner  view returns(uint256)\r\n {\r\n\r\n  advisorDistribution storage advisorDetails = advisorDistributionDetails[_newAdvisorAddr];\r\n  return advisorDetails.tokenamount ;\r\n\r\n }\r\n\r\n }\r\n"},"BrightCoinERC20ContractInterface_ICO.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\ninterface ERC20TokenInterface {\r\n    function totalSupply() external constant returns (uint);\r\n    function balanceOf(address _tokenOwner) external constant returns (uint balance);\r\n    function allowance(address _tokenOwner, address spender) external constant returns (uint remaining);\r\n   function transfer(address _to, uint _tokens) external returns (bool success);\r\n    function approve(address _spender, uint _tokens) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _tokens) external returns (bool success);\r\n\r\n}\r\n\r\n  "},"BrightCoinERC20Contract_ICO.sol":{"content":"pragma solidity ^0.4.25;\r\n//pragma experimental \"v0.5.0\";\r\n\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\nimport \"./BrightCoinERC20ContractInterface_ICO.sol\";\r\nimport \"./BrightCoinTokenSaleType_ICO.sol\";\r\n//import \"./BrightCoinAdminTokenDistributionDetails.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./BrightCoinInvestorTokenLock_ICO.sol\";\r\n\r\n\r\n\r\n\r\n\r\ncontract BrightCoinERC20 is BrightCoinTokenPreSaleDetails,\r\n                            BrightCoinTokenMainSaleDetails,\r\n                        //   BrightCoinAdminTokenDistributionDetails,\r\n                            BrightCoinInvestorTokenLock\r\n                           \r\n                          \r\n                         \r\n                            \r\n{\r\n  using SafeMath for uint;\r\n\r\n\r\n event Transfer(address indexed from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed owner, address indexed _spender, uint256 _value);\r\n   // Event called when presale is done\r\n  event PresaleFinalized(uint tokens);\r\n  event ICOSoftCapReached(string softcap);\r\n  event ICOSoftUnsuccessFull(uint256 TokenSold,string str);\r\n  event Burn(address addr, uint256 tokens);\r\n  event Mint(address target, uint256 mintedAmount);\r\n  \r\n \r\n  bool  internal pauseICO = false; \r\n  uint8 internal saleIndex = 0; //Default Sale Index as zero\r\n\r\n//Token Supply Details\r\n  uint256 public totalSupply; //Need to set at constructor level\r\n  uint256 private  BountyDistriuted = 0;\r\n  uint256 public CompanyHoldingValue = 0;\r\n   mapping(address =\u003e uint256)CompanyHoldingBalances;\r\n   address internal custodianaddress;\r\n \r\n\r\n  //Purchase Rate\r\n  function setPurchaseRate(uint newRate) public onlyTokenOwner {\r\n        require(purchaseRate != newRate);\r\n        purchaseRate = newRate;\r\n    }\r\n \r\n //ICO SoftCap \u0026 HardCap\r\n /*\r\n    Soft cap is the minimal amount required by your project, to make it viable, in order to continue. If you do not reach that amount during your ICO then you should allow your investors to refund their money using a push/ pull mechanism.\r\n */\r\n \r\n\r\n   function ChangeSoftCap(uint _newSoftcap) public onlyTokenOwner {\r\n        require(icoSoftcap != _newSoftcap);\r\n       // require(_newSoftcap \u003c= totalSupply);\r\n       require(icoSoftcap \u003c= (balances[owner()].add(balances[custodianaddress])));\r\n        icoSoftcap = _newSoftcap;\r\n      \r\n    }\r\n    function changeHardCapLimit(uint256 _newHardcap) public onlyTokenOwner {\r\n       \r\n        require(icoHardcap != _newHardcap);\r\n        require(_newHardcap \u003c= (balances[owner()].add(balances[custodianaddress])));\r\n       // require(_newHardcap \u003c= totalSupply);\r\n        icoHardcap = _newHardcap;\r\n      \r\n    }\r\n\r\n\r\n    function GetSoftcap() public  view   returns(uint256) {\r\n\r\n      return icoSoftcap;\r\n    }\r\n\r\n     function GetHardcap() public   view  returns(uint256) {\r\n\r\n      return icoHardcap;\r\n    }\r\n\r\n    //Check if softcap reached\r\n    function CheckIfSoftcapAchived() public   view returns(bool)\r\n    {\r\n\r\n        uint256 ownerbal = balances[owner()]; \r\n        uint256 custodianbal = balances[custodianaddress];\r\n       uint tokenSold = totalSupply.sub(ownerbal.add(custodianbal));\r\n\r\n        if (tokenSold \u003e icoSoftcap)\r\n            return true;\r\n        else \r\n            return false;  \r\n        \r\n    }\r\n\r\n    //check if HARD Cap Achived\r\n    function CheckIfHardcapAchived(uint256 _tokens)  public view returns(bool)\r\n    {\r\n        uint256 ownerbal = balances[owner()]; \r\n        uint256 custodianbal = balances[custodianaddress];\r\n      uint tokenSold = totalSupply.sub(ownerbal.add(custodianbal));\r\n      require(tokenSold \u003c= icoHardcap);\r\n      require(tokenSold.add(_tokens) \u003c=icoHardcap);\r\n      return true;\r\n\r\n    }\r\n\r\n \r\n    function setSalePeriodIndex(uint8 _index) public onlyTokenOwner  \r\n    {\r\n        require(_index \u003e0); //To set minimum Sale Period Index\r\n        saleIndex = _index;\r\n        \r\n    }\r\n    \r\n     function getSalePeriodIndex()  public view  returns(uint8)\r\n    {\r\n        return saleIndex;\r\n        \r\n    }\r\n  \r\n  \r\n /* function ChangeFundDepositAddress(address _newFundDepositAddress) public onlyTokenOwner  {\r\n    require(_newFundDepositAddress != address(0x0));\r\n    require( FundDepositAddress != _newFundDepositAddress );\r\n    //FundDepositAddress = _newFundDepositAddress;\r\n  }\r\n  */\r\n  \r\n\r\n//option for Minting more token \r\nbool public MintMoreTokens  = false;\r\nfunction UpdateTokenMintingOption(bool _mintingOption) public onlyTokenOwner  {\r\n  \r\n  MintMoreTokens = _mintingOption;\r\n}\r\n\r\n\r\n /////////////////////////////////////////////////   \r\n\r\n \r\n ////////////////////////////////////////\r\n  mapping(address =\u003e uint256) balances;\r\n  mapping(address =\u003e mapping (address =\u003e uint256)) allowed;\r\n\r\n  \r\n  \r\n //////////////////////////////////////////\r\n  \r\n \r\n  constructor () public{\r\n\r\n   totalSupply = initialSupply*(10**uint256(decimals));\r\n\r\n   //TotalAllocatedTeamToken = InitialAllocatedTeamToken*(10**uint256(decimals));\r\n  // TotalAllocatedFounder = InitialFounderToken*(10**uint256(decimals));\r\n //  TotalAllocatedAdvisorToken = InitialAllocatedAdvisorToken*(10**uint256(decimals));\r\n  CompanyHoldingValue = InitialCompanyHoldingValue*(10**uint256(decimals));\r\n  // BountyAllocated = totalBountyAllocated*(10**uint256(decimals));\r\n   \r\n\r\n   icoHardcap = icoHardcap.mul(10**uint256(decimals));\r\n   icoSoftcap = icoSoftcap.mul(10**uint256(decimals));\r\n   \r\n   balances[msg.sender] = totalSupply;\r\n  emit Transfer(address(0), msg.sender, totalSupply);\r\n   \r\n // FounderBalances[msg.sender] = TotalAllocatedFounder;\r\n // AdvisorBalances[msg.sender] = TotalAllocatedAdvisorToken;\r\n//  TeamBalances[msg.sender] = TotalAllocatedTeamToken;\r\n  CompanyHoldingBalances[msg.sender] = CompanyHoldingValue;\r\n  //BountyBalances[msg.sender]  = BountyAllocated;\r\n // balances[BountyTokenHolder] = BountyAllocated;\r\n   \r\n  \r\n  // BountyDistriuted = 0;\r\n \r\n  }\r\n\r\n \r\n\r\n // This function returns remaininig token\r\n  function balanceOf(address _who) public constant returns (uint256) {\r\n      return balances[_who];\r\n  }\r\n\r\n//Function Total Supply\r\nfunction totalSupply() public constant returns (uint256) {\r\n      return totalSupply;\r\n  }\r\n\r\nfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n}\r\n    \r\n   \r\n    /// @notice Will Transfer tokens from current address to receipient address.\r\n    /// @param _from  addresses to send token.\r\n    /// @param _tokens amount of token to be transferred.\r\n   /* function internaltransfer1(address _to, address _from, uint _tokens) internal returns (bool) {\r\n  \r\n     // Prevent transfer to 0x0 address. \r\n   require(_to != 0x0);\r\n    require (_tokens \u003e 0);\r\n    require (_from != _to);\r\n   require(balances[_from] \u003e= _tokens);\r\n   require(balances[_to] + _tokens \u003e balances[_to]);\r\n    balances[_from] = balances[_from].sub(_tokens);\r\n    balances[_to] = balances[_to].add(_tokens);\r\n    return true;\r\n   }\r\n   */\r\n   \r\n   /// @notice Will Transfer tokens from current address to receipient address.\r\n    /// @param _recipient  addresses to send token.\r\n    /// @param _tokens amount of token to be transferred.\r\n    function internaltransfer(address _sender, address _recipient, uint _tokens) internal returns (bool) {\r\n  \r\n     // Prevent transfer to 0x0 address. \r\n   /* require(_to != 0x0);\r\n    require (_tokens \u003e 0);\r\n  //require (_from != _to);\r\n   require(balances[_from] \u003e= _tokens);\r\n   require(balances[_to] + _tokens \u003e balances[_to]);\r\n    balances[_from] = balances[_from].sub(_tokens);\r\n    balances[_to] = balances[_to].add(_tokens);\r\n    emit Transfer(_from, _to, _tokens);\r\n    */\r\n    require(_sender != address(0), \"ERC20: transfer from the zero address\");\r\n       require(_recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n       balances[_sender] = balances[_sender].sub(_tokens);\r\n       balances[_recipient] = balances[_recipient].add(_tokens);\r\n         //  emit Transfer(_sender, _recipient, _tokens);\r\n    \r\n    return true;\r\n   }\r\n   \r\n\r\n    /// @notice Will cause a certain `_value` of coins minted for `_to`.\r\n    /// @param _to The address that will receive the coin.\r\n    /// @param _value The amount of coin they will receive.\r\n    function mint(address _to, uint _value) public onlyTokenOwner  {\r\n       // assuming you have a contract owner\r\n        mintToken(_to, _value);\r\n    }\r\n\r\n/*\r\n    /// @notice Will allow multiple minting within a single call to save gas.\r\n    /// @param recipients A list of addresses to mint for.\r\n    /// @param _values The list of values for each respective `_to` address.\r\n    function airdropMinting(address[] recipients, uint256[] _values) public onlyTokenOwner  {\r\n        // assuming you have a contract owner\r\n        require(recipients.length == _values.length);\r\n        for (uint i = 0; i \u003c recipients.length; i++) {\r\n\r\n            mintToken(recipients[i], _values[i]);\r\n        }\r\n    }\r\n    */\r\n\r\n    /// Internal method shared by `mint()` and `airdropMinting()`.\r\n    function mintToken(address _to, uint256 _value) internal {\r\n\r\n   \r\n        balances[_to]  = balances[_to].add(_value);\r\n        totalSupply =  totalSupply.add(_value); \r\n        require(balances[_to] \u003e= _value \u0026\u0026 totalSupply \u003e= _value); // overflow checks\r\n        emit  Mint(_to, _value);\r\n    } \r\n\r\n    /// @notice it will burn all the token passed as parameter.\r\n    /// @param _value Value of token to be burnt\r\n   function burn(uint256 _value) public onlyTokenOwner  {\r\n    require(_value \u003e 0);\r\n    require(_value \u003c= balances[msg.sender]);\r\n    // no need to require value \u003c= totalSupply, since that would imply the\r\n    // sender\u0027s balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    address burner = msg.sender;\r\n    balances[burner] = balances[burner].sub(_value);\r\n    totalSupply = totalSupply.sub(_value);\r\n    emit Burn(burner, _value);\r\n   }\r\n\r\n\r\n   //Owner of ICO can anytime Stop the ICO post that no any transaction will happen\r\n   function pauseICOtransaction(bool _status) public onlyTokenOwner  {\r\n\r\n    pauseICO = _status;\r\n   }\r\n\r\n//Check if token is available for further Distribution to Admin\r\n/* function InterTransferToAdmin(address _addr,\r\n                     uint256 _tokenAmount,\r\n                     uint8 _adminType )   internal  returns(bool)\r\n {\r\n     \r\n\r\n     if(_adminType == uint8(BrightCoinAdminType.Founder))\r\n    {\r\n        require(_tokenAmount \u003c= FounderBalances[msg.sender]);\r\n        // balances[_addr] = balances[_addr].add(_tokenAmount);\r\n        internaltransfer(msg.sender,_addr,_tokenAmount);\r\n         FounderBalances[msg.sender] = FounderBalances[msg.sender].sub(_tokenAmount);\r\n        // emit Transfer(msg.sender, addr, TokenAmount);\r\n      return true;\r\n    }\r\n    else if (_adminType == uint8(BrightCoinAdminType.Advisor))\r\n    {\r\n      require(_tokenAmount \u003c= AdvisorBalances[msg.sender]);\r\n      //balances[_addr] = balances[_addr].add(_tokenAmount);\r\n       internaltransfer(msg.sender,_addr,_tokenAmount);\r\n      AdvisorBalances[msg.sender] = AdvisorBalances[msg.sender].sub(_tokenAmount);\r\n     // emit Transfer(msg.sender, addr, TokenAmount);\r\n      return true;\r\n    }\r\n    else if(_adminType == uint8(BrightCoinAdminType.Team))\r\n    {\r\n      require(_tokenAmount \u003c= TeamBalances[msg.sender]);\r\n      //balances[_addr] = balances[_addr].add(_tokenAmount);\r\n       internaltransfer(msg.sender,_addr,_tokenAmount);\r\n      TeamBalances[msg.sender] = TeamBalances[msg.sender].sub(_tokenAmount);\r\n     // emit Transfer(msg.sender, addr, TokenAmount);\r\n      return true;\r\n\r\n    }  \r\n    \r\n    \r\n }\r\n */\r\n    //Check if token is available for further Distribution to Advisor\r\n function InternalTransferfrom(address _from , address _addr, uint256 _tokenamount)  internal returns(bool)\r\n {\r\n     \r\n        require(allowed[owner()][_from] \u003e= _tokenamount);\r\n        require(internaltransfer(_from, _addr, _tokenamount) == true);\r\n        allowed[owner()][_from] = allowed[owner()][_from].sub(_tokenamount);\r\n       \r\n       return true;\r\n }  \r\n \r\nfunction transferownership(address _newOwner) public onlyTokenOwner \r\n {\r\n     \r\n     require(_newOwner != 0x0);\r\n    balances[_newOwner] =  balances[_newOwner].add(balances[msg.sender]);\r\n     //To avoid reentrency \r\n   balances[msg.sender] = 0;\r\n   emit Transfer(msg.sender, _newOwner, balances[_newOwner]);\r\n   \r\n   \r\n  //FounderBalances[_newOwner] = FounderBalances[_newOwner].add(FounderBalances[msg.sender]);\r\n  //AdvisorBalances[_newOwner] = AdvisorBalances[_newOwner].add(AdvisorBalances[msg.sender]);\r\n // TeamBalances[_newOwner] = TeamBalances[_newOwner].add(TeamBalances[msg.sender]);\r\n CompanyHoldingBalances[_newOwner] = CompanyHoldingBalances[_newOwner].add(CompanyHoldingBalances[msg.sender]);\r\n\r\n    //To avoid reentrency \r\n // balances[msg.sender] = 0;\r\n//  FounderBalances[msg.sender] = 0;\r\n // AdvisorBalances[msg.sender] = 0;\r\n // TeamBalances[msg.sender] = 0;\r\n  \r\n   transferOwnership(_newOwner); // Transfer Ownership\r\n     \r\n     \r\n }\r\n\r\n\r\n\r\n}"},"BrightCoinFounderTokenDistribution.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\n\r\ncontract BrightCoinFounderTokenDistribution  is BrightCoinTokenOwner\r\n{\r\n\r\n  mapping(address =\u003e uint256)FounderBalances;\r\nusing SafeMath for uint;\r\n\r\n struct founderDistribution {\r\n       address founderAddress;\r\n       uint256 founderToken;\r\n       uint256 lockExpiryTime;\r\n       bool    founderActive;\r\n       bool    tokenlocked;\r\n    }\r\n    \r\n mapping(address =\u003e founderDistribution) founderTokenDetails;\r\n address[] internal founderAddrs;\r\n\r\nconstructor() public\r\n{\r\n \r\n}\r\n\r\n//Add Founder Starts\r\n\r\nfunction AddFounder(address _newFounder,uint256 _founderToken,uint256 _lockExpiryDateTime,\r\n bool _tokenLocked)   internal \r\n  {\r\n\r\n      founderDistribution storage  founderDetails = founderTokenDetails[_newFounder];\r\n    \r\n      founderDetails.founderAddress = _newFounder;\r\n      founderDetails.founderToken = _founderToken;\r\n      founderDetails.lockExpiryTime = _lockExpiryDateTime;\r\n      founderDetails.tokenlocked = _tokenLocked;\r\n      founderDetails.founderActive = true;\r\n      founderAddrs.push(_newFounder);\r\n    \r\n }\r\n\r\n\r\n  function  UpdateFounderTokenDetails(address _newFounder,uint256 _founderToken,\r\n  uint256 _lockExpiryDateTime) internal\r\n  {\r\n    require(CheckIfFounderActive(_newFounder) == true);   \r\n     //Add new Token amount and Set new locking Period\r\n      founderDistribution storage  founderDetails = founderTokenDetails[_newFounder];\r\n     founderDetails.founderToken  = founderDetails.founderToken.add(_founderToken);\r\n     founderDetails.lockExpiryTime = _lockExpiryDateTime;     \r\n  }\r\n\r\n//Remove Founder For Further Investment and from the Team\r\n function RemoveFounderFromFurtherInvestment(address _newFounderAddr)  public onlyTokenOwner  returns(bool)\r\n {\r\n   founderDistribution storage newFounderDetails = founderTokenDetails[_newFounderAddr];\r\n   newFounderDetails.founderActive = false;\r\n    \r\n    return true;\r\n\r\n }\r\n\r\n//ENDS\r\n\r\n//check if Founder Removed \r\n function CheckIfFounderActive(address _newFounderAddr) view internal returns(bool)\r\n {\r\n\r\n  founderDistribution storage founderDetails = founderTokenDetails[_newFounderAddr];\r\n if(founderDetails.founderActive == true)\r\n  {\r\n      return true;\r\n  }\r\n  \r\n  return false;\r\n\r\n }\r\n\r\n\r\n\r\n//Count total no of Advisors\r\n function TotalFounder() public view returns(uint256) \r\n {\r\n   return founderAddrs.length;\r\n  \r\n }\r\n\r\n\r\n //check Amount with Advisor\r\n function CheckFounderTokenAmount(address _newFounderAddr) view public returns(uint256)\r\n {\r\n\r\n  founderDistribution storage founderDetails = founderTokenDetails[_newFounderAddr];\r\n  return founderDetails.founderToken;\r\n   \r\n }\r\n\r\n}\r\n\r\n\r\n \r\n    "},"BrightCoinInvestorTokenLock_ICO.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\n\r\n\r\n\r\ncontract BrightCoinInvestorTokenLock is  BrightCoinTokenOwner\r\n{\r\n\r\n /**\r\n    * @dev Error messages for require statements\r\n    */\r\n   // string internal constant ALREADY_LOCKED = \u0027Tokens already locked\u0027;\r\n   // string internal constant NOT_LOCKED = \u0027No tokens locked\u0027;\r\n    //string internal constant AMOUNT_ZERO = \u0027Amount can not be 0\u0027;\r\n\r\nenum BrightCoinLockType { Investor, Admin,Bounty }\r\n      using SafeMath for uint;\r\n\r\n    /**\r\n     * @dev locked token structure\r\n     */\r\n    struct lockToken {\r\n        uint256 amount;\r\n        uint256 validity;\r\n        bool exists;\r\n        bool claimed;\r\n \r\n    }\r\n\r\n    /**\r\n     * @dev Holds number \u0026 validity of tokens locked for a given reason for\r\n     *      a specified address\r\n     */\r\n\r\n    mapping(address =\u003e lockToken)  locktokenDetails;\r\n\r\n    /**\r\n     * @dev Records data of all the tokens Locked\r\n     */\r\n    event Locked(\r\n        address indexed _of,\r\n        uint256 _amount,\r\n        uint256 _validity\r\n    );\r\n\r\n    /**\r\n     * @dev Records data of all the tokens unlocked\r\n     */\r\n    event Unlocked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount\r\n    );\r\n\r\n\r\n   constructor() public \r\n   {\r\n\t\r\n   }\r\n\r\n    function tokensLocked(address _of)\r\n        internal\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        uint256 am = 0;\r\n        lockToken storage AddrStruct =  locktokenDetails[_of];\r\n        if (!AddrStruct.claimed)\r\n            am = AddrStruct.amount;\r\n      \r\n            return am;\r\n    }\r\n    \r\n    function isTokenLockExpire(address _of, uint256 _time)  view internal  returns(bool)\r\n    {\r\n        bool retVal = false;\r\n\r\n       if(locktokenDetails[_of].validity \u003c _time)\r\n            return retVal = true;\r\n      \r\n            return retVal;\r\n    }\r\n\r\n    function getTokenLockExpiry(address _of)  view internal returns(uint256 )\r\n    {\r\n       return  locktokenDetails[_of].validity;\r\n    }\r\n\r\n\r\n    function isAddrExists(address _addr) view internal returns(bool)\r\n    {\r\n        \r\n       lockToken storage lockBounty = locktokenDetails[_addr];\r\n          return lockBounty.exists;\r\n       \r\n           \r\n    }\r\n    \r\n    \r\n    \r\n     function SetTokenLock(address _of, uint256 _time, \r\n         uint256 _amount)  internal   \r\n          {\r\n              \r\n               //uint256 validUntil = now.add(_time); //solhint-disable-line\r\n\r\n                 require(_amount != 0);\r\n                 require(_of != 0x0);\r\n\r\n                 lockToken storage AddrStruct =  locktokenDetails[_of];\r\n                 if(tokensLocked(_of) \u003e 0)\r\n                 {\r\n                      \r\n                        AddrStruct.amount = (AddrStruct.amount).add(_amount);\r\n                        AddrStruct.validity = _time;\r\n                 }\r\n                 else\r\n                 {\r\n        \r\n                        AddrStruct.amount = _amount;\r\n                        AddrStruct.validity = _time;\r\n                        AddrStruct.exists = true;\r\n                        AddrStruct.claimed = false;\r\n                 }\r\n          }\r\n\r\n          function IncreaseTokenAmount(address _addr, uint256 _validity,uint256 _amount)\r\n         internal \r\n        returns (bool)\r\n    {\r\n       \r\n        require(tokensLocked(_addr) \u003e 0);\r\n         lockToken storage AddrStruct =  locktokenDetails[_addr];\r\n        AddrStruct.amount = (AddrStruct.amount).add(_amount);\r\n        AddrStruct.validity = _validity;\r\n       \r\n       // emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\r\n        return true;\r\n        \r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n"},"BrightCoinRegulatedToken_ICO.sol":{"content":"\r\npragma solidity ^0.4.25;\r\n\r\n\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\nimport \"./BrightCoinERC20Contract_ICO.sol\";\r\n\r\n\r\n//Rules for Accredited Investors\r\n/*\r\n This is special BrightCoinToken that will allow User to invest to Token Only after Proper Checks and Validation as provide by US Regulatories Authorities\r\n*/\r\n\r\n/*\r\n import all specific contract that will help in Validation \r\n Accridetion\r\n KYC\r\n TokenDistribution Details\r\n*/\r\n\r\ncontract BrightCoinRegulatedToken  is BrightCoinERC20\r\n{\r\n\r\n//BrightCoinInvestorKYC InvestorKYCInfo;\r\n//BrightCoinInvestorCheck AccreditationInfo;\r\n\r\n\r\naddress public BrightCoinInvestorKYCAddress; \r\naddress public BrightCoinInvestorAccreditationAddress; \r\nmapping (uint8 =\u003e uint256) private PeriodTokenAmount;\r\nbool InvestorSecurity;\r\nbool KYCSupport;\r\n\r\nconstructor() public \r\n{\r\n InvestorSecurity = false;\r\n KYCSupport = false;\r\n}\r\n\r\n\r\n\r\n\r\n  \r\n  function DistributeToken(address _addrOfInvestor, uint256 _currenttime,\r\n                    uint256 _tokens, uint8 _mainSalePeriodIndex) public onlyTokenOwner \r\n  {\r\n\r\n      require(_addrOfInvestor != 0x0);\r\n      require(_currenttime \u003e0);\r\n   //   require(_tokenlockPeriod \u003e 0);\r\n      require(_tokens \u003e 0);\r\n\r\n   \r\n       \r\n        if((_mainSalePeriodIndex == 0) \u0026\u0026 (PreSaleOn == true))  //PreSale\r\n        {\r\n        \r\n       \r\n      \r\n            //Check if Period Hard cap achived \r\n\r\n            require(_tokens \u003c= getMaxCoinSoldDuringPreSale());\r\n            \r\n            //Check if ICO Hardcap achived\r\n            require(CheckIfHardcapAchived(_tokens) == true);\r\n            internaltransfer(msg.sender,_addrOfInvestor,_tokens);\r\n           // SetTokenLock(_addrOfInvestor,tokenTimeLock,_tokens);\r\n            updatepresalemaxTokenCount(_tokens);\r\n        }\r\n        else\r\n        {\r\n            //Calculate token amount\r\n            require(CheckIfMainSaleOn(_mainSalePeriodIndex) == true);\r\n            require(CheckTokenPeriodSale(_currenttime,_mainSalePeriodIndex) == true);\r\n            \r\n          \r\n      \r\n            require(CheckMainSaleLimit(_mainSalePeriodIndex,_tokens) == true, \"Main Sale Limit Crossed\");\r\n             \r\n            require(CheckIfHardcapAchived(_tokens) == true);\r\n            \r\n             internaltransfer(msg.sender,_addrOfInvestor,_tokens);\r\n           //  SetTokenLock(_addrOfInvestor,tokenTimeLock,_tokens);\r\n             updateCurrentTokenCount(_mainSalePeriodIndex,_tokens);\r\n        }\r\n  }\r\n\r\n function tranfertocustodian(address _to) public onlyTokenOwner returns(bool)\r\n{\r\n    internaltransfer(msg.sender, _to, balances[msg.sender]);\r\n    custodianaddress = _to;\r\n    return true;\r\n}\r\n\r\n  \r\n\r\nfunction regulatedtransfer( address _from , address _to, uint256 _tokens) private returns(bool) \r\n{\r\n    //check if locking period is expired or not \r\n      uint256 currenttime = now;\r\n      \r\n      if (InvestorSecurity == true)\r\n      {\r\n          \r\n           if(isTokenLockExpire(_from,currenttime) == true)\r\n           {\r\n               internaltransfer(_from,_to,_tokens);\r\n                return true;\r\n           }\r\n           \r\n           uint256 TokenLockExpiry = getTokenLockExpiry(_from); \r\n           require(TokenLockExpiry !=0);\r\n         \r\n         if( ICOType != uint8(BrightCoinICOType.Utility))\r\n         {\r\n        //    require(AccreditationInfo.checkBothInvestorValidity(_from,_to, ICOType) == true); \r\n            SetTokenLock(_to,TokenLockExpiry,_tokens);\r\n            internaltransfer(_from,_to,_tokens);\r\n            return true; \r\n         }\r\n         else\r\n         {\r\n          SetTokenLock(_to,TokenLockExpiry,_tokens);\r\n           internaltransfer(_from,_to,_tokens);\r\n           return true;\r\n         }\r\n            \r\n      }\r\n      else\r\n      {\r\n        // require(isTokenLockExpire(msg.sender,currenttime) == true);\r\n         internaltransfer(_from,_to,_tokens);\r\n         return true;\r\n      }\r\n      \r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _tokens) public returns (bool success) \r\n{\r\n      \r\n       require(pauseICO == false);  //if this flag is true the no operation is allowed.\r\n      require(_tokens \u003e 0);\r\n      require(allowed[_from][msg.sender] \u003e= _tokens);\r\n    \r\n     require(internaltransfer(_from ,_to,_tokens) == true);\r\n      //If regulated transfer is true then only reduce allowed map\r\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_tokens);\r\n      return true;\r\n}\r\n    \r\n\r\nfunction approve(address _spender, uint256 _value) public returns (bool success)\r\n {\r\n     require(_spender != address(0));\r\n    //  require(checkCompliance(_spender) == true);\r\n      allowed[msg.sender][_spender] = _value;\r\n      emit Approval(msg.sender, _spender, _value);\r\n      \r\n      return true;\r\n }\r\n  //This method will be called when investor  wants to tranfer token to other.  \r\nfunction transfer(address _to, uint _tokens) public returns (bool) \r\n {     \r\n    require(pauseICO == false);  //if this flag is true the no operation is allowed.\r\n    require(_to != address(0));\r\n    require (internaltransfer(msg.sender, _to,_tokens ) == true);\r\n   \r\n     emit Transfer(msg.sender, _to, _tokens);\r\n    return true;\r\n       \r\n      \r\n}\r\n      \r\n\r\n   function TransferCompanyHoldingTokens() public onlyTokenOwner     returns(bool)\r\n  { \r\n    \r\n      require(CompanyHoldingBalances[msg.sender] == CompanyHoldingValue) ; \r\n   //   uint256 Holdinglockexpiry = now.add(_lockExpiry);\r\n     // balances[CompanyHoldingAddress] = CompanyHoldingBalances[msg.sender];\r\n      internaltransfer(msg.sender,CompanyHoldingAddress,CompanyHoldingValue);\r\n    CompanyHoldingBalances[msg.sender] = 0;\r\n  // SetTokenLock(CompanyHoldingAddress,Holdinglockexpiry,CompanyHoldingValue);\r\n    //  emit Transfer(msg.sender, CompanyHoldingAddress, CompanyHoldingValue);\r\n      return true;\r\n\r\n } \r\n \r\n\r\n\r\n}"},"BrightCoinTeamTokenDistribution_ICO.sol":{"content":"\r\npragma solidity ^0.4.25;\r\n\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\n\r\ncontract BrightCoinTeamTokenDistribution  is BrightCoinTokenOwner\r\n{\r\n\r\n\r\n  mapping(address =\u003e uint256)TeamBalances;\r\nconstructor() public\r\n{\r\n \r\n}\r\n\r\n//Team Distribution  \r\n //There might be multiple entry to this\r\n uint256 public TotalAllocatedTeamToken;\r\n \r\n \r\n struct teamDistribution {\r\n        address addr;\r\n        uint256 tokenamount;\r\n        uint256 lockexpiry;\r\n        bool   teamActiveInvestor;  //To Ensure if team is still on\r\n        bool tokenlocked;\r\n    \r\n    }\r\n\r\n mapping(address =\u003e teamDistribution) teamDistributionDetails;\r\n address[] public teamTokenDetailsAddr;\r\n \r\n\r\n //Team Token Distribution  Starts\r\n\r\n//Addng Details to Team Token\r\n function AddTeam(address _newTeamAddr,uint256 _tokenamount,\r\n uint256 _lockexpirydate,\r\n bool _tokenLocked)  internal {\r\n     \r\n  teamDistribution storage teamDetails = teamDistributionDetails[_newTeamAddr];\r\n    teamDetails.addr = _newTeamAddr;\r\n    teamDetails.tokenamount = _tokenamount;\r\n    teamDetails.lockexpiry = _lockexpirydate;\r\n    teamDetails.teamActiveInvestor = true;\r\n    teamDetails.tokenlocked = _tokenLocked;\r\n    teamTokenDetailsAddr.push(_newTeamAddr);\r\n\r\n }\r\n\r\n function UpdateTeamTokenDetails(address _teamaddr,\r\n                            uint256 _tokenamount,\r\n                            uint256 _lockExpiryDateTime) internal\r\n {\r\n       //check if Team is Active\r\n       require(CheckIfTeamActive(_teamaddr) == true);\r\n      teamDistribution storage teamDetails = teamDistributionDetails[_teamaddr];\r\n \r\n      teamDetails.tokenamount += _tokenamount;\r\n      teamDetails.lockexpiry = _lockExpiryDateTime;\r\n  \r\n }\r\n\r\n function RemoveTeamFromFurtherInvestment(address _newTeamAddr) public onlyTokenOwner  \r\n {\r\n    teamDistribution storage teamDetails = teamDistributionDetails[_newTeamAddr];\r\n    teamDetails.teamActiveInvestor = false;\r\n\r\n }\r\n\r\n\r\n\r\n function TotalTeamnvestor() public view returns(uint256) \r\n {\r\n   return teamTokenDetailsAddr.length;\r\n  \r\n }\r\n\r\n//check if Team Removed \r\n function CheckIfTeamActive(address _teamAddr) view internal returns(bool)\r\n {\r\n\r\n  teamDistribution storage teamDetails = teamDistributionDetails[_teamAddr];\r\n\r\n  if(teamDetails.teamActiveInvestor == true)\r\n  {\r\n      return true;\r\n  }\r\n  return false;\r\n\r\n }\r\n\r\n //check Amount with Advisor\r\n function CheckTeamTokenAmount(address _newTeamAddr) view public returns(uint256)\r\n {\r\n\r\n  teamDistribution storage teamDetails = teamDistributionDetails[_newTeamAddr];\r\n        return teamDetails.tokenamount;\r\n\r\n }\r\n\r\n}"},"BrightCoinTokenConfig_ICO.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\ncontract BrightCoinTokenConfig\r\n{\r\n\r\n    //Token Details  \r\n  string public constant symbol = \"BDLR\"; // This is token symbol\r\n  string public constant name = \"BDollar\"; // this is token name\r\n  uint256 public constant decimals = 18; // decimal digit for token price calculation\r\n  string public constant version = \"1.0\";\r\n\r\n  uint256 public constant initialSupply = 3000000000;\r\n\r\n   //For Presales Only \r\n    uint256  public constant maxCoinSoldDuringPresale = 400000000;\r\n    uint256  public constant BonusAmountPreSale = 0; //To be calculated from outside\r\n    uint8    public constant Discount = 0; // to be calculated from outside\r\n\r\n     //PreSale Start \u0026 End Dates \r\n    uint256 internal ICOstartDate = 1561161600; //22/06/2019 00:00 UTC\r\n    uint256 internal ICOendDate =  1569193200;   //22/09/2019 23:00 UTC\r\n\r\n     //Presale Maximum and Minmum Contributions\r\n    uint256  internal MinimumContribution = 0.0 ether;\r\n    uint256  internal MaximumContribution = 0.0 ether;\r\n\r\n    //purchase rate can be changed by the Owner\r\n     uint256 public purchaseRate = 0;\r\n\r\n    enum BrightCoinICOType { RegD, RegS, RegDRegS, Utility }\r\n    uint8 public constant ICOType = uint8(BrightCoinICOType.Utility);   //0 for RegD , 1 for RegS and 2 for RedDRegS and 3 means utility ICO\r\n\r\n   uint256 public constant InitialFounderToken = 0;\r\n   uint256 internal constant InitialAllocatedTeamToken = 0;  // Token token allocated for Team distribution\r\n   uint256 internal constant InitialAllocatedAdvisorToken = 0;\r\n\r\n\r\n   uint internal icoSoftcap = 0; //Minimum Eather to Reach\r\n   uint internal icoHardcap = 2400000000;\r\n\r\n    //Investment storage address\r\n  address public constant FundDepositAddress = 0x00; //Should be taken from Script \r\n\r\n   //Company Holdings\r\n address public constant CompanyHoldingAddress = 0x7027F37e7d67E5656954483181dE674A61c0A6BD; //company Holding adddress\r\n uint256 public constant InitialCompanyHoldingValue = 600000000;// Value to be updated via Script\r\n\r\n//Bounty Token Distribution\r\nuint256 public constant totalBountyAllocated = 0;\r\naddress public  constant BountyTokenHolder = 0x00; //This address own the token and finally transfer\r\n\r\n\r\n\r\n}"},"BrightCoinTokenDistributionDetails_ICO.sol":{"content":"\r\npragma solidity ^0.4.24;\r\n\r\nimport \"./BrightCoinTeamTokenDistribution_ICO.sol\"; \r\nimport \"./BrightCoinFounderTokenDistribution.sol\"; \r\nimport \"./BrightCoinAdvisorTokenDistribution.sol\"; \r\nimport \"./SafeMath.sol\";\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\n\r\ncontract BrightCoinTokenDistributionDetails is BrightCoinAdvisorTokenDistribution,BrightCoinTeamTokenDistribution,BrightCoinFounderTokenDistribution\r\n{\r\n\r\nusing SafeMath for uint;\r\n\r\nconstructor() public\r\n{\r\n \r\n}\r\n\r\n\r\n  //Token distribution details\r\n  /////////////////////////////////////////\r\n  //Token Distribution Details --- Founder \r\n //The distribution amount, Timelock  is fixed   \r\n //Rewards Token : The Amount of token to be used for Bounty and Rewards\r\n  uint256 public constant InitialRewardsBountyToken = 1000; //To be updated via Script\r\n  uint256 public constant RewardBountylockinPeriod  = 234567;  \r\n  uint256 public RewardsBountyToken;\r\n\r\n\r\n //Company Holdings\r\n address public constant CompanyHoldingAddress = 0xcf530e5b154EB28A379cF5774d5d15B04cF10422;//To be updated via Script\r\n uint256 public constant InitialCompanyHoldingValue = 1000;// Value to be updated via Script\r\n uint256 public CompanyHoldingValue;\r\n uint256 public constant CompanyHoldinglockingPeriod = 123456; //Token LockTIme\r\n \r\n \r\n} "},"BrightCoinTokenOwner_ICO.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract BrightCoinTokenOwner \r\n{\r\n  address private _owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyTokenOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n  \r\n\r\n  /*modifier onlyTokenOwner(address _account) {\r\n        require(msg.sender == _account, \"Owner Not Authorized\");\r\n        _;\r\n    }\r\n    */\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n  \r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() internal  {\r\n    emit OwnershipRenounced(_owner);\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) internal \r\n   {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    _owner = _newOwner;\r\n    emit OwnershipTransferred(_owner, _newOwner);\r\n  }\r\n\r\n}\r\n"},"BrightCoinTokenSaleType_ICO.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\nimport \"./BrightCoinTokenOwner_ICO.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./BrightCoinTokenConfig_ICO.sol\";\r\n\r\n//Section1\r\n//...............................................................................\r\ncontract BrightCoinTokenPreSaleDetails is BrightCoinTokenOwner, BrightCoinTokenConfig\r\n{\r\n\r\n    //address owner;\r\n    using SafeMath for uint;\r\n    uint256 Availabletokenpresale;\r\n    constructor() public\r\n    { \r\n        Availabletokenpresale = maxCoinSoldDuringPresale*(10**uint256(decimals));\r\n    }\r\n\r\n  \r\n    //Current Presale Status \r\n    bool public PreSaleOn = true;\r\n \r\n     //Function for changing the startDate of Presale\r\n    function changeStartDate(uint256 _startDateTimeStamp, uint256 _currenttime) public onlyTokenOwner  returns(bool){\r\n\r\n    require(ICOstartDate \u003e _currenttime );\r\n    require( _startDateTimeStamp \u003c ICOendDate );\r\n    ICOstartDate = _startDateTimeStamp;\r\n    return true;\r\n  }\r\n\r\n    function getMaxCoinSoldDuringPreSale() view internal  returns(uint256)\r\n    {\r\n        return Availabletokenpresale;\r\n        \r\n    }\r\n\r\n    /**\r\n   * @dev It changes end date of Presale , provided it is not crossed.\r\n   * @param _endDateTimeStamp The new proposed end datetime for Presale.\r\n   */\r\n    function changeEndDate(uint256 _endDateTimeStamp,uint256 _currenttime) public onlyTokenOwner  returns(bool) \r\n    {\r\n      require(ICOendDate \u003e _currenttime);\r\n      require( _endDateTimeStamp \u003e ICOstartDate );\r\n      ICOendDate = _endDateTimeStamp;\r\n      return true;\r\n    }\r\n    \r\n    /**\r\n   * @dev It check whether the datetime passed is in presale period or not\r\n   * @param _currenttime The datetime to be checked for presale period.\r\n   */\r\n     function inPreSalePeriod(uint256 _currenttime) public view returns (bool) {\r\n      if (_currenttime \u003e= ICOstartDate \u0026\u0026 _currenttime \u003c= ICOendDate) \r\n          return true;\r\n      else \r\n          return false;     \r\n     }\r\n\r\n    /**\r\n   * @dev It will change the presale status or true/false depending upon input\r\n   * @param _presalestatus the staus to be set with presale.\r\n   */\r\n     function changePresaleStatus(bool _presalestatus) public onlyTokenOwner \r\n     {\r\n       PreSaleOn = _presalestatus;\r\n     }\r\n     \r\n   function updatepresalemaxTokenCount(uint256 _token) internal \r\n  {\r\n       Availabletokenpresale = Availabletokenpresale.sub(_token);\r\n  }\r\n}\r\n\r\n//Section2\r\n//..........................................................................\r\ncontract BrightCoinTokenMainSaleDetails  is BrightCoinTokenOwner, BrightCoinTokenConfig\r\n{\r\n   //For MainSale\r\nstruct mainSaleTokenDistrubution\r\n{\r\n    uint256 mainStartDate;\r\n    uint256 mainSaleEndDate ;\r\n    uint256 maxCoinSold;\r\n  // uint256 currentTokenCount;\r\n    uint256 discount;\r\n    bool    periodActive;\r\n    uint8  periodIndex;\r\n    bool exists;\r\n}\r\n\r\n //address owner;\r\n  using SafeMath for uint;\r\n  \r\nconstructor() public\r\n{\r\n \r\n}\r\n\r\nmapping(uint256 =\u003e mainSaleTokenDistrubution) mainSaleCountMapping;\r\nuint256[] internal  mainSaleList;\r\n mapping (uint8 =\u003e uint256) private PeriodTokenAmount;\r\n\r\n /**\r\n   * @dev It add mainsale period details \r\n   * @param _mainStartDate Start date of curent mainsale period\r\n   * @param _mainSaleEndDate End Date of MainSale\r\n   * @param _maxCoinSold Maximum coin sold during this period\r\n   * @param _discount Bonus if any for this sale period\r\n   * @param _periodIndex Period Index so that MainSale period can be tracked.\r\n   * @param _periodActive  Setting current period state.\r\n   */\r\nfunction AddMainSalePeriod(uint256 _mainStartDate,uint256 _mainSaleEndDate,uint256 _maxCoinSold,\r\n                        uint256 _discount,uint8 _periodIndex,\r\n                         bool _periodActive) public onlyTokenOwner  returns(bool)\r\n   {\r\n\r\n      mainSaleTokenDistrubution storage mainSale = mainSaleCountMapping[_periodIndex];\r\n      require(mainSale.exists == false); //To ensure that it is  new instance\r\n      \r\n      mainSale.mainStartDate  = _mainStartDate;\r\n      mainSale.mainSaleEndDate = _mainSaleEndDate;\r\n      mainSale.maxCoinSold = _maxCoinSold.mul(10**uint256(decimals));\r\n     mainSale.discount = _discount;\r\n      mainSale.periodIndex = _periodIndex; \r\n      mainSale.periodActive = _periodActive;\r\n      mainSale.exists = true;\r\n\r\n      mainSaleList.push(_periodIndex);\r\n      return true;\r\n    }                                                      \r\n                            \r\n\r\n   /**\r\n   * @dev It check whenther current datetime fits is given mainsale period\r\n   * @param _dateTimeStamp to be verified.\r\n   * @param _periodIndex mainSale period Index\r\n   */\r\n function CheckTokenPeriodSale(uint256 _dateTimeStamp, uint8 _periodIndex) public onlyTokenOwner  view returns(bool) {\r\n\r\n        mainSaleTokenDistrubution storage mainSaleTokenSale = mainSaleCountMapping[_periodIndex];\r\n       require(mainSaleTokenSale.mainStartDate !=0);\r\n        require(mainSaleTokenSale.mainSaleEndDate !=0);\r\n\r\n        if( (mainSaleTokenSale.mainStartDate \u003c _dateTimeStamp) \u0026\u0026 (mainSaleTokenSale.mainSaleEndDate \u003e _dateTimeStamp) )\r\n        return true;\r\n\r\n        return false;\r\n        \r\n  }\r\n\r\n  /**\r\n   * @dev It check bonus details for given mainSale Period \r\n   * @param _periodIndex period to be verfied.\r\n   */\r\n function getMainSaleDiscount(uint8 _periodIndex)  internal view returns(uint256) {\r\n\r\n        mainSaleTokenDistrubution storage mainSaleToken = mainSaleCountMapping[_periodIndex];\r\n        return mainSaleToken.discount;\r\n  }\r\n\r\n   /**\r\n   * @dev It ends mainSale for s given period \r\n   * @param _periodIndex period to be End.\r\n   */\r\n  function EndMainSale(uint8 _periodIndex) public onlyTokenOwner \r\n  {\r\n\r\n  mainSaleTokenDistrubution storage mainSaleTokenSale = mainSaleCountMapping[_periodIndex];\r\n  mainSaleTokenSale.periodActive = false;\r\n\r\n  //Whether we need to give refund instantly  , to be managed by Application not Samrt contract\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Check if mainSale is On  for a particular period\r\n   * @param _periodIndex period to be verfied.\r\n   */\r\n function CheckIfMainSaleOn(uint8 _periodIndex)  public view returns(bool) {\r\n\r\n        mainSaleTokenDistrubution storage mainSaleTokenSale = mainSaleCountMapping[_periodIndex];\r\n        return(mainSaleTokenSale.periodActive);\r\n        \r\n  }\r\n\r\n\r\n /**\r\n   * @dev It returns total mainSale count\r\n   */\r\n  function MainSaleCount() view public returns(uint256)\r\n  {\r\n     return mainSaleList.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Check limit of main sale for a particular \r\n   * @param _periodIndex period to be verfied.\r\n   * @param  _tokenamount to be compared with maximit\r\n   */\r\n   \r\n   // @param  _decimalValue this value to multipled with value so that compare uint become same\r\n  function CheckMainSaleLimit( uint8 _periodIndex, uint256 _tokenamount) view public returns(bool)\r\n  {\r\n\r\n    mainSaleTokenDistrubution storage mainSaleTokenSale = mainSaleCountMapping[_periodIndex];\r\n\r\n  //  uint256 maxCoinSoldDecimal = (mainSaleTokenSale.maxCoinSold).mul(10**uint256(_decimalValue));\r\n    if(_tokenamount \u003c= mainSaleTokenSale.maxCoinSold )\r\n      return true;\r\n\r\n      return false;\r\n\r\n  }\r\n\r\n/**\r\n   * @dev it changes the limit of max token that can be sold in this period\r\n   * @param _periodIndex period to be verfied.\r\n   * @param _maxTokenTobeSold  maximum token to be sold\r\n   */\r\n  function changeMainSaleLimit( uint8 _periodIndex, uint256 _maxTokenTobeSold) public onlyTokenOwner  \r\n  {\r\n\r\n  mainSaleTokenDistrubution storage mainSaleTokenSale = mainSaleCountMapping[_periodIndex];\r\n  mainSaleTokenSale.maxCoinSold = _maxTokenTobeSold.mul(10**uint256(decimals));\r\n\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev it changes the limit of max token that can be sold in this period\r\n   * @param _currenttime check current time for mainSale\r\n   */\r\n  function checkMainSalePeriod( uint256 _currenttime) view internal returns(uint256)\r\n  {\r\n\r\n  if(mainSaleList.length  == 0)\r\n    return 0;\r\n  //get first MainSale period Index\r\n  uint8 periodindex;\r\n  for(periodindex = 0; periodindex \u003c=mainSaleList.length; periodindex++)\r\n  {\r\n  mainSaleTokenDistrubution storage mainSaleTokenSale = mainSaleCountMapping[periodindex];\r\n  if( (mainSaleTokenSale.mainStartDate \u003c= _currenttime) \u0026\u0026 \r\n                      (_currenttime \u003c=mainSaleTokenSale.mainSaleEndDate) )\r\n  {\r\n       return mainSaleTokenSale.periodIndex;\r\n  }\r\n\r\n  }\r\n  \r\n  return 0;\r\n\r\n  }\r\n  \r\n  function updateCurrentTokenCount(uint8 _periodIndex, uint256 _token) internal \r\n  {\r\n        mainSaleTokenDistrubution storage mainSaleTokenSale = mainSaleCountMapping[_periodIndex];\r\n        mainSaleTokenSale.maxCoinSold = mainSaleTokenSale.maxCoinSold.sub(_token);\r\n  }\r\n  \r\n  \r\n  \r\n}\r\n    \r\n\r\n \r\n    "},"SafeMath.sol":{"content":"pragma solidity ^0.4.24;\r\n  \r\nlibrary SafeMath {\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // assert(_b \u003e 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = _a / _b;\r\n        require(_a == _b * c + _a % _b); // There is no case in which this doesnt hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b \u003c= _a);\r\n        return _a-_b;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c \u003e= _a);\r\n        return c;\r\n    }\r\n}\r\n\r\n"}}