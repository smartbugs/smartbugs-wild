{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "byzantium",
    "libraries": {},
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "/home/cashlink/stokera-token/contracts/Policy.sol": {
      "content": "pragma solidity ^0.5.3;\n\nimport './SignatureManager.sol';\n\n// For policy contracts, it is important that there is some check on msg.sender\n// so as to avoid race windows where an attacker can replay a signature\n// against the contract directly, thereby potentially producing a denial of service\ninterface IPolicy {\n    // The caller MUST ensure that the value \"action\" is also part of the input\n    // for the given hash value, or there will be no binding between the action\n    // and the action parameters.\n    function tryAuthorize(string calldata action,\n                       bytes32 hash,\n                       address sender,\n                       bytes calldata sig)\n        external\n        returns (bool);\n\n    // Asserting version of tryAuthorize\n    function authorize(string calldata action,\n                       bytes32 hash,\n                       address sender,\n                       bytes calldata sig)\n        external;\n}\n\n// Sender- OR signature-based validation\ncontract SingleAuthorityPolicy is SignatureManager, IPolicy {\n    mapping(address => bool) subjectSet;\n    address public authority;\n    address public newAuthority;\n\n    function initSingleAuthorityPolicy(address _authority) internal {\n        authority = _authority;\n        newAuthority = address(0);\n    }\n\n    modifier onlyAuthority() {\n        require(msg.sender == authority, \"Called by non-authority\");\n        _;\n    }\n\n    function setAuthority(address _newAuthority)\n        onlyAuthority\n        external\n    {\n        newAuthority = _newAuthority;\n    }\n\n    function acceptAuthority() external {\n        require(newAuthority == msg.sender);\n        authority = newAuthority;\n        newAuthority = address(0);\n    }\n\n    modifier validatesSignature() {\n        // This check is important to avoid race conditions where an attacker\n        // uses up a signature and causes a DoS by sending it to the policy contract\n        // directly.\n        require(subjectSet[msg.sender]);\n        _;\n    }\n\n    function isSubject(address subject) public view returns (bool) {\n        return subjectSet[subject];\n    }\n\n    function addSubject(address subject) public onlyAuthority {\n        require(msg.sender == authority);\n        subjectSet[subject] = true;\n    }\n\n    function removeSubject(address subject) public onlyAuthority {\n        require(msg.sender == authority);\n        subjectSet[subject] = false;\n    }\n\n    function tryAuthorize(string memory /*action*/,\n                       bytes32 hash,\n                       address _sender,\n                       bytes memory sig)\n        public\n        validatesSignature\n        returns (bool)\n    {\n        if (_sender == authority) {\n            // Fast path\n            return true;\n        }\n        return tryCheckAndUseSignatureImpl(hash, sig, authority);\n    }\n\n    function authorize(string calldata action,\n                       bytes32 hash,\n                       address sender,\n                       bytes calldata sig)\n        external\n        validatesSignature\n    {\n        bool success = tryAuthorize(action, hash, sender, sig);\n        require(success, \"Unauthorized: Invalid signature\");\n    }\n\n    function addSubjectWithSignature(address subject, bytes calldata sig) external {\n        bytes32 hash = keccak256(abi.encode(\n            \"AddSubject\",\n            address(this),\n            subject));\n        checkAndUseSignatureImpl(hash, sig, authority);\n        subjectSet[subject] = true;\n    }\n\n    function removeSubjectWithSignature(address subject, bytes calldata sig) external {\n        bytes32 hash = keccak256(abi.encode(\n            \"RemoveSubject\",\n            address(this),\n            subject));\n        checkAndUseSignatureImpl(hash, sig, authority);\n        subjectSet[subject] = false;\n    }\n\n    function revokeNonce(uint256 nonce) external onlyAuthority {\n        revokeNonceImpl(nonce);\n    }\n\n    function revokeNonceWithSignature(uint256 nonce, bytes calldata sig) external {\n        revokeNonceWithSignatureImpl(nonce, sig, authority);\n    }\n\n    function isNonceValid(uint256 nonce) external view returns (bool) {\n        return isNonceValidImpl(nonce);\n    }\n\n    function isNonceUsed(uint256 nonce) external view returns (bool) {\n        return isNonceUsedImpl(nonce);\n    }\n\n    function isNonceRevoked(uint256 nonce) external view returns (bool) {\n        return isNonceRevokedImpl(nonce);\n    }\n\n    function () external payable { revert(); }\n}\n"
    },
    "/home/cashlink/stokera-token/contracts/SignatureManager.sol": {
      "content": "pragma solidity ^0.5.3;\n\ncontract SignatureManager {\n    // If this changes, the prefix string also has to change\n    uint256 private constant EXTRA_LEN = 8 + 8 + 20 + 20;\n    uint256 private constant PREFIX_STRING =\n        // (\"\\x19Ethereum Signed Message:\\n%d\" % (EXTRA_LEN + 32)).encode('hex')\n        0x19457468657265756d205369676e6564204d6573736167653a0a3838;\n\n    uint256 private constant EC_LEN = 32 + 32 + 1;\n    uint256 private constant SIG_LEN = EXTRA_LEN + EC_LEN;\n\n    uint256 private constant SIGNATURE_VERSION = 1;\n\n    event NonceUsed(uint256 nonce);\n    event NonceRevoked(uint256 nonce);\n\n    enum NonceStatus {\n        Unused, Used, Revoked\n    }\n    mapping(uint256 => NonceStatus) nonceStatus;\n\n    struct SignatureParams {\n        uint128 expiresAt;\n        uint128 version;\n        uint256 nonce;\n        uint256 dependentNonce;\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    // Adapted from\n    // https://programtheblockchain.com/posts/2018/02/17/signing-and-verifying-messages-in-ethereum/\n    // Also see https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/ECRecovery.sol\n    //\n    // It will take a bytestring and an offset, and extracts several values\n    // from the signature at the given offset of the bytestring:\n    //   * expiry date: an simple timestamp after which the signature is invalid\n    //   * nonce: a unique integer value used to identify the signature\n    //   * r, s, v: ECDSA signature\n    //\n    // Format:\n    //   256 bit / 32 byte   length (Solidity \"bytes\" prefix)\n    //    64 bit /  8 byte   expiry time\n    //   160 bit / 20 byte   nonce\n    //   160 bit / 20 byte   dependent nonce\n    //   256 bit / 32 byte   r\n    //   256 bit / 32 byte   s\n    //     8 bit /  1 byte   v\n    function splitSignature(bytes memory sig, uint256 offset)\n        internal pure returns (SignatureParams memory params)\n    {\n        require(offset < sig.length && sig.length - offset >= SIG_LEN);\n        uint128 expiresAt;\n        uint128 version;\n        uint256 nonce;\n        uint256 dependentNonce;\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        uint256 ptr;\n\n        assembly {\n            // seek to requested signature, ptr now point to 32-byte *before* the\n            // current signature\n            ptr := add(sig, offset)\n\n            // 8 bytes expiry time\n            ptr := add(ptr, 8)\n            expiresAt := and(mload(ptr), 0xffffffffffffffff)\n\n            // 8 bytes version\n            ptr := add(ptr, 8)\n            version := and(mload(ptr), 0xffffffffffffffff)\n\n            // 20 bytes nonce\n            ptr := add(ptr, 20)\n            nonce := and(mload(ptr), 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // 20 bytes dependent nonce\n            ptr := add(ptr, 20)\n            dependentNonce := and(mload(ptr), 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // 32 bytes r\n            ptr := add(ptr, 32)\n            r := mload(ptr)\n\n            // 32 bytes s\n            ptr := add(ptr, 32)\n            s := mload(ptr)\n\n            // 1 byte v\n            ptr := add(ptr, 32)\n            v := byte(0, mload(ptr))\n        }\n\n        // web3 creates signatures with v in {0,1,2,3} instead of {27,28,29,30}\n        //\n        // ecrecover of course expects the latter.\n        if (v < 27)\n            v += 27;\n\n        params.expiresAt = expiresAt;\n        params.version = version;\n        params.nonce = nonce;\n        params.dependentNonce = dependentNonce;\n        params.r = r;\n        params.s = s;\n        params.v = v;\n    }\n\n    function isNonceValidImpl(uint256 nonce) internal view returns (bool) {\n        return nonceStatus[nonce] == NonceStatus.Unused;\n    }\n\n    function isNonceUsedImpl(uint256 nonce) internal view returns (bool) {\n        return nonceStatus[nonce] == NonceStatus.Used;\n    }\n\n    function isNonceRevokedImpl(uint256 nonce) internal view returns (bool) {\n        return nonceStatus[nonce] == NonceStatus.Revoked;\n    }\n\n    function revokeNonceImpl(uint256 nonce) internal {\n        require(nonceStatus[nonce] == NonceStatus.Unused, \"Nonce must be unused\");\n        emit NonceRevoked(nonce);\n        nonceStatus[nonce] = NonceStatus.Revoked;\n    }\n\n    function makePrefixedHash(bytes32 message, bytes memory sig, uint256 offset)\n        internal pure\n        returns (bytes32)\n    {\n        uint256 extraLen = EXTRA_LEN;  // copy for inline assembly code\n        uint256 prefixStr = PREFIX_STRING;  // copy for inline assembly code\n        uint256 len = 28 + 32 + EXTRA_LEN;\n        bytes memory preimage = new bytes(len);\n        uint256 dst;\n        uint256 src;\n        assembly {\n            // because of 32-byte size header, this points to last 32-byte word\n            // of destination buffer\n            dst := add(preimage, len)\n\n            // because of 32-byte size header, this points to last 32-byte word\n            // of signature params\n            src := add(sig, add(offset, extraLen))\n\n            // Copy 64 bytes (at least extraLen are needed)\n            mstore(dst, mload(src))\n            dst := sub(dst, 32)\n            src := sub(src, 32)\n            mstore(dst, mload(src))\n\n            dst := add(preimage, 60) // 32 + 28 = size prefix + message\n            mstore(dst, message)\n\n            dst := add(preimage, 28)\n            // \"\\x19Ethereum Signed Message:\\n\" ...\n            mstore(dst, prefixStr)\n\n            // Fix length field\n            mstore(preimage, len)\n        }\n        return keccak256(preimage);\n    }\n\n    struct SignatureCheckResult {\n        bool valid;\n        uint256 nonce;\n    }\n\n    function isValidNonce(uint256 nonce) private view returns (bool) {\n        require(nonce != 0, \"nonce should never be 0\");\n        return nonceStatus[nonce] == NonceStatus.Unused;\n    }\n\n    function isValidDependentNonce(uint256 depNonce) private view returns (bool) {\n        return depNonce == 0 || nonceStatus[depNonce] == NonceStatus.Used;\n    }\n\n    function isValidExpiryTime(uint128 expiresAt) private view returns (bool) {\n        return expiresAt == 0 || expiresAt >= now;\n    }\n\n    event DebugSignatureParams(uint128 expiresAt, uint128 version,\n                               uint256 nonce, uint256 dependentNonce,\n                               bytes32 r, bytes32 s, uint8 v, address signedBy);\n\n    // Verifies a signature chain\n    // This should never be used outside of testing or checkAndUseSignatureImpl\n    function checkSignatureChain(bytes32 message,\n                                 bytes memory sig,\n                                 address authority,\n                                 uint256 offset,\n                                 uint256 end)\n        internal\n        view\n        returns (SignatureCheckResult memory result)\n    {\n        require(\n            offset <= sig.length &&\n            end <= sig.length &&\n            offset < end &&\n            (end - offset) % SIG_LEN == 0);\n\n        bytes32 currentMessage = message;\n\n        result.valid = false;\n        result.nonce = 0;\n\n        uint256 idx = 0;\n        uint256 start = offset;\n        while (offset < end) {\n            SignatureParams memory params = splitSignature(sig, offset);\n\n            address signedBy = ecrecover(makePrefixedHash(currentMessage, sig, offset),\n                                         params.v, params.r, params.s);\n            //emit DebugSignatureParams(params.expiresAt, params.version,\n                                      //params.nonce, params.dependentNonce,\n                                      //params.r, params.s, params.v,\n                                      //signedBy);\n\n            if (signedBy == address(0)\n                    || !isValidExpiryTime(params.expiresAt)\n                    || !isValidNonce(params.nonce)\n                    || !isValidDependentNonce(params.dependentNonce)\n                    || params.version != SIGNATURE_VERSION)\n            {\n                // Early exit because of error. The caller MUST ignore the\n                // partially uninitialized nonces array\n                return result;\n            }\n\n            if (offset == start) {\n                // Only the first nonce (for the single non-SigningAuthority\n                // signature in the chain) will be consumed\n                result.nonce = params.nonce;\n            }\n\n            if (signedBy == authority) {\n                result.valid = true;\n                require(offset + SIG_LEN == end);\n                return result;\n            }\n\n            currentMessage = keccak256(abi.encode(\n                \"SigningAuthority\", signedBy));\n\n            offset += SIG_LEN;\n            ++idx;\n        }\n        require(offset == end);\n    }\n\n    event DebugHeader(uint256 header, address auth, uint256 len);\n    event DebugValidSignature(uint256 offset);\n\n    function checkSignatureImpl(bytes32 message, bytes memory sig, address authority)\n        internal\n        view\n        returns (SignatureCheckResult memory result)\n    {\n        uint256 offset = 0;\n        while (offset < sig.length) {\n            // offset < sig.length checked just now, so LHS cannot underflow\n            require(sig.length - offset >= 0x20);\n            uint256 header;\n            assembly {\n                // skip length field and seek to offset\n                header := mload(add(sig, add(0x20, offset)))\n            }\n            address signatureAuthority = address(header >> (256 - 160));\n            uint256 len = header & 0xffffffff;\n\n            // RHS cannot overflow due to len < 2^32\n            require(sig.length - offset >= 0x20 + len);\n\n            //emit DebugHeader(header, auth, len);\n            offset += 0x20;\n            if (signatureAuthority == authority) {\n                result = checkSignatureChain(message, sig, authority, offset, offset + len);\n                if (result.valid) {\n                    //emit DebugValidSignature(offset);\n                    return result;\n                }\n            }\n            offset += len;\n        }\n        result.valid = false;\n    }\n\n    function consumeNonce(uint256 nonce) internal {\n        require(nonce != 0, \"nonce should never be 0\");\n        require(nonceStatus[nonce] == NonceStatus.Unused, \"Nonce must be unused\");\n        // TODO how expensive is yielding this event?\n        emit NonceUsed(nonce);\n        nonceStatus[nonce] = NonceStatus.Used;\n    }\n\n    // Checks a signature and marks single-use signatures as used in case\n    // of successful verification.\n    function tryCheckAndUseSignatureImpl(bytes32 message, bytes memory sig,\n                                         address authority)\n        internal\n        returns (bool)\n    {\n        SignatureCheckResult memory result =\n            checkSignatureImpl(message, sig, authority);\n        if (!result.valid) {\n            return false;\n        }\n        require(result.nonce != 0);\n        consumeNonce(result.nonce);\n        return true;\n    }\n\n    function checkAndUseSignatureImpl(bytes32 message, bytes memory sig, address authority)\n        internal\n    {\n        bool success = tryCheckAndUseSignatureImpl(message, sig, authority);\n        require(success, \"Invalid signature\");\n    }\n\n\n    function revokeNonceWithSignatureImpl(uint256 nonce, bytes memory sig,\n                                          address authority) internal {\n        bytes32 hash = keccak256(abi.encode(\n            \"NonceRevocation\",\n            address(this),\n            nonce));\n        checkAndUseSignatureImpl(hash, sig, authority);\n        revokeNonceImpl(nonce);\n    }\n}\n"
    },
    "/home/cashlink/stokera-token/contracts/TokenPlatform.sol": {
      "content": "pragma solidity ^0.5.3;\n\nimport './Policy.sol';\nimport './Upgradeable.sol';\n\ninterface ITokenPlatform {\n    function isITokenPlatform() external pure returns (bool);\n}\n\ncontract TokenPlatform is SingleAuthorityPolicy, ITokenPlatform {\n    constructor(address _authority) public {\n        initSingleAuthorityPolicy(_authority);\n    }\n\n    function isITokenPlatform() external pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "/home/cashlink/stokera-token/contracts/Upgradeable.sol": {
      "content": "pragma solidity ^0.5.3;\n\nimport './Utils.sol';\n\ninterface IUpgradeProxy {\n    event OwnershipTransferred(address indexed from, address indexed to);\n    event ProxyPaused();\n    event ProxyUnpaused();\n    event ProxyStartUpgrade(address indexed oldAddress, address indexed newAddress,\n                            uint256 fromVersion, uint256 toVersion);\n    event ProxyFinishUpgrade(address indexed oldAddress, address indexed newAddress,\n                             uint256 fromVersion, uint256 toVersion);\n    event ProxyCallMigration(address indexed oldAddress, address indexed newAddress,\n                             uint256 fromVersion, uint256 toVersion);\n    event ProxyForceVersionBump(address indexed oldAddress, address indexed newAddress,\n                                uint256 fromVersion, uint256 toVersion);\n    event ProxyCancelUpgrade(address indexed oldAddress, address indexed newAddress,\n                             uint256 fromVersion, uint256 toVersion);\n\n    function proxyTransferOwnership(address _newOwner) external;\n    function proxyAcceptOwnership() external;\n    function proxyPause() external;\n    function proxyUnpause() external;\n    function proxyStartUpgrade(address newLogicContract, uint256 newVersion) external;\n    function proxyFinishUpgrade() external;\n    function proxyCallMigration(bytes calldata data) external;\n\n    // Undo proxyStartUpgrade without actually upgrading. Restores the old logic\n    // contract. This is only safe to execute before doing a successful call to\n    // proxyCallMigration, after which it is UNSAFE. This is meant as a recovery\n    // mechanism in case a migration fails.\n    function proxyCancelUpgrade() external;\n\n    // Without this function it is possible to reach an unrecoverable state:\n    // Call proxyStartUpgrade with a smart contract that does not have a\n    // migration function that bumps it to the given version.\n    //\n    // This can be recovered by calling this function before calling\n    // proxyFinishUpgrade, and then initiating a new upgrade before unpause.\n    //\n    // This is an emergency recovery mechanism that should never be used under\n    // normal circumstances.\n    function proxyForceVersionBump() external;\n\n    function version() external view returns (uint256);\n    function logicContract() external view returns (address);\n    function upgradingFromVersion() external view returns (uint256);\n    function upgradingToVersion() external view returns (uint256);\n}\n\n// Inherited by both proxy and logic contract, to avoid storage location overlaps\n// and function signature hash collisions\n//\n// Rules for logic contracts:\n//\n// * Does not depend on constructor behaviour. Instead it should have a migrate_0_to_1\n//   migration function that takes the arguments that the constructor would normally\n//   have. In fact we have to ensure that there is no constructor in the entire\n//   inheritance chain, because none of them will be actually called for the\n//   proxy contract. This is automatically ensured by the compiler for\n//   non-trivial constructors in case the logic contract has no constructor itself,\n//   but this does not hold for trivial constructors (i.e. those with zero\n//   parameters), so we still have to be careful.\n//\n// * No private functions, so that we can extend by inheritance\n//\n// * There must be no publicly accessible self-destruct functionality, or\n//   if there is, it MUST carry the \"onlyViaProxy\" modifier\n//\n// * Logic contracts MUST NOT write to any of the variables defined in\n//   SharedBetweenProxyAndLogic since these are managed by the proxy contract,\n//   with the exception of the \"version\" variable, which must only be written\n//   within migrations.\n//   Ideally the variables should not be inspected either, unless from within the\n//   \"onlyViaProxy\" and \"migration\" wrappers. The only exception is the \"owner\"\n//   variable, which can be re-used by the logic contract so as to avoid adding\n//   a second variable with essentially the same meaning.\n//\n// TODO investigate if we want a way to execute stateful things as the owner\n// while the contract is paused. Probably it is not needed because we can call\n// proxyUnpause() -> stateful action -> proxyPause() in a transaction? We should\n// test this though\ncontract SharedBetweenProxyAndLogic is IUpgradeProxy {\n    enum ProxyState {Normal, Paused, Upgrading, CallingMigrationFunction}\n\n    // All of these state variables are managed by the proxy and MUST NOT\n    // be written by\n    address public owner;\n    address public newOwner;\n    ProxyState public proxyState;\n    // Technically, this is redundant since for example\n    // isProxy == logicContract != 0 || proxyState != 0.\n    // Better be a bit more explicit though.\n    bool isProxy;\n\n    uint256 public upgradingFromVersion;\n    uint256 public upgradingToVersion;\n    address public logicContract;\n    uint256 public version;\n\n    address internal oldLogicContract;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Sender must be owner\");\n        _;\n    }\n}\n\ncontract ContractLogic is SharedBetweenProxyAndLogic {\n    // IUpgradeProxy fake implementation to make Solidity happy. It would be better\n    // to just have these calls fall through, but this is not currently possible?\n    function proxyTransferOwnership(address) external { revert(); }\n    function proxyAcceptOwnership() external { revert(); }\n    function proxyPause() external { revert(); }\n    function proxyUnpause() external { revert(); }\n    function proxyStartUpgrade(address, uint256) external { revert(); }\n    function proxyCancelUpgrade() external { revert(); }\n    function proxyFinishUpgrade() external { revert(); }\n    function proxyCallMigration(bytes calldata) external { revert(); }\n    function proxyForceVersionBump() external { revert(); }\n\n    // General recommendation is to not accept funds if not required\n    // (can still be forced via self-destruction)\n    function () external payable { revert(); }\n\n    // TODO currently unused and untested\n    modifier onlyViaProxy() {\n        // Must be called on the proxy, not the deployed logic contract\n        require(isProxy);\n        _;\n    }\n\n    modifier migration(uint256 fromVersion, uint256 toVersion) {\n        // This is just a sanity check, the fact that we are in CallingMigrationFunction\n        // state means that this function call was performed via proxyCallMigration\n        assert(msg.sender == owner);\n\n        assert(toVersion - fromVersion == 1);\n\n        // Must be called on the proxy in the correct state, not the deployed\n        // logic contract\n        require(isProxy);\n        require(proxyState == ProxyState.CallingMigrationFunction);\n\n        // Make sure the migration version range is consistent with the\n        // actual upgrade version range\n        require(fromVersion >= upgradingFromVersion && toVersion <= upgradingToVersion);\n        require(version == fromVersion);\n        uint256 oldVersion = version;\n        _;\n        // Migration functions should be monotone in the version, and hold their\n        // promise regarding the migrated version range\n        assert(version >= oldVersion);\n        assert(version <= toVersion);\n        // This can be used by the caller to verify that a function with this\n        // modifier was used\n        proxyState = ProxyState.Upgrading;\n    }\n}\n\ncontract UpgradeProxy is SharedBetweenProxyAndLogic {\n    constructor(address _owner) public {\n        owner = _owner;\n        newOwner = address(0);\n        proxyState = ProxyState.Paused;\n        logicContract = address(0);\n        oldLogicContract = address(0);\n        isProxy = true;\n        version = 0;\n        emit ProxyPaused();\n    }\n\n    function proxyTransferOwnership(address _newOwner) external onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    function proxyAcceptOwnership() external {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n\n    function proxyPause() external onlyOwner {\n        emit ProxyPaused();\n        require(proxyState == ProxyState.Normal);\n        proxyState = ProxyState.Paused;\n    }\n\n    function proxyUnpause() external onlyOwner {\n        emit ProxyUnpaused();\n        // Make sure the first unpause only happens after a logic contract was set\n        require(Utils.isContract(logicContract));\n        require(proxyState == ProxyState.Paused);\n        proxyState = ProxyState.Normal;\n    }\n\n    function proxyStartUpgrade(address newLogicContract, uint256 newVersion)\n        external onlyOwner\n    {\n        require(proxyState == ProxyState.Paused);\n        require(version < newVersion);\n        require(Utils.isContract(newLogicContract));\n\n        upgradingFromVersion = version;\n        upgradingToVersion = newVersion;\n        oldLogicContract = logicContract;\n        logicContract = newLogicContract;\n\n        emit ProxyStartUpgrade(oldLogicContract, newLogicContract,\n                               upgradingFromVersion, upgradingToVersion);\n        proxyState = ProxyState.Upgrading;\n    }\n\n    function proxyCallMigration(bytes calldata data)\n        external onlyOwner\n    {\n        require(proxyState == ProxyState.Upgrading);\n        require(Utils.isContract(logicContract));\n\n        emit ProxyCallMigration(oldLogicContract, logicContract,\n                                upgradingFromVersion, upgradingToVersion);\n\n        proxyState = ProxyState.CallingMigrationFunction;\n        (bool result,) = logicContract.delegatecall(data);\n        require(result);\n\n        require(proxyState == ProxyState.Upgrading);\n    }\n\n    function proxyForceVersionBump()\n        external onlyOwner\n    {\n        require(proxyState == ProxyState.Upgrading);\n        emit ProxyForceVersionBump(oldLogicContract, logicContract,\n                                   upgradingFromVersion, upgradingToVersion);\n        version = upgradingToVersion;\n    }\n\n    function proxyFinishUpgrade()\n        external onlyOwner\n    {\n        require(proxyState == ProxyState.Upgrading);\n        require(version == upgradingToVersion);\n\n        emit ProxyFinishUpgrade(oldLogicContract, logicContract,\n                                upgradingFromVersion, upgradingToVersion);\n        proxyState = ProxyState.Paused;\n\n        // Clean up storage\n        upgradingFromVersion = 0;\n        upgradingToVersion = 0;\n        oldLogicContract = address(0);\n    }\n\n    function proxyCancelUpgrade()\n        external onlyOwner\n    {\n        require(proxyState == ProxyState.Upgrading);\n\n        emit ProxyCancelUpgrade(oldLogicContract, logicContract,\n                                upgradingFromVersion, upgradingToVersion);\n        logicContract = oldLogicContract;\n\n        // It would be safer to require(version == upgradingFromVersion), but\n        // we give us a little bit of freedom here in case we really mess up badly.\n        version = upgradingFromVersion;\n        proxyState = ProxyState.Paused;\n\n        // Clean up storage\n        upgradingFromVersion = 0;\n        upgradingToVersion = 0;\n        oldLogicContract = address(0);\n    }\n\n    // from\n    // https://github.com/zeppelinos/labs/blob/master/upgradeability_using_eternal_storage/contracts/Proxy.sol\n    function () payable external {\n        require(proxyState == ProxyState.Normal);\n\n        // TODO check that the receiver has code\n        // https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/\n        // For now we don't do this for performance reasons\n        //require(Utils.isContract(logicContract));\n        address impl = logicContract;\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, impl, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n"
    },
    "/home/cashlink/stokera-token/contracts/Utils.sol": {
      "content": "pragma solidity ^0.5.3;\n\nlibrary Utils {\n    function isContract(address addr) external view returns (bool) {\n        if (addr == address(0)) {\n            return false;\n        }\n        uint32 size;\n        assembly { size := extcodesize(addr) }\n        return (size > 0);\n    }\n}\n"
    }
  }
}}