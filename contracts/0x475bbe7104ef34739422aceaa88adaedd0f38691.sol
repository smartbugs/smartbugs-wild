{"DSAuth.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\npragma solidity ^0.4.13;\n\ncontract DSAuthority {\n  function canCall(\n    address src, address dst, bytes4 sig\n  ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n  event LogSetAuthority (address indexed authority);\n  event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n  DSAuthority  public  authority;\n  address      public  owner;\n\n  function DSAuth() public {\n    owner = msg.sender;\n    LogSetOwner(msg.sender);\n  }\n\n  function setOwner(address owner_)\n  public\n  auth\n  {\n    owner = owner_;\n    LogSetOwner(owner);\n  }\n\n  function setAuthority(DSAuthority authority_)\n  public\n  auth\n  {\n    authority = authority_;\n    LogSetAuthority(authority);\n  }\n\n  modifier auth {\n    require(isAuthorized(msg.sender, msg.sig));\n    _;\n  }\n\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n    if (src == address(this)) {\n      return true;\n    } else if (src == owner) {\n      return true;\n    } else if (authority == DSAuthority(0)) {\n      return false;\n    } else {\n      return authority.canCall(src, this, sig);\n    }\n  }\n}\n"},"EternalDb.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./DSAuth.sol\";\n\n/**\n * @title Contract to store arbitrary state data, decoupled from any logic related to it\n *\n * @dev Original implementation: https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88\n * In addition to original implementation, this contract uses DSAuth for more advanced authentication options\n * It also provides way set/get multiple values in single transaction\n */\n\ncontract EternalDb is DSAuth {\n\n  enum Types {UInt, String, Address, Bytes, Bytes32, Boolean, Int}\n\n  event EternalDbEvent(bytes32[] records, uint[] values, uint timestamp);\n\n  function EternalDb(){\n  }\n\n  ////////////\n  //UInt\n  ////////////\n\n  mapping(bytes32 =\u003e uint) UIntStorage;\n\n  function getUIntValue(bytes32 record) constant returns (uint){\n    return UIntStorage[record];\n  }\n\n  function getUIntValues(bytes32[] records) constant returns (uint[] results){\n    results = new uint[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = UIntStorage[records[i]];\n    }\n  }\n\n  function setUIntValue(bytes32 record, uint value)\n  auth\n  {\n    UIntStorage[record] = value;\n    bytes32[] memory records = new bytes32[](1);\n    records[0] = record;\n    uint[] memory values = new uint[](1);\n    values[0] = value;\n    emit EternalDbEvent(records, values, now);\n  }\n\n  function setUIntValues(bytes32[] records, uint[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      UIntStorage[records[i]] = values[i];\n    }\n    emit EternalDbEvent(records, values, now);\n  }\n\n  function deleteUIntValue(bytes32 record)\n  auth\n  {\n    delete UIntStorage[record];\n  }\n\n  ////////////\n  //Strings\n  ////////////\n\n  mapping(bytes32 =\u003e string) StringStorage;\n\n  function getStringValue(bytes32 record) constant returns (string){\n    return StringStorage[record];\n  }\n\n  function setStringValue(bytes32 record, string value)\n  auth\n  {\n    StringStorage[record] = value;\n  }\n\n  function deleteStringValue(bytes32 record)\n  auth\n  {\n    delete StringStorage[record];\n  }\n\n  ////////////\n  //Address\n  ////////////\n\n  mapping(bytes32 =\u003e address) AddressStorage;\n\n  function getAddressValue(bytes32 record) constant returns (address){\n    return AddressStorage[record];\n  }\n\n  function setAddressValues(bytes32[] records, address[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      AddressStorage[records[i]] = values[i];\n    }\n  }\n\n  function setAddressValue(bytes32 record, address value)\n  auth\n  {\n    AddressStorage[record] = value;\n  }\n\n  function deleteAddressValue(bytes32 record)\n  auth\n  {\n    delete AddressStorage[record];\n  }\n\n  ////////////\n  //Bytes\n  ////////////\n\n  mapping(bytes32 =\u003e bytes) BytesStorage;\n\n  function getBytesValue(bytes32 record) constant returns (bytes){\n    return BytesStorage[record];\n  }\n\n  function setBytesValue(bytes32 record, bytes value)\n  auth\n  {\n    BytesStorage[record] = value;\n  }\n\n  function deleteBytesValue(bytes32 record)\n  auth\n  {\n    delete BytesStorage[record];\n  }\n\n  ////////////\n  //Bytes32\n  ////////////\n\n  mapping(bytes32 =\u003e bytes32) Bytes32Storage;\n\n  function getBytes32Value(bytes32 record) constant returns (bytes32){\n    return Bytes32Storage[record];\n  }\n\n  function getBytes32Values(bytes32[] records) constant returns (bytes32[] results){\n    results = new bytes32[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = Bytes32Storage[records[i]];\n    }\n  }\n\n  function setBytes32Value(bytes32 record, bytes32 value)\n  auth\n  {\n    Bytes32Storage[record] = value;\n  }\n\n  function setBytes32Values(bytes32[] records, bytes32[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      Bytes32Storage[records[i]] = values[i];\n    }\n  }\n\n  function deleteBytes32Value(bytes32 record)\n  auth\n  {\n    delete Bytes32Storage[record];\n  }\n\n  ////////////\n  //Boolean\n  ////////////\n\n  mapping(bytes32 =\u003e bool) BooleanStorage;\n\n  function getBooleanValue(bytes32 record) constant returns (bool){\n    return BooleanStorage[record];\n  }\n\n  function getBooleanValues(bytes32[] records) constant returns (bool[] results){\n    results = new bool[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = BooleanStorage[records[i]];\n    }\n  }\n\n  function setBooleanValue(bytes32 record, bool value)\n  auth\n  {\n    BooleanStorage[record] = value;\n  }\n\n  function setBooleanValues(bytes32[] records, bool[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      BooleanStorage[records[i]] = values[i];\n    }\n  }\n\n  function deleteBooleanValue(bytes32 record)\n  auth\n  {\n    delete BooleanStorage[record];\n  }\n\n  ////////////\n  //Int\n  ////////////\n  mapping(bytes32 =\u003e int) IntStorage;\n\n  function getIntValue(bytes32 record) constant returns (int){\n    return IntStorage[record];\n  }\n\n  function getIntValues(bytes32[] records) constant returns (int[] results){\n    results = new int[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = IntStorage[records[i]];\n    }\n  }\n\n  function setIntValue(bytes32 record, int value)\n  auth\n  {\n    IntStorage[record] = value;\n  }\n\n  function setIntValues(bytes32[] records, int[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      IntStorage[records[i]] = values[i];\n    }\n  }\n\n  function deleteIntValue(bytes32 record)\n  auth\n  {\n    delete IntStorage[record];\n  }\n\n}\n"}}