{"Address.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n}\n"},"Controllable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Ownable.sol\";\n\ncontract Controllable is Ownable {\n    mapping(address=\u003ebool) public controllers;\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n    }\n}\n"},"Deed.sol":{"content":"pragma solidity \u003e=0.4.24;\n\ninterface Deed {\n\n    function setOwner(address payable newOwner) external;\n    function setRegistrar(address newRegistrar) external;\n    function setBalance(uint newValue, bool throwOnFailure) external;\n    function closeDeed(uint refundRatio) external;\n    function destroyDeed() external;\n\n    function owner() external view returns (address);\n    function previousOwner() external view returns (address);\n    function value() external view returns (uint);\n    function creationDate() external view returns (uint);\n\n}\n"},"DeedImplementation.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Deed.sol\";\n\n/**\n * @title Deed to hold ether in exchange for ownership of a node\n * @dev The deed can be controlled only by the registrar and can only send ether back to the owner.\n */\ncontract DeedImplementation is Deed {\n\n    address payable constant burn = address(0xdead);\n\n    address payable private _owner;\n    address private _previousOwner;\n    address private _registrar;\n\n    uint private _creationDate;\n    uint private _value;\n\n    bool active;\n\n    event OwnerChanged(address newOwner);\n    event DeedClosed();\n\n    modifier onlyRegistrar {\n        require(msg.sender == _registrar);\n        _;\n    }\n\n    modifier onlyActive {\n        require(active);\n        _;\n    }\n\n    constructor(address payable initialOwner) public payable {\n        _owner = initialOwner;\n        _registrar = msg.sender;\n        _creationDate = now;\n        active = true;\n        _value = msg.value;\n    }\n\n    function setOwner(address payable newOwner) external onlyRegistrar {\n        require(newOwner != address(0x0));\n        _previousOwner = _owner;  // This allows contracts to check who sent them the ownership\n        _owner = newOwner;\n        emit OwnerChanged(newOwner);\n    }\n\n    function setRegistrar(address newRegistrar) external onlyRegistrar {\n        _registrar = newRegistrar;\n    }\n\n    function setBalance(uint newValue, bool throwOnFailure) external onlyRegistrar onlyActive {\n        // Check if it has enough balance to set the value\n        require(_value \u003e= newValue);\n        _value = newValue;\n        // Send the difference to the owner\n        require(_owner.send(address(this).balance - newValue) || !throwOnFailure);\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     *\n     * @param refundRatio The amount*1/1000 to refund\n     */\n    function closeDeed(uint refundRatio) external onlyRegistrar onlyActive {\n        active = false;\n        require(burn.send(((1000 - refundRatio) * address(this).balance)/1000));\n        emit DeedClosed();\n        _destroyDeed();\n    }\n\n    /**\n     * @dev Close a deed and refund a specified fraction of the bid value\n     */\n    function destroyDeed() external {\n        _destroyDeed();\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    function previousOwner() external view returns (address) {\n        return _previousOwner;\n    }\n\n    function value() external view returns (uint) {\n        return _value;\n    }\n\n    function creationDate() external view returns (uint) {\n        _creationDate;\n    }\n\n    function _destroyDeed() internal {\n        require(!active);\n\n        // Instead of selfdestruct(owner), invoke owner fallback function to allow\n        // owner to log an event if desired; but owner should also be aware that\n        // its fallback function can also be invoked by setBalance\n        if (_owner.send(address(this).balance)) {\n            selfdestruct(burn);\n        }\n    }\n}\n"},"ENS.sol":{"content":"pragma solidity \u003e=0.4.24;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n\n}\n"},"HashRegistrar.sol":{"content":"pragma solidity ^0.5.0;\n\n\n/*\n\nTemporary Hash Registrar\n========================\n\nThis is a simplified version of a hash registrar. It is purporsefully limited:\nnames cannot be six letters or shorter, new auctions will stop after 4 years.\n\nThe plan is to test the basic features and then move to a new contract in at most\n2 years, when some sort of renewal mechanism will be enabled.\n*/\n\n\nimport \"./ENS.sol\";\nimport \"./DeedImplementation.sol\";\nimport \"./Registrar.sol\";\n\n/**\n * @title Registrar\n * @dev The registrar handles the auction process for each subnode of the node it owns.\n */\ncontract HashRegistrar is Registrar {\n    ENS public ens;\n    bytes32 public rootNode;\n\n    mapping (bytes32 =\u003e Entry) _entries;\n    mapping (address =\u003e mapping (bytes32 =\u003e Deed)) public sealedBids;\n\n    uint32 constant totalAuctionLength = 5 days;\n    uint32 constant revealPeriod = 48 hours;\n    uint32 public constant launchLength = 8 weeks;\n\n    uint constant minPrice = 0.01 ether;\n    uint public registryStarted;\n\n    struct Entry {\n        Deed deed;\n        uint registrationDate;\n        uint value;\n        uint highestBid;\n    }\n\n    modifier inState(bytes32 _hash, Mode _state) {\n        require(state(_hash) == _state);\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _hash) {\n        require(state(_hash) == Mode.Owned \u0026\u0026 msg.sender == _entries[_hash].deed.owner());\n        _;\n    }\n\n    modifier registryOpen() {\n        require(now \u003e= registryStarted \u0026\u0026 now \u003c= registryStarted + (365 * 4) * 1 days \u0026\u0026 ens.owner(rootNode) == address(this));\n        _;\n    }\n\n    /**\n     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\n     *\n     * @param _ens The address of the ENS\n     * @param _rootNode The hash of the rootnode.\n     */\n    constructor(ENS _ens, bytes32 _rootNode, uint _startDate) public {\n        ens = _ens;\n        rootNode = _rootNode;\n        registryStarted = _startDate \u003e 0 ? _startDate : now;\n    }\n\n    /**\n     * @dev Start an auction for an available hash\n     *\n     * @param _hash The hash to start an auction on\n     */\n    function startAuction(bytes32 _hash) external {\n        _startAuction(_hash);\n    }\n\n    /**\n     * @dev Start multiple auctions for better anonymity\n     *\n     * Anyone can start an auction by sending an array of hashes that they want to bid for.\n     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\n     * are only really interested in bidding for one. This will increase the cost for an\n     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\n     * open but not bid on are closed after a week.\n     *\n     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\n     */\n    function startAuctions(bytes32[] calldata _hashes) external {\n        _startAuctions(_hashes);\n    }\n\n    /**\n     * @dev Submit a new sealed bid on a desired hash in a blind auction\n     *\n     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\n     * contains information about the bid, including the bidded hash, the bid amount, and a random\n     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\n     * itself can be masqueraded by sending more than the value of your actual bid. This is\n     * followed by a 48h reveal period. Bids revealed after this period will be burned and the ether unrecoverable.\n     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\n     * words, will have multiple bidders pushing the price up.\n     *\n     * @param sealedBid A sealedBid, created by the shaBid function\n     */\n    function newBid(bytes32 sealedBid) external payable {\n        _newBid(sealedBid);\n    }\n\n    /**\n     * @dev Start a set of auctions and bid on one of them\n     *\n     * This method functions identically to calling `startAuctions` followed by `newBid`,\n     * but all in one transaction.\n     *\n     * @param hashes A list of hashes to start auctions on.\n     * @param sealedBid A sealed bid for one of the auctions.\n     */\n    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable {\n        _startAuctions(hashes);\n        _newBid(sealedBid);\n    }\n\n    /**\n     * @dev Submit the properties of a bid to reveal them\n     *\n     * @param _hash The node in the sealedBid\n     * @param _value The bid amount in the sealedBid\n     * @param _salt The sale in the sealedBid\n     */\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external {\n        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\n        Deed bid = sealedBids[msg.sender][seal];\n        require(address(bid) != address(0x0));\n\n        sealedBids[msg.sender][seal] = Deed(address(0x0));\n        Entry storage h = _entries[_hash];\n        uint value = min(_value, bid.value());\n        bid.setBalance(value, true);\n\n        Mode auctionState = state(_hash);\n        if (auctionState == Mode.Owned) {\n            // Too late! Bidder loses their bid. Gets 0.5% back.\n            bid.closeDeed(5);\n            emit BidRevealed(_hash, msg.sender, value, 1);\n        } else if (auctionState != Mode.Reveal) {\n            // Invalid phase\n            revert();\n        } else if (value \u003c minPrice || bid.creationDate() \u003e h.registrationDate - revealPeriod) {\n            // Bid too low or too late, refund 99.5%\n            bid.closeDeed(995);\n            emit BidRevealed(_hash, msg.sender, value, 0);\n        } else if (value \u003e h.highestBid) {\n            // New winner\n            // Cancel the other bid, refund 99.5%\n            if (address(h.deed) != address(0x0)) {\n                Deed previousWinner = h.deed;\n                previousWinner.closeDeed(995);\n            }\n\n            // Set new winner\n            // Per the rules of a vickery auction, the value becomes the previous highestBid\n            h.value = h.highestBid;  // will be zero if there\u0027s only 1 bidder\n            h.highestBid = value;\n            h.deed = bid;\n            emit BidRevealed(_hash, msg.sender, value, 2);\n        } else if (value \u003e h.value) {\n            // Not winner, but affects second place\n            h.value = value;\n            bid.closeDeed(995);\n            emit BidRevealed(_hash, msg.sender, value, 3);\n        } else {\n            // Bid doesn\u0027t affect auction\n            bid.closeDeed(995);\n            emit BidRevealed(_hash, msg.sender, value, 4);\n        }\n    }\n\n    /**\n     * @dev Cancel a bid\n     *\n     * @param seal The value returned by the shaBid function\n     */\n    function cancelBid(address bidder, bytes32 seal) external {\n        Deed bid = sealedBids[bidder][seal];\n        \n        // If a sole bidder does not `unsealBid` in time, they have a few more days\n        // where they can call `startAuction` (again) and then `unsealBid` during\n        // the revealPeriod to get back their bid value.\n        // For simplicity, they should call `startAuction` within\n        // 9 days (2 weeks - totalAuctionLength), otherwise their bid will be\n        // cancellable by anyone.\n        require(address(bid) != address(0x0) \u0026\u0026 now \u003e= bid.creationDate() + totalAuctionLength + 2 weeks);\n\n        // Send the canceller 0.5% of the bid, and burn the rest.\n        bid.setOwner(msg.sender);\n        bid.closeDeed(5);\n        sealedBids[bidder][seal] = Deed(0);\n        emit BidRevealed(seal, bidder, 0, 5);\n    }\n\n    /**\n     * @dev Finalize an auction after the registration date has passed\n     *\n     * @param _hash The hash of the name the auction is for\n     */\n    function finalizeAuction(bytes32 _hash) external onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        \n        // Handles the case when there\u0027s only a single bidder (h.value is zero)\n        h.value = max(h.value, minPrice);\n        h.deed.setBalance(h.value, true);\n\n        trySetSubnodeOwner(_hash, h.deed.owner());\n        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\n    }\n\n    /**\n     * @dev The owner of a domain may transfer it to someone else at any time.\n     *\n     * @param _hash The node to transfer\n     * @param newOwner The address to transfer ownership to\n     */\n    function transfer(bytes32 _hash, address payable newOwner) external onlyOwner(_hash) {\n        require(newOwner != address(0x0));\n\n        Entry storage h = _entries[_hash];\n        h.deed.setOwner(newOwner);\n        trySetSubnodeOwner(_hash, newOwner);\n    }\n\n    /**\n     * @dev After some time, or if we\u0027re no longer the registrar, the owner can release\n     *      the name and get their ether back.\n     *\n     * @param _hash The node to release\n     */\n    function releaseDeed(bytes32 _hash) external onlyOwner(_hash) {\n        Entry storage h = _entries[_hash];\n        Deed deedContract = h.deed;\n\n        require(now \u003e= h.registrationDate + 365 days || ens.owner(rootNode) != address(this));\n\n        h.value = 0;\n        h.highestBid = 0;\n        h.deed = Deed(0);\n\n        _tryEraseSingleNode(_hash);\n        deedContract.closeDeed(1000);\n        emit HashReleased(_hash, h.value);        \n    }\n\n    /**\n     * @dev Submit a name 6 characters long or less. If it has been registered,\n     *      the submitter will earn 50% of the deed value. \n     * \n     * We are purposefully handicapping the simplified registrar as a way \n     * to force it into being restructured in a few years.\n     *\n     * @param unhashedName An invalid name to search for in the registry.\n     */\n    function invalidateName(string calldata unhashedName)\n        external\n        inState(keccak256(abi.encode(unhashedName)), Mode.Owned)\n    {\n        require(strlen(unhashedName) \u003c= 6);\n        bytes32 hash = keccak256(abi.encode(unhashedName));\n\n        Entry storage h = _entries[hash];\n\n        _tryEraseSingleNode(hash);\n\n        if (address(h.deed) != address(0x0)) {\n            // Reward the discoverer with 50% of the deed\n            // The previous owner gets 50%\n            h.value = max(h.value, minPrice);\n            h.deed.setBalance(h.value/2, false);\n            h.deed.setOwner(msg.sender);\n            h.deed.closeDeed(1000);\n        }\n\n        emit HashInvalidated(hash, unhashedName, h.value, h.registrationDate);\n\n        h.value = 0;\n        h.highestBid = 0;\n        h.deed = Deed(0);\n    }\n\n    /**\n     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\n     *      name that is not currently owned in the registrar. If passing, eg, \u0027foo.bar.eth\u0027,\n     *      the owner and resolver fields on \u0027foo.bar.eth\u0027 and \u0027bar.eth\u0027 will all be cleared.\n     *\n     * @param labels A series of label hashes identifying the name to zero out, rooted at the\n     *        registrar\u0027s root. Must contain at least one element. For instance, to zero \n     *        \u0027foo.bar.eth\u0027 on a registrar that owns \u0027.eth\u0027, pass an array containing\n     *        [keccak256(\u0027foo\u0027), keccak256(\u0027bar\u0027)].\n     */\n    function eraseNode(bytes32[] calldata labels) external {\n        require(labels.length != 0);\n        require(state(labels[labels.length - 1]) != Mode.Owned);\n\n        _eraseNodeHierarchy(labels.length - 1, labels, rootNode);\n    }\n\n    /**\n     * @dev Transfers the deed to the current registrar, if different from this one.\n     *\n     * Used during the upgrade process to a permanent registrar.\n     *\n     * @param _hash The name hash to transfer.\n     */\n    function transferRegistrars(bytes32 _hash) external onlyOwner(_hash) {\n        address registrar = ens.owner(rootNode);\n        require(registrar != address(this));\n\n        // Migrate the deed\n        Entry storage h = _entries[_hash];\n        h.deed.setRegistrar(registrar);\n\n        // Call the new registrar to accept the transfer\n        Registrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\n\n        // Zero out the Entry\n        h.deed = Deed(0);\n        h.registrationDate = 0;\n        h.value = 0;\n        h.highestBid = 0;\n    }\n\n    /**\n     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\n     *      is no previous registrar implementing this interface.\n     *\n     * @param hash The sha3 hash of the label to transfer.\n     * @param deed The Deed object for the name being transferred in.\n     * @param registrationDate The date at which the name was originally registered.\n     */\n    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external {\n        hash; deed; registrationDate; // Don\u0027t warn about unused variables\n    }\n\n    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint) {\n        Entry storage h = _entries[_hash];\n        return (state(_hash), address(h.deed), h.registrationDate, h.value, h.highestBid);\n    }\n\n    // State transitions for names:\n    //   Open -\u003e Auction (startAuction)\n    //   Auction -\u003e Reveal\n    //   Reveal -\u003e Owned\n    //   Reveal -\u003e Open (if nobody bid)\n    //   Owned -\u003e Open (releaseDeed or invalidateName)\n    function state(bytes32 _hash) public view returns (Mode) {\n        Entry storage entry = _entries[_hash];\n\n        if (!isAllowed(_hash, now)) {\n            return Mode.NotYetAvailable;\n        } else if (now \u003c entry.registrationDate) {\n            if (now \u003c entry.registrationDate - revealPeriod) {\n                return Mode.Auction;\n            } else {\n                return Mode.Reveal;\n            }\n        } else {\n            if (entry.highestBid == 0) {\n                return Mode.Open;\n            } else {\n                return Mode.Owned;\n            }\n        }\n    }\n\n    /**\n     * @dev Determines if a name is available for registration yet\n     *\n     * Each name will be assigned a random date in which its auction\n     * can be started, from 0 to 8 weeks\n     *\n     * @param _hash The hash to start an auction on\n     * @param _timestamp The timestamp to query about\n     */\n    function isAllowed(bytes32 _hash, uint _timestamp) public view returns (bool allowed) {\n        return _timestamp \u003e getAllowedTime(_hash);\n    }\n\n    /**\n     * @dev Returns available date for hash\n     *\n     * The available time from the `registryStarted` for a hash is proportional\n     * to its numeric value.\n     *\n     * @param _hash The hash to start an auction on\n     */\n    function getAllowedTime(bytes32 _hash) public view returns (uint) {\n        return registryStarted + ((launchLength * (uint(_hash) \u003e\u003e 128)) \u003e\u003e 128);\n        // Right shift operator: a \u003e\u003e b == a / 2**b\n    }\n\n    /**\n     * @dev Hash the values required for a secret bid\n     *\n     * @param hash The node corresponding to the desired namehash\n     * @param value The bid amount\n     * @param salt A random value to ensure secrecy of the bid\n     * @return The hash of the bid values\n     */\n    function shaBid(bytes32 hash, address owner, uint value, bytes32 salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hash, owner, value, salt));\n    }\n\n    function _tryEraseSingleNode(bytes32 label) internal {\n        if (ens.owner(rootNode) == address(this)) {\n            ens.setSubnodeOwner(rootNode, label, address(this));\n            bytes32 node = keccak256(abi.encodePacked(rootNode, label));\n            ens.setResolver(node, address(0x0));\n            ens.setOwner(node, address(0x0));\n        }\n    }\n\n    function _startAuction(bytes32 _hash) internal registryOpen() {\n        Mode mode = state(_hash);\n        if (mode == Mode.Auction) return;\n        require(mode == Mode.Open);\n\n        Entry storage newAuction = _entries[_hash];\n        newAuction.registrationDate = now + totalAuctionLength;\n        newAuction.value = 0;\n        newAuction.highestBid = 0;\n        emit AuctionStarted(_hash, newAuction.registrationDate);\n    }\n\n    function _startAuctions(bytes32[] memory _hashes) internal {\n        for (uint i = 0; i \u003c _hashes.length; i ++) {\n            _startAuction(_hashes[i]);\n        }\n    }\n\n    function _newBid(bytes32 sealedBid) internal {\n        require(address(sealedBids[msg.sender][sealedBid]) == address(0x0));\n        require(msg.value \u003e= minPrice);\n\n        // Creates a new hash contract with the owner\n        Deed bid = (new DeedImplementation).value(msg.value)(msg.sender);\n        sealedBids[msg.sender][sealedBid] = bid;\n        emit NewBid(sealedBid, msg.sender, msg.value);\n    }\n\n    function _eraseNodeHierarchy(uint idx, bytes32[] memory labels, bytes32 node) internal {\n        // Take ownership of the node\n        ens.setSubnodeOwner(node, labels[idx], address(this));\n        node = keccak256(abi.encodePacked(node, labels[idx]));\n\n        // Recurse if there are more labels\n        if (idx \u003e 0) {\n            _eraseNodeHierarchy(idx - 1, labels, node);\n        }\n\n        // Erase the resolver and owner records\n        ens.setResolver(node, address(0x0));\n        ens.setOwner(node, address(0x0));\n    }\n\n    /**\n     * @dev Assign the owner in ENS, if we\u0027re still the registrar\n     *\n     * @param _hash hash to change owner\n     * @param _newOwner new owner to transfer to\n     */\n    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\n        if (ens.owner(rootNode) == address(this))\n            ens.setSubnodeOwner(rootNode, _hash, _newOwner);\n    }\n\n    /**\n     * @dev Returns the maximum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The maximum of two unsigned integers\n     */\n    function max(uint a, uint b) internal pure returns (uint) {\n        if (a \u003e b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Returns the minimum of two unsigned integers\n     *\n     * @param a A number to compare\n     * @param b A number to compare\n     * @return The minimum of two unsigned integers\n     */\n    function min(uint a, uint b) internal pure returns (uint) {\n        if (a \u003c b)\n            return a;\n        else\n            return b;\n    }\n\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint) {\n        s; // Don\u0027t warn about unused variables\n        // Starting here means the LSB will be the byte we care about\n        uint ptr;\n        uint end;\n        assembly {\n            ptr := add(s, 1)\n            end := add(mload(s), ptr)\n        }\n        uint len = 0;\n        for (len; ptr \u003c end; len++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b \u003c 0x80) {\n                ptr += 1;\n            } else if (b \u003c 0xE0) {\n                ptr += 2;\n            } else if (b \u003c 0xF0) {\n                ptr += 3;\n            } else if (b \u003c 0xF8) {\n                ptr += 4;\n            } else if (b \u003c 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n        return len;\n    }\n\n}\n"},"MultiSigWallet.sol":{"content":"/**\n * Source Code first verified at https://etherscan.io on Friday, March 3, 2017\n (UTC) */\n\npragma solidity ^0.5.0;\n\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - \u003cstefan.george@consensys.net\u003e\ncontract MultiSigWallet {\n\n  uint constant public MAX_OWNER_COUNT = 50;\n\n  event Confirmation(address indexed sender, uint indexed transactionId);\n  event Revocation(address indexed sender, uint indexed transactionId);\n  event Submission(uint indexed transactionId);\n  event Execution(uint indexed transactionId, bytes data);\n  event ExecutionFailure(uint indexed transactionId);\n  event Deposit(address indexed sender, uint value);\n  event OwnerAddition(address indexed owner);\n  event OwnerRemoval(address indexed owner);\n  event RequirementChange(uint required);\n\n  mapping (uint =\u003e Transaction) public transactions;\n  mapping (uint =\u003e mapping (address =\u003e bool)) public confirmations;\n  mapping (address =\u003e bool) public isOwner;\n  address[] public owners;\n  uint public required;\n  uint public transactionCount;\n\n  struct Transaction {\n    address destination;\n    uint value;\n    bytes data;\n    bool executed;\n  }\n\n  modifier onlyWallet() {\n    if (msg.sender != address(this))\n      revert();\n    _;\n  }\n\n  modifier ownerDoesNotExist(address owner) {\n    if (isOwner[owner])\n      revert();\n    _;\n  }\n\n  modifier ownerExists(address owner) {\n    if (!isOwner[owner])\n      revert();\n    _;\n  }\n\n  modifier transactionExists(uint transactionId) {\n    if (transactions[transactionId].destination == address(0))\n      revert();\n    _;\n  }\n\n  modifier confirmed(uint transactionId, address owner) {\n    if (!confirmations[transactionId][owner])\n      revert();\n    _;\n  }\n\n  modifier notConfirmed(uint transactionId, address owner) {\n    if (confirmations[transactionId][owner])\n      revert();\n    _;\n  }\n\n  modifier notExecuted(uint transactionId) {\n    if (transactions[transactionId].executed)\n      revert();\n    _;\n  }\n\n  modifier notNull(address _address) {\n    if (_address == address(0))\n      revert();\n    _;\n  }\n\n  modifier validRequirement(uint ownerCount, uint _required) {\n    if (   ownerCount \u003e MAX_OWNER_COUNT\n    || _required \u003e ownerCount\n    || _required == 0\n    || ownerCount == 0)\n      revert();\n    _;\n  }\n\n  /*\n   * Public functions\n   */\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\n  /// @param _owners List of initial owners.\n  /// @param _required Number of required confirmations.\n  constructor(address[] memory _owners, uint _required)\n  public\n  validRequirement(_owners.length, _required)\n  {\n    for (uint i=0; i\u003c_owners.length; i++) {\n      if (isOwner[_owners[i]] || _owners[i] == address(0))\n        revert();\n      isOwner[_owners[i]] = true;\n    }\n    owners = _owners;\n    required = _required;\n  }\n\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of new owner.\n  function addOwner(address owner)\n  public\n  onlyWallet\n  ownerDoesNotExist(owner)\n  notNull(owner)\n  validRequirement(owners.length + 1, required)\n  {\n    isOwner[owner] = true;\n    owners.push(owner);\n    emit OwnerAddition(owner);\n  }\n\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner.\n  function removeOwner(address owner)\n  public\n  onlyWallet\n  ownerExists(owner)\n  {\n    isOwner[owner] = false;\n    for (uint i=0; i\u003cowners.length - 1; i++)\n      if (owners[i] == owner) {\n        owners[i] = owners[owners.length - 1];\n        break;\n      }\n    owners.length -= 1;\n    if (required \u003e owners.length)\n      changeRequirement(owners.length);\n    emit OwnerRemoval(owner);\n  }\n\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner to be replaced.\n  /// @param owner Address of new owner.\n  function replaceOwner(address owner, address newOwner)\n  public\n  onlyWallet\n  ownerExists(owner)\n  ownerDoesNotExist(newOwner)\n  {\n    for (uint i=0; i\u003cowners.length; i++)\n      if (owners[i] == owner) {\n        owners[i] = newOwner;\n        break;\n      }\n    isOwner[owner] = false;\n    isOwner[newOwner] = true;\n    emit OwnerRemoval(owner);\n    emit OwnerAddition(newOwner);\n  }\n\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n  /// @param _required Number of required confirmations.\n  function changeRequirement(uint _required)\n  public\n  onlyWallet\n  validRequirement(owners.length, _required)\n  {\n    required = _required;\n    emit RequirementChange(_required);\n  }\n\n  /// @dev Allows an owner to submit and confirm a transaction.\n  /// @param destination Transaction target address.\n  /// @param value Transaction ether value.\n  /// @param data Transaction data payload.\n  /// @return Returns transaction ID.\n  function submitTransaction(address destination, uint value, bytes memory data)\n  public\n  returns (uint transactionId)\n  {\n    transactionId = addTransaction(destination, value, data);\n    confirmTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to confirm a transaction.\n  /// @param transactionId Transaction ID.\n  function confirmTransaction(uint transactionId)\n  public\n  ownerExists(msg.sender)\n  transactionExists(transactionId)\n  notConfirmed(transactionId, msg.sender)\n  {\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    executeTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to revoke a confirmation for a transaction.\n  /// @param transactionId Transaction ID.\n  function revokeConfirmation(uint transactionId)\n  public\n  ownerExists(msg.sender)\n  confirmed(transactionId, msg.sender)\n  notExecuted(transactionId)\n  {\n    confirmations[transactionId][msg.sender] = false;\n    emit Revocation(msg.sender, transactionId);\n  }\n\n  /// @dev Allows anyone to execute a confirmed transaction.\n  /// @param transactionId Transaction ID.\n  function executeTransaction(uint transactionId)\n  public\n  notExecuted(transactionId)\n  {\n    if (isConfirmed(transactionId)) {\n      Transaction storage tx = transactions[transactionId];\n      tx.executed = true;\n      bool success;\n      (success,) = tx.destination.call.value(tx.value)(tx.data);\n      if (success)\n        emit Execution(transactionId, tx.data);\n      else {\n        emit ExecutionFailure(transactionId);\n        tx.executed = false;\n      }\n    }\n  }\n\n  /// @dev Returns the confirmation status of a transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Confirmation status.\n  function isConfirmed(uint transactionId)\n  public\n  view\n  returns (bool)\n  {\n    uint count = 0;\n    for (uint i=0; i\u003cowners.length; i++) {\n      if (confirmations[transactionId][owners[i]])\n        count += 1;\n      if (count == required)\n        return true;\n    }\n  }\n\n  /*\n   * Internal functions\n   */\n  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n  /// @param destination Transaction target address.\n  /// @param value Transaction ether value.\n  /// @param data Transaction data payload.\n  /// @return Returns transaction ID.\n  function addTransaction(address destination, uint value, bytes memory data)\n  internal\n  notNull(destination)\n  returns (uint transactionId)\n  {\n    transactionId = transactionCount;\n    transactions[transactionId] = Transaction({\n      destination: destination,\n      value: value,\n      data: data,\n      executed: false\n      });\n    transactionCount += 1;\n    emit Submission(transactionId);\n  }\n\n  /*\n   * Web3 call functions\n   */\n  /// @dev Returns number of confirmations of a transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Number of confirmations.\n  function getConfirmationCount(uint transactionId)\n  public\n  view\n  returns (uint count)\n  {\n    for (uint i=0; i\u003cowners.length; i++)\n      if (confirmations[transactionId][owners[i]])\n        count += 1;\n  }\n\n  /// @dev Returns total number of transactions after filers are applied.\n  /// @param pending Include pending transactions.\n  /// @param executed Include executed transactions.\n  /// @return Total number of transactions after filters are applied.\n  function getTransactionCount(bool pending, bool executed)\n  public\n  view\n  returns (uint count)\n  {\n    for (uint i=0; i\u003ctransactionCount; i++)\n      if (   pending \u0026\u0026 !transactions[i].executed\n      || executed \u0026\u0026 transactions[i].executed)\n        count += 1;\n  }\n\n  /// @dev Returns list of owners.\n  /// @return List of owner addresses.\n  function getOwners()\n  public\n  view\n  returns (address[] memory)\n  {\n    return owners;\n  }\n\n  /// @dev Returns array with owner addresses, which confirmed transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Returns array of owner addresses.\n  function getConfirmations(uint transactionId)\n  public\n  view\n  returns (address[] memory _confirmations)\n  {\n    address[] memory confirmationsTemp = new address[](owners.length);\n    uint count = 0;\n    uint i;\n    for (i=0; i\u003cowners.length; i++)\n      if (confirmations[transactionId][owners[i]]) {\n        confirmationsTemp[count] = owners[i];\n        count += 1;\n      }\n    _confirmations = new address[](count);\n    for (i=0; i\u003ccount; i++)\n      _confirmations[i] = confirmationsTemp[i];\n  }\n\n  /// @dev Returns list of transaction IDs in defined range.\n  /// @param from Index start position of transaction array.\n  /// @param to Index end position of transaction array.\n  /// @param pending Include pending transactions.\n  /// @param executed Include executed transactions.\n  /// @return Returns array of transaction IDs.\n  function getTransactionIds(uint from, uint to, bool pending, bool executed)\n  public\n  view\n  returns (uint[] memory _transactionIds)\n  {\n    uint[] memory transactionIdsTemp = new uint[](transactionCount);\n    uint count = 0;\n    uint i;\n    for (i=0; i\u003ctransactionCount; i++)\n      if (   pending \u0026\u0026 !transactions[i].executed\n      || executed \u0026\u0026 transactions[i].executed)\n      {\n        transactionIdsTemp[count] = i;\n        count += 1;\n      }\n    _transactionIds = new uint[](to - from);\n    for (i=from; i\u003cto; i++)\n      _transactionIds[i - from] = transactionIdsTemp[i];\n  }\n}"},"NameBazaarRescue.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Root.sol\";\n\nimport \"./Offering.sol\";\nimport \"./OfferingRegistry.sol\";\nimport \"./MultiSigWallet.sol\";\n\ncontract NameBazaarRescue is Ownable {\n  bytes32 constant public ETH_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n  bytes32 constant public ETH_LABEL = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0;\n\n  Root public root;\n  OfferingRegistry public offeringRegistry;\n  address public previousRegistrar;\n\n  event ReclaimSuccess(address offering, uint transactionId);\n\n  constructor(address _root, address _offeringRegistry, address _previousRegistrar) public {\n    require(_root != address(0));\n    require(_offeringRegistry != address(0));\n    require(_previousRegistrar != address(0));\n\n    root = Root(_root);\n    offeringRegistry = OfferingRegistry(_offeringRegistry);\n    previousRegistrar = _previousRegistrar;\n  }\n\n  function reclaimOwnerships(address[] memory offerings) public onlyOwner {\n    address originalNodeOwner = root.ens().owner(ETH_NODE);\n    MultiSigWallet emergencyMultisig = MultiSigWallet(offeringRegistry.emergencyMultisig());\n\n    root.setSubnodeOwner(ETH_LABEL, previousRegistrar);\n\n    for (uint i = 0; i \u003c offerings.length; i++) {\n      require(offeringRegistry.isOffering(offerings[i]));\n      bool executed = false;\n      uint txId = emergencyMultisig.submitTransaction(offerings[i], 0, abi.encodeWithSignature(\"reclaimOwnership()\"));\n      (,,,executed) = emergencyMultisig.transactions(txId);\n\n      if (executed) {\n        emit ReclaimSuccess(offerings[i], txId);\n      } else {\n        revert(\"reclaimOwnership transaction couldn\u0027t be executed\");\n      }\n    }\n\n    root.setSubnodeOwner(ETH_LABEL, originalNodeOwner);\n  }\n\n}\n"},"Offering.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @title Offering\n * @dev Contains base logic for an offering and is meant to be extended.\n */\n\nimport \"./ENS.sol\";\nimport \"./HashRegistrar.sol\";\nimport \"./OfferingRegistry.sol\";\nimport \"./Address.sol\";\n\ncontract Offering {\n\n    struct Offering {\n        // Order here is important for gas optimisations. Must be fitting into uint265 slots.\n        bytes32 node;                       // ENS node\n        // WARNING: The contract DOES NOT perform ENS name normalisation, which is up to responsibility of each offchain UI!\n        string name;                        // full ENS name\n        bytes32 labelHash;                  // hash of ENS label\n        address originalOwner;              // owner of ENS name, creator of offering\n        address newOwner;                   // Address of a new owner of ENS name, buyer\n        uint price;                         // Price of the offering, or the highest bid in auction\n        uint128 version;                    // version of offering contract\n        uint64 createdOn;                   // Time when offering was created\n        uint64 finalizedOn;                 // Time when ENS name was transferred to a new owner\n    }\n\n    Offering public offering;\n\n    // Hardcoded ENS address. For development will be replaced after compilation. This way we save gas to users deploying offering contracts.\n    ENS public ens = ENS(0x314159265dD8dbb310642f98f50C066173C1259b);\n\n    // Hardcoded namehash of \"eth\"\n    bytes32 public constant rootNode = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    // Placeholder to be replaced after compilation. This way we save gas to users deploying offering contracts.\n    OfferingRegistry public offeringRegistry = OfferingRegistry(0xfEEDFEEDfeEDFEedFEEdFEEDFeEdfEEdFeEdFEEd);\n\n    // Placeholder to be replaced after compilation. This way we save gas to users deploying offering contracts.\n    address public emergencyMultisig = 0xDeEDdeeDDEeDDEEdDEedDEEdDEeDdEeDDEEDDeed;\n\n    constructor(ENS _ens, OfferingRegistry _offeringRegistry, address _emergencyMultisig) public {\n        ens = _ens;\n        offeringRegistry = _offeringRegistry;\n        emergencyMultisig = _emergencyMultisig;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only for offering creator\n     */\n    modifier onlyOriginalOwner() {\n        require(isSenderOriginalOwner());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only for Namebazaar\u0027s Emergency Multisig wallet\n     */\n    modifier onlyEmergencyMultisig() {\n        require(isSenderEmergencyMultisig());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only is called by Namebazaar\u0027s Emergency Multisig wallet\n     */\n    modifier onlyWithoutNewOwner() {\n        require(offering.newOwner == address(0));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when offering contract has name ownership\n     */\n    modifier onlyWhenContractIsNodeOwner() {\n        require(isContractNodeOwner());\n        _;\n    }\n\n\n    /**\n     * @dev Modifier to make a function callable only when there\u0027s not emergency pause\n     */\n    modifier onlyWhenNotEmergencyPaused() {\n        require(!offeringRegistry.isEmergencyPaused());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when offering contract doesn\u0027t have name ownership\n     */\n    modifier onlyWhenContractIsNotNodeOwner() {\n        require(!isContractNodeOwner());\n        _;\n    }\n\n    /**\n     * @dev Constructor of offering\n     * Should be callable just once, by factory\n     */\n    function construct(\n        bytes32 _node,\n        string memory _name,\n        bytes32 _labelHash,\n        address _originalOwner,\n        uint128 _version,\n        uint _price\n    )\n    public\n    onlyWhenNotEmergencyPaused\n    {\n        require(offering.createdOn == 0);               // Prevent constructing multiple times\n        offering.node = _node;\n        offering.name = _name;\n        offering.labelHash = _labelHash;\n        offering.originalOwner = _originalOwner;\n        offering.version = _version;\n        offering.createdOn = uint64(now);\n        offering.price = _price;\n    }\n\n    /**\n     * @dev Unregisters offering for not displaying it in UI\n     * Cannot be run if contract has ownership or it was already transferred to new owner\n     */\n    function unregister()\n    public\n    onlyOriginalOwner\n    onlyWithoutNewOwner\n    onlyWhenContractIsNotNodeOwner\n    {\n        // New owner is not really this address, but it\u0027s the way to recogize if offering\n        // was unregistered without having separate var for it, which is costly\n        offering.newOwner = address(0xdeaddead);\n        fireOnChanged(\"unregister\");\n    }\n\n    /**\n    * @dev Transfers ENS name ownership back to original owner\n    * Can be run only by original owner or emergency multisig\n    * Sets newOwner to special address 0xdead\n    */\n    function reclaimOwnership()\n    public\n    onlyWithoutNewOwner\n    {\n        bool isEmergency = isSenderEmergencyMultisig();\n        require(isEmergency || isSenderOriginalOwner());\n\n        if (isContractNodeOwner()) {\n            doTransferOwnership(offering.originalOwner);\n        }\n        if (isEmergency) {\n            // New owner is not really this address, but it\u0027s the way to recogize if\n            // was disabled in emergency without having separate var for it, which is costly\n            offering.newOwner = address(0xdead);\n        }\n        fireOnChanged(\"reclaimOwnership\");\n    }\n\n    /**\n    * @dev Transfers name ownership in context of offering contract\n    * Cannot be run if ownership was already transferred to new owner\n    * @param _newOwner address New owner of ENS name\n    */\n    function transferOwnership(address _newOwner)\n    internal\n    onlyWhenNotEmergencyPaused\n    onlyWithoutNewOwner\n    {\n        offering.newOwner = _newOwner;\n        offering.finalizedOn = uint64(now);\n        doTransferOwnership(_newOwner);\n        fireOnChanged(\"finalize\");\n    }\n\n    /**\n    * @dev Function to actually do ENS transfer\n    * Top level names should be transferred via registrar, so deed is transferred too\n    * @param _newOwner address New owner of ENS name\n    */\n    function doTransferOwnership(address _newOwner)\n    private\n    {\n        address payable newOwner = address(uint160(_newOwner));\n        if (isNodeTLDOfRegistrar()) {\n            HashRegistrar(ens.owner(rootNode)).transfer(offering.labelHash, newOwner);\n        } else {\n            ens.setOwner(offering.node, newOwner);\n        }\n    }\n\n    function doSetSettings(uint _price)\n    internal\n    {\n        offering.price = _price;\n    }\n\n    function fireOnChanged(bytes32 eventType, uint[] memory extraData)\n    internal\n    {\n        offeringRegistry.fireOnOfferingChanged(offering.version, eventType, extraData);\n    }\n\n    function fireOnChanged(bytes32 eventType) internal {\n        fireOnChanged(eventType, new uint[](0));\n    }\n\n    /**\n    * @dev Returns whether offering contract is owner of ENS name\n    * For top level names, offering contract must be also owner of registrar deed\n    * @return bool true if contract is ENS node owner\n    */\n    function isContractNodeOwner() public view returns(bool) {\n        if (isNodeTLDOfRegistrar()) {\n            address deed;\n            (,deed,,,) = HashRegistrar(ens.owner(rootNode)).entries(offering.labelHash);\n            return ens.owner(offering.node) == address(this) \u0026\u0026\n            Deed(deed).owner() == address(this);\n        } else {\n            return ens.owner(offering.node) == address(this);\n        }\n    }\n\n    /**\n    * @dev Exchanges funds of new owner for ownership of ENS name owner\n    * msg.value must exactly equal to offering price\n    */\n    function buy()\n    public\n    payable\n    {\n        require(msg.value == offering.price);\n        address payable origOwner = address(uint160(offering.originalOwner));\n        origOwner.transfer(offering.price);\n        transferOwnership(msg.sender);\n    }\n\n    /**\n    * @dev Returns whether offering node is top level name of registrar or subname\n    * @return bool true if offering node is top level name of registrar\n    */\n    function isNodeTLDOfRegistrar() public view returns (bool) {\n        return offering.node == keccak256(abi.encodePacked(rootNode, offering.labelHash));\n    }\n\n    /**\n    * @dev Returns whether msg.sender is original owner of ENS name, offering creator\n    * @return bool true if msg.sender is original owner\n    */\n    function isSenderOriginalOwner() public view returns(bool) {\n        return msg.sender == offering.originalOwner;\n    }\n\n    /**\n    * @dev Returns whether msg.sender is emergency multisig address\n    * @return bool true if msg.sender is emergency multisig\n    */\n    function isSenderEmergencyMultisig() public view returns(bool) {\n        return msg.sender == emergencyMultisig;\n    }\n\n    /**\n    * @dev Returns whether offerring was cancelled in emergency, by emergency multisig\n    * @return bool true if offering was cancelled in emergency\n    */\n    function wasEmergencyCancelled() public view returns(bool) {\n        return offering.newOwner == address(0xdead);\n    }\n}\n"},"OfferingFactory.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./OfferingRegistry.sol\";\nimport \"./Offering.sol\";\nimport \"./ENS.sol\";\nimport \"./HashRegistrar.sol\";\n\n/**\n * @title OfferingFactory\n * @dev Base contract factory for creating new offerings\n */\n\ncontract OfferingFactory {\n\n    ENS public ens;\n    OfferingRegistry public offeringRegistry;\n\n    // Hardcoded namehash of \"eth\"\n    bytes32 public constant rootNode = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    constructor (\n        ENS _ens,\n        OfferingRegistry _offeringRegistry\n    ) public {\n        ens = _ens;\n        offeringRegistry = _offeringRegistry;\n    }\n\n    /**\n    * @dev Deploys new BuyNow offering and registers it to OfferingRegistry\n    * @param name string Plaintext ENS name\n    * @param price uint The price of the offering\n    */\n    function createOffering(\n        bytes32 node,\n        string memory name,\n        bytes32 labelHash,\n        uint price\n    ) public {\n        Offering newOffering = new Offering(ens, offeringRegistry, offeringRegistry.emergencyMultisig());\n        uint8 version = 1;\n\n        newOffering.construct(\n            node,\n            name,\n            labelHash,\n            msg.sender,\n            version,\n            price\n        );\n\n        registerOffering(node, labelHash, address(newOffering), version);\n    }\n\n    /**\n    * @dev Registers new offering to OfferingRegistry, clears offering requests for this ENS node\n    * Must check if creator of offering is actual owner of ENS name and for top level names also deed owner\n    * @param node bytes32 ENS node\n    * @param labelHash bytes32 ENS labelhash\n    * @param newOffering address The address of new offering\n    * @param version uint The version of offering contract\n    */\n    function registerOffering(bytes32 node, bytes32 labelHash, address newOffering, uint version)\n        internal\n    {\n        require(ens.owner(node) == msg.sender);\n        if (node == keccak256(abi.encodePacked(rootNode, labelHash))) {\n            address deed;\n            (,deed,,,) = HashRegistrar(ens.owner(rootNode)).entries(labelHash);\n            require(Deed(deed).owner() == msg.sender);\n        }\n\n        offeringRegistry.addOffering(newOffering, node, msg.sender, version);\n    }\n}"},"OfferingRegistry.sol":{"content":"pragma solidity ^0.5.0;\n\n\nimport \"./UsedByFactories.sol\";\n\n\n/**\n * @title OfferingRegistry\n * @dev Offering registry is responsible to firing event each time offering is created or changed\n * This is mostly for offchain search DB to keep easily in sync\n */\n\ncontract OfferingRegistry is UsedByFactories {\n\n  event onOfferingAdded(address indexed offering, bytes32 indexed node, address indexed owner, uint version);\n  event onOfferingChanged(address indexed offering, uint version, bytes32 indexed eventType, uint[] extraData);\n\n  address public emergencyMultisig;                           // Emergency Multisig wallet of Namebazaar\n  bool public isEmergencyPaused = false;                      // Variable to pause buying activity on all offerings\n  mapping (address =\u003e bool) public isOffering;                // Stores whether given address of namebazaar offering\n\n\n  /**\n   * @dev Modifier to make a function callable only by Namebazaar Multisig wallet\n   */\n  modifier onlyEmergencyMultisig() {\n    require(msg.sender == emergencyMultisig);\n    _;\n  }\n\n  constructor(address _emergencyMultisig) public {\n    emergencyMultisig = _emergencyMultisig;\n  }\n\n  /**\n   * @dev Serves as central point for firing event when new offering is created\n   * Only offering factory can run this function\n   * @param offering address Address of newly created offering\n   * @param node bytes32 ENS node associated with new offering\n   * @param owner address Owner of the ENS name and creator of the offering\n   * @param version uint Version of offering contract\n   */\n  function addOffering(address offering, bytes32 node, address owner, uint version)\n  public\n  onlyFactory\n  {\n    isOffering[offering] = true;\n    emit onOfferingAdded(offering, node, owner, version);\n  }\n\n\n  /**\n   * @dev Serves as central point for firing event when offering state has been changed in any way\n   * Only offering contract can run this function\n   * @param version uint Version of offering contract\n   * @param eventType base32 Short string identifying offering change\n   * @param extraData uint[] Arbitrary data associated with event\n   */\n  function fireOnOfferingChanged(uint version, bytes32 eventType, uint[] memory extraData) public {\n    require(isOffering[msg.sender]);\n    emit onOfferingChanged(msg.sender, version, eventType, extraData);\n  }\n\n  /**\n   * @dev Function to activate emergency pause. This should stop buying activity on all offerings\n   * Only Emergency Multisig wallet should be able to call this\n   */\n  function emergencyPause() onlyEmergencyMultisig public {\n    isEmergencyPaused = true;\n  }\n\n  /**\n   * @dev Function to deactivate emergency pause. This should allow buying activity on all offerings again\n   * Only Emergency Multisig wallet should be able to call this\n   */\n  function emergencyRelease() onlyEmergencyMultisig public {\n    isEmergencyPaused = false;\n  }\n}"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract Ownable {\n\n    address public owner;\n\n    modifier onlyOwner {\n        require(isOwner(msg.sender));\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n    function isOwner(address addr) public view returns (bool) {\n        return owner == addr;\n    }\n}\n"},"Registrar.sol":{"content":"pragma solidity \u003e=0.4.24;\n\nimport \"./Deed.sol\";\n\ninterface Registrar {\n\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\n\n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n    event HashReleased(bytes32 indexed hash, uint value);\n    event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate);\n\n    function startAuction(bytes32 _hash) external;\n    function startAuctions(bytes32[] calldata _hashes) external;\n    function newBid(bytes32 sealedBid) external payable;\n    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable;\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external;\n    function cancelBid(address bidder, bytes32 seal) external;\n    function finalizeAuction(bytes32 _hash) external;\n    function transfer(bytes32 _hash, address payable newOwner) external;\n    function releaseDeed(bytes32 _hash) external;\n    function invalidateName(string calldata unhashedName) external;\n    function eraseNode(bytes32[] calldata labels) external;\n    function transferRegistrars(bytes32 _hash) external;\n    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external;\n    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint);\n}\n"},"Root.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ENS.sol\";\nimport \"./Ownable.sol\";\nimport \"./Controllable.sol\";\n\ncontract Root is Ownable, Controllable {\n    bytes32 constant private ROOT_NODE = bytes32(0);\n\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\n    event TLDLocked(bytes32 indexed label);\n\n    ENS public ens;\n    mapping(bytes32=\u003ebool) public locked;\n\n    constructor(ENS _ens) public {\n        ens = _ens;\n    }\n\n    function setSubnodeOwner(bytes32 label, address owner) external onlyController {\n        require(!locked[label]);\n        ens.setSubnodeOwner(ROOT_NODE, label, owner);\n    }\n\n    function setResolver(address resolver) external onlyOwner {\n        ens.setResolver(ROOT_NODE, resolver);\n    }\n\n    function lock(bytes32 label) external onlyOwner {\n        emit TLDLocked(label);\n        locked[label] = true;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return interfaceID == INTERFACE_META_ID;\n    }\n}\n"},"UsedByFactories.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @title UsedByFactories\n * @dev Provides modifiers to allow only offering factory contracts to execute method\n */\n\ncontract UsedByFactories is Ownable {\n\n    mapping(address =\u003e bool) public isFactory;\n\n    modifier onlyFactory() {\n        require(isFactory[msg.sender]);\n        _;\n    }\n\n    function setFactories(address[] memory factories, bool _isFactory)\n    public\n    onlyOwner\n    {\n        for(uint i = 0; i \u003c factories.length; i++) {\n            isFactory[factories[i]] = _isFactory;\n        }\n    }\n}"}}