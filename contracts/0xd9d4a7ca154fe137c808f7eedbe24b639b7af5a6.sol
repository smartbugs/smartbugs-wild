{"Cereneum.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./CereneumImplementation.sol\";\n\n/// @author AshKetchumNakamoto09\n/// @title A Trustless Interest-bearing Cryptographic Certificate of Interest on Ethereum\ncontract Cereneum is CereneumImplementation\n{\n\tusing SafeMath for uint256;\n\n\tconstructor(\n\t\t\tbytes32 a_hBTCMerkleTreeRoot,\n\t\t\tbytes32 a_hBCHMerkleTreeRoot,\n\t\t\tbytes32 a_hBSVMerkleTreeRoot,\n\t\t\tbytes32 a_hETHMerkleTreeRoot,\n\t\t\tbytes32 a_hLTCMerkleTreeRoot\n  )\n\tpublic\n\t{\n\t\t//Store the launch time of the contract\n    m_tContractLaunchTime = block.timestamp;\n    m_hMerkleTreeRootsArray[0] = a_hBTCMerkleTreeRoot;\n\t\tm_hMerkleTreeRootsArray[1] = a_hBCHMerkleTreeRoot;\n\t\tm_hMerkleTreeRootsArray[2] = a_hBSVMerkleTreeRoot;\n\t\tm_hMerkleTreeRootsArray[3] = a_hETHMerkleTreeRoot;\n\t\tm_hMerkleTreeRootsArray[4] = a_hLTCMerkleTreeRoot;\n\n\t\t//These ratios will be updated on snapshot day\n\t\t//All ratios have an invisible 0.0 in front of them\n\t\tm_blockchainRatios[0] = 5128; //BCH\n\t  m_blockchainRatios[1] = 2263; //BSV\n\t  m_blockchainRatios[2] = 3106; //ETH\n\t  m_blockchainRatios[3] = 1311; //LTC\n\n\t\t//Binance 1\n\t\tm_exchangeAirdropAddresses[0] = 0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE;\n\t\tm_exchangeAirdropAmounts[0] = 17400347788910;\n\n\t\t//Binance 2\n\t\tm_exchangeAirdropAddresses[1] = 0xD551234Ae421e3BCBA99A0Da6d736074f22192FF;\n\t\tm_exchangeAirdropAmounts[1] = 6758097982665;\n\n\t\t//Binance 3\n\t\tm_exchangeAirdropAddresses[2] = 0x564286362092D8e7936f0549571a803B203aAceD;\n\t\tm_exchangeAirdropAmounts[2] = 5557947334680;\n\n\t\t//Binance 4\n\t\tm_exchangeAirdropAddresses[3] = 0x0681d8Db095565FE8A346fA0277bFfdE9C0eDBBF;\n\t\tm_exchangeAirdropAmounts[3] = 5953786344335;\n\n\t\t//Binance 5 has little ether in it\n\n\t\t//Binance 6\n\t\tm_exchangeAirdropAddresses[4] = 0x4E9ce36E442e55EcD9025B9a6E0D88485d628A67;\n\t\tm_exchangeAirdropAmounts[4] = 779918770916450;\n\n\t\t//Bittrex1\n\t\tm_exchangeAirdropAddresses[5] = 0xFBb1b73C4f0BDa4f67dcA266ce6Ef42f520fBB98;\n\t\tm_exchangeAirdropAmounts[5] = 84975797259280;\n\n\t\t//Bittrex3\n\t\tm_exchangeAirdropAddresses[6] = 0x66f820a414680B5bcda5eECA5dea238543F42054;\n\t\tm_exchangeAirdropAmounts[6] = 651875804471280;\n\n\t\t//KuCoin1\n\t\tm_exchangeAirdropAddresses[7] = 0x2B5634C42055806a59e9107ED44D43c426E58258;\n\t\tm_exchangeAirdropAmounts[7] = 6609673761160;\n\n\t\t//KuCoin2\n\t\tm_exchangeAirdropAddresses[8] = 0x689C56AEf474Df92D44A1B70850f808488F9769C;\n\t\tm_exchangeAirdropAmounts[8] = 4378334643430;\n\n\t\t//LAToken\n\t\tm_exchangeAirdropAddresses[9] = 0x7891b20C690605F4E370d6944C8A5DBfAc5a451c;\n\t\tm_exchangeAirdropAmounts[9] = 6754951284855;\n\n\t\t//Huobi Global\n\t\tm_exchangeAirdropAddresses[10] = 0xDc76CD25977E0a5Ae17155770273aD58648900D3;\n\t\tm_exchangeAirdropAmounts[10] = 427305320984440;\n\n\t\t//CoinBene\n\t\tm_exchangeAirdropAddresses[11] = 0x33683b94334eeBc9BD3EA85DDBDA4a86Fb461405;\n\t\tm_exchangeAirdropAmounts[11] = 2414794474090;\n\n    //Mint all claimable coins to contract wallet\n    _mint(address(this), m_nMaxRedeemable);\n\t}\n\n\t//ERC20 Constants\n  string public constant name = \"Cereneum\";\n  string public constant symbol = \"CER\";\n  uint public constant decimals = 8;\n\n\t/// @dev A one time callable function to airdrop Ethereum chain CER tokens to some exchange wallets.\n\t/// The amounts granted had the standard whale penalties applied and were removed from the UTXO\n\t/// set before the Merkle Tree was built so they cannot be claimed a second time.\n\tfunction ExchangeEthereumAirdrops() external\n\t{\n\t\tUpdateDailyData();\n\n\t\trequire(m_bHasAirdroppedExchanges == false);\n\t\tm_bHasAirdroppedExchanges = true;\n\n\t\t//The following Ethereum exchange addresses are removed from the claimable UTXO set and automatically airdropped\n\t\t//To encourage early exchange support.\n\t\tuint256 nGenesisBonuses = 0;\n\t\tuint256 nPublicReferralBonuses = 0;\n\t\tuint256 nTokensRedeemed = 0;\n\t\tuint256 nBonuses = 0;\n\t\tuint256 nPenalties = 0;\n\n\t\tfor(uint256 i=0; i \u003c 12; ++i)\n\t\t{\n\t\t\t(nTokensRedeemed, nBonuses, nPenalties) = GetRedeemAmount(m_exchangeAirdropAmounts[i], BlockchainType.Ethereum);\n\n\t\t\t//Transfer coins from contracts wallet to claim wallet\n\t\t\t_transfer(address(this), m_exchangeAirdropAddresses[i], nTokensRedeemed);\n\n\t\t\t//Mint speed bonus and 10% referral bonus to claiming address\n\t\t\t_mint(m_exchangeAirdropAddresses[i], nBonuses.add(nTokensRedeemed.div(10)));\n\n\t\t\t//Speed bonus and referral bonus matched for genesis address (20% for referral and 10% for claimer referral = 30%)\n\t\t\tnGenesisBonuses = nGenesisBonuses.add(nBonuses.add(nTokensRedeemed.mul(1000000000000).div(3333333333333)));\n\n\t\t\t//Grant 20% bonus of tokens to referrer\n\t\t\tnPublicReferralBonuses = nPublicReferralBonuses.add(nTokensRedeemed.div(5));\n\n\t\t\tm_nTotalRedeemed = m_nTotalRedeemed.add(GetRedeemRatio(m_exchangeAirdropAmounts[i], BlockchainType.Ethereum));\n\t\t\tm_nRedeemedCount = m_nRedeemedCount.add(1);\n\t\t}\n\n\t\t//Mint all of the referrer bonuses in a single call\n\t\t_mint(m_publicReferralAddress, nPublicReferralBonuses);\n\n\t\t//Mint all of the genesis bonuses in a single call\n\t\t_mint(m_genesis, nGenesisBonuses);\n\t}\n}\n"},"CereneumData.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./MerkleProof.sol\";\nimport \"./ERC20.sol\";\nimport \"./SafeMath.sol\";\n\ncontract CereneumData is ERC20\n{\n\tusing SafeMath for uint256;\n\n  //Launch timestamp of contract used to track how long contract has been running\n  uint256 internal m_tContractLaunchTime;\n\n\t//Root hashes of the 5 UTXO Merkle trees. Used to verify claims.\n  //0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  bytes32[5] public m_hMerkleTreeRootsArray;\n\n\t//Total number of UTXO\u0027s at snapshot. Used for calculating bonus rewards.\n  uint256 public constant m_nUTXOCountAtSnapshot = 85997439;\n\n  //Maximum number of redeemable coins at snapshot.\n  uint256 public constant m_nMaxRedeemable = 21275254524468718;\n\n  //For Prosperous bonus we need to use the adjusted redeemable amount\n  //That has the whale penalties applied (lowering claimable supply)\n  uint256 public constant m_nAdjustedMaxRedeemable = 15019398043400000;\n\n\t//Genesis Address\n  address constant internal m_genesis = 0xb26165df612B1c9dc705B9872178B3F48151b24d;\n\n\t//Eth Pool Genesis Address\n\taddress payable constant internal m_EthGenesis = 0xbe9CEF4196a835F29B117108460ed6fcA299b611;\n\n\t//The public donation address for referrals\n\taddress payable constant internal m_publicReferralAddress = 0x8eAf4Fec503da352EB66Ef1E2f75C63e5bC635e1;\n\n  //Store the BTC ratios for BCH, BSV, ETH and LTC\n  uint16[4] public m_blockchainRatios;\n\n  enum AddressType { LegacyUncompressed, LegacyCompressed, SegwitUncompressed, SegwitCompressed }\n  enum BlockchainType { Bitcoin, BitcoinCash, BitcoinSV, Ethereum, Litecoin }\n\n\t//Track how many tokens and UTXOs have been redeemed.\n\t//These are used for calculating bonus rewards.\n  uint256 public m_nTotalRedeemed = 0;\n  uint256 public m_nRedeemedCount = 0;\n\n  //Map of redeemed UTXOs to boolean (true/false if redeemed or not)\n  mapping(uint8 =\u003e mapping(bytes32 =\u003e bool)) internal m_claimedUTXOsMap;\n\n  //Store the last day UpdateDailyData() was successfully executed\n\t//Starts at 14 to give a two week buffer after contract launch\n  uint256 internal m_nLastUpdatedDay = 14;\n\n  //Daily data\n  struct DailyDataStuct\n\t{\n    uint256 nPayoutAmount;\n    uint256 nTotalStakeShares;\n\t\tuint256 nTotalEthStaked;\n  }\n\n\t//Map to store daily historical data.\n  mapping(uint256 =\u003e DailyDataStuct) public m_dailyDataMap;\n\n  //Stakes Storage\n  struct StakeStruct\n\t{\n    uint256 nAmountStaked;\n    uint256 nSharesStaked;\t//Get bonus shares for longer stake times\n\t\tuint256 nCompoundedPayoutAccumulated;\n    uint256 tLockTime;\n    uint256 tEndStakeCommitTime;\n\t\tuint256 tLastCompoundedUpdateTime;\n    uint256 tTimeRemovedFromGlobalPool;\n\t\tuint8 nVotedOnMultiplier;\n\t\tbool bIsInGlobalPool;\n    bool bIsLatePenaltyAlreadyPooled;\n  }\n\n\t//Eth Pool Stakes Storage\n  struct EthStakeStruct\n\t{\n    uint256 nAmount;\n    uint256 nDay;\n  }\n\n\t//Map of addresses to StakeStructs.\n  mapping(address =\u003e StakeStruct[]) public m_staked;\n\n\t//Map of addresses to ETH amount (in Wei) participating in the Eth pool\n\tmapping(address =\u003e EthStakeStruct[]) public m_EthereumStakers;\n\n\t//Accumulated early/late unstake penalties to go into next staker pool as rewards\n  uint256 internal m_nEarlyAndLateUnstakePool;\n\n\t//Track the number of staked tokens and shares\n  uint256 public m_nTotalStakedTokens;\n  uint256 public m_nTotalStakeShares;\n\n\t//The daily amount of ETH in the ETH pool\n\tuint256 public m_nTotalEthStaked = 0;\n\n\t//The latest interest multiplier voted on by the majority of the staker pool\n  uint8 public m_nInterestMultiplier = 1;\n\n\t//The number of stake shares voting for each interest multiplier\n\t//1 keeps the base 5% interest (minimum), 2 is 10%, ... 10 is 50% (maximum)\n\tmapping(uint8 =\u003e uint256) public m_votingMultiplierMap;\n\n  //Maximum stake time allowed\n  uint256 internal constant m_nMaxStakingTime = 365 days * 5;\t//years is deprecated because of leap years\n\n\t//Two week buffer window after launch before interest starts\n\tuint256 internal constant m_nClaimPhaseBufferDays = 14;\n\n\tuint256 public m_nLastEthWithdrawalTime = 0;\n\n\tbool internal m_bHasAirdroppedExchanges = false;\n\n\taddress[12] internal m_exchangeAirdropAddresses;\n\tuint256[12] internal m_exchangeAirdropAmounts;\n}\n"},"CereneumImplementation.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./CereneumData.sol\";\n\ncontract CereneumImplementation is CereneumData\n{\n\tusing SafeMath for uint256;\n\n\t//Events\n  event ClaimEvent(\n    uint256 nOriginalClaimAmount,\n    uint256 nAmountGranted,\n    uint256 nBonuses,\n\t\tuint256 nPenalties,\n    bool bWasReferred\n  );\n\n  event StartStakeEvent(\n    uint256 nAmount,\n    uint256 nDays\n  );\n\n\tevent CompoundInterestEvent(\n\t\tuint256 nInterestCompounded\n\t);\n\n  event EndStakeEvent(\n    uint256 nPrincipal,\n    uint256 nPayout,\n    uint256 nDaysServed,\n    uint256 nPenalty,\n    uint256 nStakeShares,\n    uint256 nDaysCommitted\n  );\n\n  event EndStakeForAFriendEvent(\n    uint256 nShares,\n    uint256 tStakeEndTimeCommit\n  );\n\n\tevent StartEthStakeEvent(\n    uint256 nEthAmount\n  );\n\n\tevent EndEthStakeEvent(\n    uint256 nPayout\n  );\n\n\t/// @dev Returns the number of current stakes for given address.\n\t///\t@param a_address Address of stake to lookup\n\t///\t@return The number of stakes.\n\tfunction GetNumberOfStakes(\n\t\taddress a_address\n\t)\n\texternal view returns (uint256)\n\t{\n\t\treturn m_staked[a_address].length;\n\t}\n\n\t/// @dev Returns the number of current Eth pool stakes for given address.\n\t///\t@param a_address Address of stake to lookup\n\t///\t@return The number of stakes.\n\tfunction GetNumberOfEthPoolStakes(\n\t\taddress a_address\n\t)\n\texternal view returns (uint256)\n\t{\n\t\treturn m_EthereumStakers[a_address].length;\n\t}\n\n  /// @dev Returns the timestamp until the next daily update\n\t///\t@return The time until the next daily update.\n\tfunction GetTimeUntilNextDailyUpdate() external view returns (uint256)\n\t{\n    uint256 nDay = 1 days;\n\t\treturn nDay.sub((block.timestamp.sub(m_tContractLaunchTime)).mod(1 days));\n\t}\n\n\t/// @dev Calculates difference between 2 timestamps in days\n \t/// @param a_nStartTime beginning timestamp\n  /// @param a_nEndTime ending timestamp\n  /// @return Difference between timestamps in days\n  function DifferenceInDays(\n    uint256 a_nStartTime,\n    uint256 a_nEndTime\n  ) public pure returns (uint256)\n\t{\n    return (a_nEndTime.sub(a_nStartTime).div(1 days));\n  }\n\n  /// @dev Calculates the number of days since contract launch for a given timestamp.\n  /// @param a_tTimestamp Timestamp to calculate from\n  /// @return Number of days into contract\n  function TimestampToDaysSinceLaunch(\n    uint256 a_tTimestamp\n  ) public view returns (uint256)\n\t{\n    return (a_tTimestamp.sub(m_tContractLaunchTime).div(1 days));\n  }\n\n  /// @dev Gets the number of days since the launch of the contract\n  /// @return Number of days since contract launch\n  function DaysSinceLaunch() public view returns (uint256)\n\t{\n    return (TimestampToDaysSinceLaunch(block.timestamp));\n  }\n\n  /// @dev Checks if we\u0027re still in the claimable phase (first 52 weeks)\n  /// @return Boolean on if we are still in the claimable phase\n  function IsClaimablePhase() public view returns (bool)\n\t{\n    return (DaysSinceLaunch() \u003c 364);\n  }\n\n\t/// @dev Starts a 1 day stake in the ETH pool. Requires minimum of 0.01 ETH\n\tfunction StartEthStake() external payable\n\t{\n\t\t//Require the minimum value for staking\n\t\trequire(msg.value \u003e= 0.01 ether, \"ETH Sent not above minimum value\");\n\n\t\trequire(DaysSinceLaunch() \u003e= m_nClaimPhaseBufferDays, \"Eth Pool staking doesn\u0027t begin until after the buffer window\");\n\n\t\tUpdateDailyData();\n\n\t\tm_EthereumStakers[msg.sender].push(\n      EthStakeStruct(\n        msg.value, // Ethereum staked\n\t\t\t\tDaysSinceLaunch()\t//Day staked\n      )\n    );\n\n\t\temit StartEthStakeEvent(\n      msg.value\n    );\n\n\t\tm_nTotalEthStaked = m_nTotalEthStaked.add(msg.value);\n  }\n\n\t/// @dev The default function\n\tfunction() external payable\n\t{\n\n  }\n\n\t/// @dev Withdraw CER from the Eth pool after stake has completed\n \t/// @param a_nIndex The index of the stake to be withdrawn\n\tfunction WithdrawFromEthPool(uint256 a_nIndex) external\n\t{\n\t\t//Require that the stake index doesn\u0027t go out of bounds\n\t\trequire(m_EthereumStakers[msg.sender].length \u003e a_nIndex, \"Eth stake does not exist\");\n\n\t\tUpdateDailyData();\n\n\t\tuint256 nDay = m_EthereumStakers[msg.sender][a_nIndex].nDay;\n\n\t\trequire(nDay \u003c DaysSinceLaunch(), \"Must wait until next day to withdraw\");\n\n\t\tuint256 nAmount = m_EthereumStakers[msg.sender][a_nIndex].nAmount;\n\n\t\tuint256 nPayoutAmount = m_dailyDataMap[nDay].nPayoutAmount.div(10);\t//10%\n\n\t\tuint256 nEthPoolPayout = nPayoutAmount.mul(nAmount)\n\t\t\t.div(m_dailyDataMap[nDay].nTotalEthStaked);\n\n\t\t_mint(msg.sender, nEthPoolPayout);\n\n\t\temit EndEthStakeEvent(\n      nEthPoolPayout\n    );\n\n\t\tuint256 nEndingIndex = m_EthereumStakers[msg.sender].length.sub(1);\n\n    //Only copy if we aren\u0027t removing the last index\n    if(nEndingIndex != a_nIndex)\n    {\n      //Copy last stake in array over stake we are removing\n      m_EthereumStakers[msg.sender][a_nIndex] = m_EthereumStakers[msg.sender][nEndingIndex];\n    }\n\n    //Lower array length by 1\n    m_EthereumStakers[msg.sender].length = nEndingIndex;\n\t}\n\n\t/// @dev Transfers ETH in the contract to the genesis address\n\t/// Only callable once every 12 weeks.\n\tfunction TransferContractETH() external\n  {\n  \trequire(address(this).balance != 0, \"No Eth to transfer\");\n\n\t\trequire(m_nLastEthWithdrawalTime.add(12 weeks) \u003c= block.timestamp, \"Can only withdraw once every 3 months\");\n\n    m_EthGenesis.transfer(address(this).balance);\n\n\t\tm_nLastEthWithdrawalTime = block.timestamp;\n  }\n\n\t/// @dev Updates and stores the global interest for each day.\n\t/// Additionally adds the frenzy/prosperous bonuses and the Early/Late unstake penalties.\n\t/// This function gets called at the start of popular public functions to continuously update.\n  function UpdateDailyData() public\n\t{\n    for(m_nLastUpdatedDay; DaysSinceLaunch() \u003e m_nLastUpdatedDay; m_nLastUpdatedDay++)\n\t\t{\n\t\t\t//Gives 5% inflation per 365 days\n      uint256 nPayoutRound = totalSupply().div(7300);\n\n      uint256 nUnclaimedCoins = 0;\n    \t//Frenzy/Prosperous bonuses and Unclaimed redistribution only available during claims phase.\n      if(m_nLastUpdatedDay \u003c 364)\n\t\t\t{\n        nUnclaimedCoins = m_nMaxRedeemable.sub(m_nTotalRedeemed);\n\t\t\t\tnUnclaimedCoins = GetRobinHoodMonthlyAmount(nUnclaimedCoins, m_nLastUpdatedDay);\n\n        nPayoutRound = nPayoutRound.add(nUnclaimedCoins);\n\n\t\t\t\t//Pay frenzy and Prosperous bonuses to genesis address\n        _mint(m_genesis, nPayoutRound.mul(m_nRedeemedCount).div(m_nUTXOCountAtSnapshot)); // Frenzy\n        _mint(m_genesis, nPayoutRound.mul(m_nTotalRedeemed).div(m_nAdjustedMaxRedeemable)); // Prosperous\n\n        nPayoutRound = nPayoutRound.add(\n          //Frenzy bonus 0-100% based on total users claiming\n          nPayoutRound.mul(m_nRedeemedCount).div(m_nUTXOCountAtSnapshot)\n        ).add(\n          //Prosperous bonus 0-100% based on size of claims\n          nPayoutRound.mul(m_nTotalRedeemed).div(m_nAdjustedMaxRedeemable)\n        );\n      }\n\t\t\telse\n\t\t\t{\n\t\t\t\t//If we are not in the claimable phase anymore apply the voted on interest multiplier\n\n\t\t\t\t//First we need to check if there is a new \"most voted on\" multiplier\n\t\t\t\tuint8 nVoteMultiplier = 1;\n\t\t\t\tuint256 nVoteCount = m_votingMultiplierMap[1];\n\n\t\t\t\tfor(uint8 i=2; i \u003c= 10; i++)\n\t\t\t\t{\n\t\t\t\t\tif(m_votingMultiplierMap[i] \u003e nVoteCount)\n\t\t\t\t\t{\n\t\t\t\t\t\tnVoteCount = m_votingMultiplierMap[i];\n\t\t\t\t\t\tnVoteMultiplier = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnPayoutRound = nPayoutRound.mul(nVoteMultiplier);\n\n\t\t\t\t//Store last interest multiplier for public viewing\n\t\t\t\tm_nInterestMultiplier = nVoteMultiplier;\n\t\t\t}\n\n\t\t\t//Add nPayoutRound to contract\u0027s balance\n\t\t\t_mint(address(this), nPayoutRound.sub(nUnclaimedCoins));\n\n      //Add early and late unstake pool to payout round\n\t\t\tif(m_nEarlyAndLateUnstakePool != 0)\n\t\t\t{\n      \tnPayoutRound = nPayoutRound.add(m_nEarlyAndLateUnstakePool);\n\t\t\t\t//Reset back to 0 for next day\n      \tm_nEarlyAndLateUnstakePool = 0;\n\t\t\t}\n\n    \t//Store daily data\n      m_dailyDataMap[m_nLastUpdatedDay] = DailyDataStuct(\n        nPayoutRound,\n        m_nTotalStakeShares,\n\t\t\t\tm_nTotalEthStaked\n      );\n\n\t\t\tm_nTotalEthStaked = 0;\n    }\n  }\n\n  /// @dev Gets the circulating supply (total supply minus staked coins).\n  /// @return Circulating Supply\n  function GetCirculatingSupply() external view returns (uint256)\n\t{\n    return totalSupply().sub(balanceOf(address(this)));\n  }\n\n  /// @dev Verify a Merkle proof using the UTXO Merkle tree\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\n  /// @param a_hMerkleLeaf Merkle leaf hash that must be present in the UTXO Merkle tree\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @return Boolean on validity of proof\n  function VerifyProof(\n    bytes32[] memory a_hMerkleTreeBranches,\n    bytes32 a_hMerkleLeaf,\n    BlockchainType a_nWhichChain\n  ) public view returns (bool)\n\t{\n    require(uint8(a_nWhichChain) \u003e= 0 \u0026\u0026 uint8(a_nWhichChain) \u003c= 4, \"Invalid blockchain option\");\n\n    return MerkleProof.verify(a_hMerkleTreeBranches, m_hMerkleTreeRootsArray[uint8(a_nWhichChain)], a_hMerkleLeaf);\n  }\n\n  /// @dev Validate the ECDSA parameters of signed message\n  /// ECDSA public key associated with the specified Ethereum address\n  /// @param a_addressClaiming Address within signed message\n  /// @param a_publicKeyX X parameter of uncompressed ECDSA public key\n  /// @param a_publicKeyY Y parameter of uncompressed ECDSA public key\n  /// @param a_v v parameter of ECDSA signature\n  /// @param a_r r parameter of ECDSA signature\n  /// @param a_s s parameter of ECDSA signature\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @return Boolean on if the signature is valid\n  function ECDSAVerify(\n    address a_addressClaiming,\n    bytes32 a_publicKeyX,\n    bytes32 a_publicKeyY,\n    uint8 a_v,\n    bytes32 a_r,\n    bytes32 a_s,\n    BlockchainType a_nWhichChain\n  ) public pure returns (bool)\n\t{\n    bytes memory addressAsHex = GenerateSignatureMessage(a_addressClaiming, a_nWhichChain);\n\n    bytes32 hHash;\n    if(a_nWhichChain != BlockchainType.Ethereum)  //All Bitcoin chains and Litecoin do double sha256 hash\n    {\n      hHash = sha256(abi.encodePacked(sha256(abi.encodePacked(addressAsHex))));\n    }\n    else //Otherwise ETH\n    {\n      hHash = keccak256(abi.encodePacked(addressAsHex));\n    }\n\n    return ValidateSignature(\n      hHash,\n      a_v,\n      a_r,\n      a_s,\n      PublicKeyToEthereumAddress(a_publicKeyX, a_publicKeyY)\n    );\n  }\n\n  /// @dev Convert an uncompressed ECDSA public key into an Ethereum address\n  /// @param a_publicKeyX X parameter of uncompressed ECDSA public key\n  /// @param a_publicKeyY Y parameter of uncompressed ECDSA public key\n  /// @return Ethereum address generated from the ECDSA public key\n  function PublicKeyToEthereumAddress(\n    bytes32 a_publicKeyX,\n    bytes32 a_publicKeyY\n  ) public pure returns (address)\n\t{\n\t\tbytes32 hash = keccak256(abi.encodePacked(a_publicKeyX, a_publicKeyY));\n    return address(uint160(uint256((hash))));\n  }\n\n  /// @dev Calculate the Bitcoin-style address associated with an ECDSA public key\n  /// @param a_publicKeyX First half of ECDSA public key\n  /// @param a_publicKeyY Second half of ECDSA public key\n  /// @param a_nAddressType Whether BTC/LTC is Legacy or Segwit address and if it was compressed\n  /// @return Raw Bitcoin address\n  function PublicKeyToBitcoinAddress(\n    bytes32 a_publicKeyX,\n    bytes32 a_publicKeyY,\n    AddressType a_nAddressType\n  ) public pure returns (bytes20)\n\t{\n    bytes20 publicKey;\n    uint8 initialByte;\n    if(a_nAddressType == AddressType.LegacyCompressed || a_nAddressType == AddressType.SegwitCompressed)\n\t\t{\n      //Hash the compressed format\n      initialByte = (uint256(a_publicKeyY) \u0026 1) == 0 ? 0x02 : 0x03;\n      publicKey = ripemd160(abi.encodePacked(sha256(abi.encodePacked(initialByte, a_publicKeyX))));\n    }\n\t\telse\n\t\t{\n      //Hash the uncompressed format\n      initialByte = 0x04;\n      publicKey = ripemd160(abi.encodePacked(sha256(abi.encodePacked(initialByte, a_publicKeyX, a_publicKeyY))));\n    }\n\n    if(a_nAddressType == AddressType.LegacyUncompressed || a_nAddressType == AddressType.LegacyCompressed)\n    {\n      return publicKey;\n    }\n    else if(a_nAddressType == AddressType.SegwitUncompressed || a_nAddressType == AddressType.SegwitCompressed)\n    {\n      return ripemd160(abi.encodePacked(sha256(abi.encodePacked(hex\"0014\", publicKey))));\n    }\n  }\n\n  /// @dev Appends an Ethereum address onto the expected string for a Bitcoin signed message\n  /// @param a_address Ethereum address\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @return Correctly formatted message for bitcoin signing\n\tfunction GenerateSignatureMessage(\n    address a_address,\n    BlockchainType a_nWhichChain\n  ) public pure returns(bytes memory)\n\t{\n\t\tbytes16 hexDigits = \"0123456789abcdef\";\n\t\tbytes memory prefix;\n    uint8 nPrefixLength = 0;\n\n    //One of the bitcoin chains\n    if(a_nWhichChain \u003e= BlockchainType.Bitcoin \u0026\u0026 a_nWhichChain \u003c= BlockchainType.BitcoinSV)\n    {\n      nPrefixLength = 46;\n      prefix = new bytes(nPrefixLength);\n      prefix = \"\\x18Bitcoin Signed Message:\\n\\x3CClaim_Cereneum_to_0x\";\n    }\n    else if(a_nWhichChain == BlockchainType.Ethereum) //Ethereum chain\n    {\n      nPrefixLength = 48;\n      prefix = new bytes(nPrefixLength);\n      prefix = \"\\x19Ethereum Signed Message:\\n60Claim_Cereneum_to_0x\";\n    }\n    else  //Otherwise LTC\n    {\n      nPrefixLength = 47;\n      prefix = new bytes(nPrefixLength);\n      prefix = \"\\x19Litecoin Signed Message:\\n\\x3CClaim_Cereneum_to_0x\";\n    }\n\n\t\tbytes20 addressBytes = bytes20(a_address);\n\t\tbytes memory message = new bytes(nPrefixLength + 40);\n\t\tuint256 nOffset = 0;\n\n\t\tfor(uint i = 0; i \u003c nPrefixLength; i++)\n\t\t{\n    \tmessage[nOffset++] = prefix[i];\n    }\n\n\t\tfor(uint i = 0; i \u003c 20; i++)\n\t\t{\n      message[nOffset++] = hexDigits[uint256(uint8(addressBytes[i] \u003e\u003e 4))];\n      message[nOffset++] = hexDigits[uint256(uint8(addressBytes[i] \u0026 0x0f))];\n    }\n\n\t\treturn message;\n\t}\n\n  /// @dev Validate ECSDA signature was signed by the specified address\n  /// @param a_hash Hash of signed data\n  /// @param a_v v parameter of ECDSA signature\n  /// @param a_r r parameter of ECDSA signature\n  /// @param a_s s parameter of ECDSA signature\n  /// @param a_address Ethereum address matching the signature\n  /// @return Boolean on if the signature is valid\n  function ValidateSignature(\n    bytes32 a_hash,\n    uint8 a_v,\n    bytes32 a_r,\n    bytes32 a_s,\n    address a_address\n  ) public pure returns (bool)\n\t{\n    return ecrecover(\n      a_hash,\n      a_v,\n      a_r,\n      a_s\n    ) == a_address;\n  }\n\n  /// @dev Verify that a UTXO with the Merkle leaf hash can be claimed\n  /// @param a_hMerkleLeafHash Merkle tree hash of the UTXO to be checked\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @return Boolean on if the UTXO from the given hash can be redeemed\n  function CanClaimUTXOHash(\n    bytes32 a_hMerkleLeafHash,\n    bytes32[] memory a_hMerkleTreeBranches,\n    BlockchainType a_nWhichChain\n  ) public view returns (bool)\n\t{\n    //Check that the UTXO has not yet been redeemed and that it exists in the Merkle tree\n    return(\n\t\t\t(m_claimedUTXOsMap[uint8(a_nWhichChain)][a_hMerkleLeafHash] == false) \u0026\u0026 VerifyProof(a_hMerkleTreeBranches, a_hMerkleLeafHash, a_nWhichChain)\n    );\n  }\n\n  /// @dev Check if address can make a claim\n  /// @param a_addressRedeeming Raw Bitcoin address (no base58-check encoding)\n  /// @param a_nAmount Amount of UTXO to redeem\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @return Boolean on if the UTXO can be redeemed\n  function CanClaim(\n    bytes20 a_addressRedeeming,\n    uint256 a_nAmount,\n    bytes32[] memory a_hMerkleTreeBranches,\n    BlockchainType a_nWhichChain\n  ) public view returns (bool)\n\t{\n    //Calculate the hash of the Merkle leaf associated with this UTXO\n    bytes32 hMerkleLeafHash = keccak256(\n      abi.encodePacked(\n        a_addressRedeeming,\n        a_nAmount\n      )\n    );\n\n    //Check if it can be redeemed\n    return CanClaimUTXOHash(hMerkleLeafHash, a_hMerkleTreeBranches, a_nWhichChain);\n  }\n\n\t/// @dev Calculates the monthly Robin Hood reward\n  /// @param a_nAmount The amount to calculate from\n  /// @param a_nDaysSinceLaunch The number of days since contract launch\n  /// @return The amount after applying monthly Robin Hood calculation\n\tfunction GetRobinHoodMonthlyAmount(uint256 a_nAmount, uint256 a_nDaysSinceLaunch) public pure returns (uint256)\n\t{\n\t\tuint256 nScaledAmount = a_nAmount.mul(1000000000000);\n\t\tuint256 nScalar = 400000000000000;\t// 0.25%\n\t\t//Month 1 - 0.25% late penalty\n\t\tif(a_nDaysSinceLaunch \u003c 43)\n\t\t{\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 2 - Additional 0.5% penalty\n\t\t// 0.25% + 0.5% = .75%\n\t\telse if(a_nDaysSinceLaunch \u003c 72)\n\t\t{\n\t\t\tnScalar = 200000000000000;\t// 0.5%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 3 - Additional 0.75% penalty\n\t\t// 0.25% + 0.5% + .75% = 1.5%\n\t\telse if(a_nDaysSinceLaunch \u003c 101)\n\t\t{\n\t\t\tnScalar = 133333333333333;\t// 0.75%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 4 - Additional 1.5%\n\t\t// 0.25% + 0.5% + .75% + 1.5% = 3%\n\t\telse if(a_nDaysSinceLaunch \u003c 130)\n\t\t{\n\t\t\tnScalar = 66666666666666;\t// 1.5%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 5 - Additional 3%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% = 6%\n\t\telse if(a_nDaysSinceLaunch \u003c 159)\n\t\t{\n\t\t\tnScalar = 33333333333333;\t// 3%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 6 - Additional 6%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% = 12%\n\t\telse if(a_nDaysSinceLaunch \u003c 188)\n\t\t{\n\t\t\tnScalar = 16666666666666;\t// 6%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 7 - Additional 8%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% = 20%\n\t\telse if(a_nDaysSinceLaunch \u003c 217)\n\t\t{\n\t\t\tnScalar = 12499999999999;\t// 8%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 8 - Additional 10%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% = 30%\n\t\telse if(a_nDaysSinceLaunch \u003c 246)\n\t\t{\n\t\t\tnScalar = 10000000000000;\t// 10%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 9 - Additional 12.5%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% = 42.5%\n\t\telse if(a_nDaysSinceLaunch \u003c 275)\n\t\t{\n\t\t\tnScalar = 7999999999999;\t// 12.5%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 10 - Additional 15%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% = 57.5%\n\t\telse if(a_nDaysSinceLaunch \u003c 304)\n\t\t{\n\t\t\tnScalar = 6666666666666;\t// 15%\n\t\t\treturn nScaledAmount.div(nScalar.mul(29));\n\t\t}\n\t\t//Month 11 - Additional 17.5%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% = 75%\n\t\telse if(a_nDaysSinceLaunch \u003c 334)\n\t\t{\n\t\t\tnScalar = 5714285714290;\t// 17.5%\n\t\t\treturn nScaledAmount.div(nScalar.mul(30));\n\t\t}\n\t\t//Month 12 - Additional 25%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% + 25% = 100%\n\t\telse if(a_nDaysSinceLaunch \u003c 364)\n\t\t{\n\t\t\tnScalar = 4000000000000;\t// 25%\n\t\t\treturn nScaledAmount.div(nScalar.mul(30));\n\t\t}\n\t}\n\n\t/// @dev Calculates the monthly late penalty\n  /// @param a_nAmount The amount to calculate from\n  /// @param a_nDaysSinceLaunch The number of days since contract launch\n  /// @return The amount after applying monthly late penalty\n\tfunction GetMonthlyLatePenalty(uint256 a_nAmount, uint256 a_nDaysSinceLaunch) public pure returns (uint256)\n\t{\n\t\tif(a_nDaysSinceLaunch \u003c= m_nClaimPhaseBufferDays)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 nScaledAmount = a_nAmount.mul(1000000000000);\n\t\tuint256 nPreviousMonthPenalty = 0;\n\t\tuint256 nScalar = 400000000000000;\t// 0.25%\n\t\t//Month 1 - 0.25% late penalty\n\t\tif(a_nDaysSinceLaunch \u003c= 43)\n\t\t{\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(14);\n\t\t\treturn nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t}\n\t\t//Month 2 - Additional 0.5% penalty\n\t\t// 0.25% + 0.5% = .75%\n\t\telse if(a_nDaysSinceLaunch \u003c= 72)\n\t\t{\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(43);\n\t\t\tnScalar = 200000000000000;\t// 0.5%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 3 - Additional 0.75% penalty\n\t\t// 0.25% + 0.5% + .75% = 1.5%\n\t\telse if(a_nDaysSinceLaunch \u003c= 101)\n\t\t{\n\t\t\tnScalar = 133333333333333;\t// 0.75%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(72);\n\t\t\tnScalar = 133333333333333;\t// 0.75%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 4 - Additional 1.5%\n\t\t// 0.25% + 0.5% + .75% + 1.5% = 3%\n\t\telse if(a_nDaysSinceLaunch \u003c= 130)\n\t\t{\n\t\t\tnScalar = 66666666666666;\t// 1.5%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(101);\n\t\t\tnScalar = 66666666666666;\t// 1.5%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 5 - Additional 3%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% = 6%\n\t\telse if(a_nDaysSinceLaunch \u003c= 159)\n\t\t{\n\t\t\tnScalar = 33333333333333;\t// 3%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(130);\n\t\t\tnScalar = 33333333333333;\t// 3%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 6 - Additional 6%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% = 12%\n\t\telse if(a_nDaysSinceLaunch \u003c= 188)\n\t\t{\n\t\t\tnScalar = 16666666666666;\t// 6%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(159);\n\t\t\tnScalar = 16666666666666;\t// 6%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 7 - Additional 8%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% = 20%\n\t\telse if(a_nDaysSinceLaunch \u003c= 217)\n\t\t{\n\t\t\tnScalar = 8333333333333;\t// 12%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(188);\n\t\t\tnScalar = 12499999999999;\t// 8%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 8 - Additional 10%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% = 30%\n\t\telse if(a_nDaysSinceLaunch \u003c= 246)\n\t\t{\n\t\t\tnScalar = 5000000000000;\t// 20%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(217);\n\t\t\tnScalar = 10000000000000;\t// 10%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 9 - Additional 12.5%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% = 42.5%\n\t\telse if(a_nDaysSinceLaunch \u003c= 275)\n\t\t{\n\t\t\tnScalar = 3333333333333;\t// 30%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(246);\n\t\t\tnScalar = 7999999999999;\t// 12.5%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 10 - Additional 15%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% = 57.5%\n\t\telse if(a_nDaysSinceLaunch \u003c= 304)\n\t\t{\n\t\t\tnScalar = 2352941176472;\t// 42.5%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(275);\n\t\t\tnScalar = 6666666666666;\t// 15%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(29));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 11 - Additional 17.5%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% = 75%\n\t\telse if(a_nDaysSinceLaunch \u003c= 334)\n\t\t{\n\t\t\tnScalar = 1739130434782;\t// 57.5%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(304);\n\t\t\tnScalar = 5714285714290;\t// 17.5%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(30));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\t//Month 12 - Additional 25%\n\t\t// 0.25% + 0.5% + .75% + 1.5% + 3% + 6% + 8% + 10% + 12.5% + 15% + 17.5% + 25% = 100%\n\t\telse if(a_nDaysSinceLaunch \u003c 364)\n\t\t{\n\t\t\tnScalar = 1333333333333;\t// 75%\n\t\t\tnPreviousMonthPenalty = nScaledAmount.div(nScalar);\n\t\t\ta_nDaysSinceLaunch = a_nDaysSinceLaunch.sub(334);\n\t\t\tnScalar = 4000000000000;\t// 25%\n\t\t\tnScaledAmount = nScaledAmount.mul(a_nDaysSinceLaunch).div(nScalar.mul(30));\n\t\t\treturn nScaledAmount.add(nPreviousMonthPenalty);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn a_nAmount;\n\t\t}\n\t}\n\n\t/// @dev Returns claim amount with deduction based on weeks since contract launch.\n\t/// @param a_nAmount Amount of claim from UTXO\n\t/// @return Amount after any late penalties\n\tfunction GetLateClaimAmount(uint256 a_nAmount) internal view returns (uint256)\n\t{\n\t\tuint256 nDaysSinceLaunch = DaysSinceLaunch();\n\n\t\treturn a_nAmount.sub(GetMonthlyLatePenalty(a_nAmount, nDaysSinceLaunch));\n\t}\n\n  /// @dev Calculates speed bonus for claiming early\n  /// @param a_nAmount Amount of claim from UTXO\n  /// @return Speed bonus amount\n  function GetSpeedBonus(uint256 a_nAmount) internal view returns (uint256)\n\t{\n\t\tuint256 nDaysSinceLaunch = DaysSinceLaunch();\n\n\t\t//We give a two week buffer after contract launch before penalties\n\t\tif(nDaysSinceLaunch \u003c m_nClaimPhaseBufferDays)\n\t\t{\n\t\t\tnDaysSinceLaunch = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnDaysSinceLaunch = nDaysSinceLaunch.sub(m_nClaimPhaseBufferDays);\n\t\t}\n\n    uint256 nMaxDays = 350;\n    a_nAmount = a_nAmount.div(5);\n    return a_nAmount.mul(nMaxDays.sub(nDaysSinceLaunch)).div(nMaxDays);\n  }\n\n\t/// @dev Gets the redeem amount with the blockchain ratio applied.\n\t/// @param a_nAmount Amount of UTXO in satoshis\n\t/// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @return Amount with blockchain ratio applied\n\tfunction GetRedeemRatio(uint256 a_nAmount, BlockchainType a_nWhichChain) internal view returns (uint256)\n\t{\n\t\tif(a_nWhichChain != BlockchainType.Bitcoin)\n\t\t{\n\t\t\tuint8 nWhichChain = uint8(a_nWhichChain);\n\t\t\t--nWhichChain;\n\n\t\t\t//Many zeros to avoid rounding errors\n\t\t\tuint256 nScalar = 100000000000000000;\n\n\t\t\tuint256 nRatio = nScalar.div(m_blockchainRatios[nWhichChain]);\n\n\t\t\ta_nAmount = a_nAmount.mul(1000000000000).div(nRatio);\n\t\t}\n\n\t\treturn a_nAmount;\n\t}\n\n  /// @dev Gets the redeem amount and bonuses based on time since contract launch\n  /// @param a_nAmount Amount of UTXO in satoshis\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @return Claim amount, bonuses and penalty\n  function GetRedeemAmount(uint256 a_nAmount, BlockchainType a_nWhichChain) public view returns (uint256, uint256, uint256)\n\t{\n    a_nAmount = GetRedeemRatio(a_nAmount, a_nWhichChain);\n\n    uint256 nAmount = GetLateClaimAmount(a_nAmount);\n    uint256 nBonus = GetSpeedBonus(a_nAmount);\n\n    return (nAmount, nBonus, a_nAmount.sub(nAmount));\n  }\n\n\t/// @dev Verify claim ownership from signed message\n\t/// @param a_nAmount Amount of UTXO claim\n\t/// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\n\t/// @param a_addressClaiming Ethereum address within signed message\n\t/// @param a_pubKeyX First half of uncompressed ECDSA public key from signed message\n\t/// @param a_pubKeyY Second half of uncompressed ECDSA public key from signed message\n  /// @param a_nAddressType Whether BTC/LTC is Legacy or Segwit address\n\t/// @param a_v v parameter of ECDSA signature\n\t/// @param a_r r parameter of ECDSA signature\n\t/// @param a_s s parameter of ECDSA signature\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  function ValidateOwnership(\n    uint256 a_nAmount,\n    bytes32[] memory a_hMerkleTreeBranches,\n    address a_addressClaiming,\n    bytes32 a_pubKeyX,\n    bytes32 a_pubKeyY,\n    AddressType a_nAddressType,\n    uint8 a_v,\n    bytes32 a_r,\n    bytes32 a_s,\n    BlockchainType a_nWhichChain\n  ) internal\n\t{\n    //Calculate the UTXO Merkle leaf hash for the correct chain\n    bytes32 hMerkleLeafHash;\n    if(a_nWhichChain != BlockchainType.Ethereum)  //All Bitcoin chains and Litecoin have the same raw address format\n    {\n      hMerkleLeafHash = keccak256(abi.encodePacked(PublicKeyToBitcoinAddress(a_pubKeyX, a_pubKeyY, a_nAddressType), a_nAmount));\n    }\n    else //Otherwise ETH\n    {\n      hMerkleLeafHash = keccak256(abi.encodePacked(PublicKeyToEthereumAddress(a_pubKeyX, a_pubKeyY), a_nAmount));\n    }\n\n    //Require that the UTXO can be redeemed\n    require(CanClaimUTXOHash(hMerkleLeafHash, a_hMerkleTreeBranches, a_nWhichChain), \"UTXO Cannot be redeemed.\");\n\n    //Verify the ECDSA parameters match the signed message\n    require(\n      ECDSAVerify(\n        a_addressClaiming,\n        a_pubKeyX,\n        a_pubKeyY,\n        a_v,\n        a_r,\n        a_s,\n        a_nWhichChain\n      ),\n\t\t\t\"ECDSA verification failed.\"\n    );\n\n    //Save the UTXO as redeemed in the global map\n    m_claimedUTXOsMap[uint8(a_nWhichChain)][hMerkleLeafHash] = true;\n  }\n\n  /// @dev Claim tokens from a UTXO at snapshot block\n  /// granting CER tokens proportional to amount of UTXO.\n  /// BCH, BSV, ETH \u0026 LTC chains get proportional BTC ratio awards.\n  /// @param a_nAmount Amount of UTXO\n  /// @param a_hMerkleTreeBranches Merkle tree branches from leaf to root\n  /// @param a_addressClaiming The Ethereum address for the claimed CER tokens to be sent to\n  /// @param a_publicKeyX X parameter of uncompressed ECDSA public key from UTXO\n  /// @param a_publicKeyY Y parameter of uncompressed ECDSA public key from UTXO\n  /// @param a_nAddressType Whether BTC/LTC is Legacy or Segwit address and if it was compressed\n  /// @param a_v v parameter of ECDSA signature\n  /// @param a_r r parameter of ECDSA signature\n  /// @param a_s s parameter of ECDSA signature\n  /// @param a_nWhichChain Which blockchain is claiming, 0=BTC, 1=BCH, 2=BSV, 3=ETH, 4=LTC\n  /// @param a_referrer Optional address of referrer. Address(0) for no referral\n  /// @return The number of tokens redeemed, if successful\n  function Claim(\n    uint256 a_nAmount,\n    bytes32[] memory a_hMerkleTreeBranches,\n    address a_addressClaiming,\n    bytes32 a_publicKeyX,\n    bytes32 a_publicKeyY,\n    AddressType a_nAddressType,\n    uint8 a_v,\n    bytes32 a_r,\n    bytes32 a_s,\n    BlockchainType a_nWhichChain,\n    address a_referrer\n  ) public returns (uint256)\n\t{\n    //No claims after the first 50 weeks of contract launch\n    require(IsClaimablePhase(), \"Claim is outside of claims period.\");\n\n    require(uint8(a_nWhichChain) \u003e= 0 \u0026\u0026 uint8(a_nWhichChain) \u003c= 4, \"Incorrect blockchain value.\");\n\n    require(a_v \u003c= 30 \u0026\u0026 a_v \u003e= 27, \"V parameter is invalid.\");\n\n    ValidateOwnership(\n      a_nAmount,\n      a_hMerkleTreeBranches,\n      a_addressClaiming,\n      a_publicKeyX,\n      a_publicKeyY,\n      a_nAddressType,\n      a_v,\n      a_r,\n      a_s,\n      a_nWhichChain\n    );\n\n    UpdateDailyData();\n\n    m_nTotalRedeemed = m_nTotalRedeemed.add(GetRedeemRatio(a_nAmount, a_nWhichChain));\n\n    (uint256 nTokensRedeemed, uint256 nBonuses, uint256 nPenalties) = GetRedeemAmount(a_nAmount, a_nWhichChain);\n\n\t\t//Transfer coins from contracts wallet to claim wallet\n    _transfer(address(this), a_addressClaiming, nTokensRedeemed);\n\n    //Mint speed bonus to claiming address\n    _mint(a_addressClaiming, nBonuses);\n\t\t//Speed bonus matched for genesis address\n    _mint(m_genesis, nBonuses);\n\n    m_nRedeemedCount = m_nRedeemedCount.add(1);\n\n    if(a_referrer != address(0))\n\t\t{\n\t\t\t//Grant 10% bonus token to the person being referred\n\t\t\t_mint(a_addressClaiming, nTokensRedeemed.div(10));\n\t\t\tnBonuses = nBonuses.add(nTokensRedeemed.div(10));\n\n      //Grant 20% bonus of tokens to referrer\n      _mint(a_referrer, nTokensRedeemed.div(5));\n\n\t\t\t//Match referral bonus for genesis address (20% for referral and 10% for claimer referral = 30%)\n      _mint(m_genesis, nTokensRedeemed.mul(1000000000000).div(3333333333333));\n    }\n\n    emit ClaimEvent(\n      a_nAmount,\n      nTokensRedeemed,\n      nBonuses,\n\t\t\tnPenalties,\n      a_referrer != address(0)\n    );\n\n    //Return the number of tokens redeemed\n    return nTokensRedeemed.add(nBonuses);\n  }\n\n  /// @dev Calculates stake payouts for a given stake\n  /// @param a_nStakeShares Number of shares to calculate payout for\n  /// @param a_tLockTime Starting timestamp of stake\n  /// @param a_tEndTime Ending timestamp of stake\n  /// @return payout amount\n  function CalculatePayout(\n    uint256 a_nStakeShares,\n    uint256 a_tLockTime,\n    uint256 a_tEndTime\n  ) public view returns (uint256)\n\t{\n\t\tif(m_nLastUpdatedDay == 0)\n\t\t\treturn 0;\n\n    uint256 nPayout = 0;\n\n\t\tuint256 tStartDay = TimestampToDaysSinceLaunch(a_tLockTime);\n\n    //Calculate what day stake was closed\n    uint256 tEndDay = TimestampToDaysSinceLaunch(a_tEndTime);\n\n    //Iterate through each day and sum up the payout\n    for(uint256 i = tStartDay; i \u003c tEndDay; i++)\n\t\t{\n      uint256 nDailyPayout = m_dailyDataMap[i].nPayoutAmount.mul(a_nStakeShares)\n        .div(m_dailyDataMap[i].nTotalStakeShares);\n\n      //Keep sum of payouts\n      nPayout = nPayout.add(nDailyPayout);\n    }\n\n    return nPayout;\n  }\n\n  /// @dev Updates current amount of stake to apply compounding interest\n\t/// @notice This applies all of your earned interest to future payout calculations\n  /// @param a_nStakeIndex index of stake to compound interest for\n  function CompoundInterest(\n\t\tuint256 a_nStakeIndex\n\t) external\n\t{\n\t\trequire(m_nLastUpdatedDay != 0, \"First update day has not finished.\");\n\n    //Get a reference to the stake to save gas from constant map lookups\n    StakeStruct storage rStake = m_staked[msg.sender][a_nStakeIndex];\n\n\t\trequire(block.timestamp \u003c rStake.tEndStakeCommitTime, \"Stake has already matured.\");\n\n\t\tUpdateDailyData();\n\n\t\tuint256 nInterestEarned = CalculatePayout(\n\t\t\trStake.nSharesStaked,\n\t\t  rStake.tLastCompoundedUpdateTime,\n\t\t\tblock.timestamp\n\t\t);\n\n\t\tif(nInterestEarned != 0)\n\t\t{\n\t\t\trStake.nCompoundedPayoutAccumulated = rStake.nCompoundedPayoutAccumulated.add(nInterestEarned);\n\t\t\trStake.nSharesStaked = rStake.nSharesStaked.add(nInterestEarned);\n\n\t\t\t//InterestRateMultiplier votes\n\t\t\tm_votingMultiplierMap[rStake.nVotedOnMultiplier] = m_votingMultiplierMap[rStake.nVotedOnMultiplier].add(nInterestEarned);\n\n\t\t\tm_nTotalStakeShares = m_nTotalStakeShares.add(nInterestEarned);\n\t\t\trStake.tLastCompoundedUpdateTime = block.timestamp;\n\n\t\t\temit CompoundInterestEvent(\n\t\t\t\tnInterestEarned\n\t\t\t);\n\t\t}\n  }\n\n  /// @dev Starts a stake\n  /// @param a_nAmount Amount of token to stake\n  /// @param a_nDays Number of days to stake\n\t/// @param a_nInterestMultiplierVote Pooled interest rate to vote for (1-10 =\u003e 5%-50% interest)\n  function StartStake(\n    uint256 a_nAmount,\n    uint256 a_nDays,\n\t\tuint8 a_nInterestMultiplierVote\n  ) external\n\t{\n\t\trequire(DaysSinceLaunch() \u003e= m_nClaimPhaseBufferDays, \"Staking doesn\u0027t begin until after the buffer window\");\n\n    //Verify account has enough tokens\n    require(balanceOf(msg.sender) \u003e= a_nAmount, \"Not enough funds for stake.\");\n\n    //Don\u0027t allow 0 amount stakes\n    require(a_nAmount \u003e 0, \"Stake amount must be greater than 0\");\n\n\t\trequire(a_nDays \u003e= 7, \"Stake is under the minimum time required.\");\n\n\t\trequire(a_nInterestMultiplierVote \u003e= 1 \u0026\u0026 a_nInterestMultiplierVote \u003c= 10, \"Interest multiplier range is 1-10.\");\n\n\t\t//Calculate Unlock time\n    uint256 tEndStakeCommitTime = block.timestamp.add(a_nDays.mul(1 days));\n\n    //Don\u0027t allow stakes over the maximum stake time\n    require(tEndStakeCommitTime \u003c= block.timestamp.add(m_nMaxStakingTime), \"Stake time exceeds maximum.\");\n\n    UpdateDailyData();\n\n\t\t//Calculate bonus interest for longer stake periods (20% bonus per year)\n\t\tuint256 nSharesModifier = 0;\n\n\t\t//Minimum stake time of 3 months to get amplifier bonus\n\t\tif(a_nDays \u003e= 90)\n\t\t{\n\t\t\t//We can\u0027t have a fractional modifier such as .5 so we need to use whole numbers and divide later\n\t\t\tnSharesModifier = a_nDays.mul(2000000).div(365);\n\t\t}\n\n    //20% bonus shares per year of committed stake time\n    uint256 nStakeShares = a_nAmount.add(a_nAmount.mul(nSharesModifier).div(10000000));\n\n    //Create and store the stake\n    m_staked[msg.sender].push(\n      StakeStruct(\n        a_nAmount, // nAmountStaked\n        nStakeShares, // nSharesStaked\n\t\t\t\t0,\t//Accumulated Payout from CompoundInterest\n        block.timestamp, // tLockTime\n        tEndStakeCommitTime, // tEndStakeCommitTime\n\t\t\t\tblock.timestamp, //tLastCompoundedUpdateTime\n        0, // tTimeRemovedFromGlobalPool\n\t\t\t\ta_nInterestMultiplierVote,\n\t\t\t\ttrue, // bIsInGlobalPool\n        false // bIsLatePenaltyAlreadyPooled\n      )\n    );\n\n    emit StartStakeEvent(\n      a_nAmount,\n      a_nDays\n    );\n\n\t\t//InterestRateMultiplier\n\t\tm_votingMultiplierMap[a_nInterestMultiplierVote] = m_votingMultiplierMap[a_nInterestMultiplierVote].add(nStakeShares);\n\n    //Globally track staked tokens\n    m_nTotalStakedTokens = m_nTotalStakedTokens.add(a_nAmount);\n\n    //Globally track staked shares\n    m_nTotalStakeShares = m_nTotalStakeShares.add(nStakeShares);\n\n    //Transfer staked tokens to contract wallet\n    _transfer(msg.sender, address(this), a_nAmount);\n  }\n\n  /// @dev Calculates penalty for unstaking late\n  /// @param a_tEndStakeCommitTime Timestamp stake matured\n  /// @param a_tTimeRemovedFromGlobalPool Timestamp stake was removed from global pool\n  /// @param a_nInterestEarned Interest earned from stake\n  /// @return penalty value\n  function CalculateLatePenalty(\n    uint256 a_tEndStakeCommitTime,\n    uint256 a_tTimeRemovedFromGlobalPool,\n    uint256 a_nInterestEarned\n  ) public pure returns (uint256)\n\t{\n    uint256 nPenalty = 0;\n\n\t\t//One week grace period\n    if(a_tTimeRemovedFromGlobalPool \u003e a_tEndStakeCommitTime.add(1 weeks))\n\t\t{\n      //Penalty is 1% per day after the 1 week grace period\n      uint256 nPenaltyPercent = DifferenceInDays(a_tEndStakeCommitTime.add(1 weeks), a_tTimeRemovedFromGlobalPool);\n\n\t\t\t//Cap max percent at 100\n\t\t\tif(nPenaltyPercent \u003e 100)\n\t\t\t{\n\t\t\t\tnPenaltyPercent = 100;\n\t\t\t}\n\n      //Calculate penalty\n\t\t\tnPenalty = a_nInterestEarned.mul(nPenaltyPercent).div(100);\n    }\n\n    return nPenalty;\n  }\n\n  /// @dev Calculates penalty for unstaking early\n\t/// @param a_tLockTime Starting timestamp of stake\n  /// @param a_nEndStakeCommitTime Timestamp the stake matures\n  /// @param a_nAmount Amount that was staked\n\t/// @param a_nInterestEarned Interest earned from stake\n  /// @return penalty value\n  function CalculateEarlyPenalty(\n\t\tuint256 a_tLockTime,\n\t\tuint256 a_nEndStakeCommitTime,\n    uint256 a_nAmount,\n\t\tuint256 a_nInterestEarned\n  ) public view returns (uint256)\n\t{\n    uint256 nPenalty = 0;\n\n    if(block.timestamp \u003c a_nEndStakeCommitTime)\n\t\t{\n\t\t\t//If they didn\u0027t stake for at least 1 full day we give them no interest\n\t\t\t//To prevent any abuse\n\t\t\tif(DifferenceInDays(a_tLockTime, block.timestamp) == 0)\n\t\t\t{\n\t\t\t\tnPenalty = a_nInterestEarned;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Base penalty is half of earned interest\n\t\t\t\tnPenalty = a_nInterestEarned.div(2);\n\t\t\t}\n\n\t\t\tuint256 nCommittedStakeDays = DifferenceInDays(a_tLockTime, a_nEndStakeCommitTime);\n\n\t\t\tif(nCommittedStakeDays \u003e= 90)\n\t\t\t{\n\t\t\t\t//Take another 10% per year of committed stake\n\t\t\t\tnPenalty = nPenalty.add(nPenalty.mul(nCommittedStakeDays).div(3650));\n\t\t\t}\n\n\t\t\t//5% yearly interest converted to daily interest multiplied by stake time\n\t\t\tuint256 nMinimumPenalty = a_nAmount.mul(nCommittedStakeDays).div(7300);\n\n\t\t\tif(nMinimumPenalty \u003e nPenalty)\n\t\t\t{\n\t\t\t\tnPenalty = nMinimumPenalty;\n\t\t\t}\n\t\t}\n\n    return nPenalty;\n  }\n\n  /// @dev Removes completed stake from global pool\n  /// @notice Removing finished stakes will increase the payout to other stakers.\n  /// @param a_nStakeIndex Index of stake to process\n\t/// @param a_address Address of the staker\n  function EndStakeForAFriend(\n    uint256 a_nStakeIndex,\n\t\taddress a_address\n  ) external\n\t{\n\t\t//Require that the stake index doesn\u0027t go out of bounds\n\t\trequire(m_staked[a_address].length \u003e a_nStakeIndex, \"Stake does not exist\");\n\n    //Require that the stake has been matured\n    require(block.timestamp \u003e m_staked[a_address][a_nStakeIndex].tEndStakeCommitTime, \"Stake must be matured.\");\n\n\t\tProcessStakeEnding(a_nStakeIndex, a_address, true);\n  }\n\n \t/// @dev Ends a stake, even if it is before it has matured.\n\t/// @notice If stake has matured behavior is the same as EndStakeSafely\n  /// @param a_nStakeIndex Index of stake to close\n  function EndStakeEarly(\n    uint256 a_nStakeIndex\n  ) external\n\t{\n\t\t//Require that the stake index doesn\u0027t go out of bounds\n\t\trequire(m_staked[msg.sender].length \u003e a_nStakeIndex, \"Stake does not exist\");\n\n    ProcessStakeEnding(a_nStakeIndex, msg.sender, false);\n  }\n\n  /// @dev Ends a stake safely. Will only execute if a stake is matured.\n  /// @param a_nStakeIndex Index of stake to close\n  function EndStakeSafely(\n    uint256 a_nStakeIndex\n  ) external\n\t{\n\t\t//Require that the stake index doesn\u0027t go out of bounds\n\t\trequire(m_staked[msg.sender].length \u003e a_nStakeIndex, \"Stake does not exist\");\n\n\t\t//Require that stake is matured\n\t\trequire(block.timestamp \u003e m_staked[msg.sender][a_nStakeIndex].tEndStakeCommitTime, \"Stake must be matured.\");\n\n    ProcessStakeEnding(a_nStakeIndex, msg.sender, false);\n  }\n\n\tfunction ProcessStakeEnding(\n    uint256 a_nStakeIndex,\n\t\taddress a_address,\n\t\tbool a_bWasForAFriend\n  ) internal\n\t{\n\t\tUpdateDailyData();\n\n    //Get a reference to the stake to save gas from constant map lookups\n    StakeStruct storage rStake = m_staked[a_address][a_nStakeIndex];\n\n    uint256 tEndTime = block.timestamp \u003e rStake.tEndStakeCommitTime ?\n\t\t\trStake.tEndStakeCommitTime : block.timestamp;\n\n\t\t//Calculate Payout\n\t\tuint256 nTotalPayout = CalculatePayout(\n\t\t\trStake.nSharesStaked,\n\t\t\trStake.tLastCompoundedUpdateTime,\n\t\t\ttEndTime\n\t\t);\n\n\t\t//Add any accumulated interest payout from user calling CompoundInterest\n\t\tnTotalPayout = nTotalPayout.add(rStake.nCompoundedPayoutAccumulated);\n\n\t\t//Add back the original amount staked\n\t\tnTotalPayout = nTotalPayout.add(rStake.nAmountStaked);\n\n\t\t//Is stake still in the global pool?\n\t\tif(rStake.bIsInGlobalPool)\n\t\t{\n\t\t\t//Update global staked token tracking\n\t\t\tm_nTotalStakedTokens = m_nTotalStakedTokens.sub(rStake.nAmountStaked);\n\n\t\t\t//Update global stake shares tracking\n\t\t\tm_nTotalStakeShares = m_nTotalStakeShares.sub(rStake.nSharesStaked);\n\n\t\t\t//InterestRateMultiplier\n\t\t\tm_votingMultiplierMap[rStake.nVotedOnMultiplier] = m_votingMultiplierMap[rStake.nVotedOnMultiplier].sub(rStake.nSharesStaked);\n\n\t\t\t//Set time removed\n\t\t\trStake.tTimeRemovedFromGlobalPool = block.timestamp;\n\n\t\t\t//Set flag that it is no longer in the global pool\n\t\t\trStake.bIsInGlobalPool = false;\n\n\t\t\tif(a_bWasForAFriend)\n\t\t\t{\n\t\t\t\temit EndStakeForAFriendEvent(\n\t\t\t\t\trStake.nSharesStaked,\n\t\t\t\t\trStake.tEndStakeCommitTime\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//Calculate penalties if any\n\t\tuint256 nPenalty = 0;\n\t\tif(!a_bWasForAFriend)\t//Can\u0027t have an early penalty if it was called by EndStakeForAFriend\n \t\t{\n\t\t\tnPenalty = CalculateEarlyPenalty(\n\t\t\t\trStake.tLockTime,\n\t\t\t\trStake.tEndStakeCommitTime,\n\t\t\t\trStake.nAmountStaked,\n\t\t\t\tnTotalPayout.sub(rStake.nAmountStaked)\n\t\t\t);\n\t\t}\n\n\t\t//Only calculate late penalty if there wasn\u0027t an early penalty\n\t\tif(nPenalty == 0)\n\t\t{\n\t\t\tnPenalty = CalculateLatePenalty(\n\t\t\t\trStake.tEndStakeCommitTime,\n\t\t\t\trStake.tTimeRemovedFromGlobalPool,\n\t\t\t\tnTotalPayout.sub(rStake.nAmountStaked)\n\t\t\t);\n\t\t}\n\n\t\t//Don\u0027t payout penalty amount that has already been paid out\n\t\tif(nPenalty != 0 \u0026\u0026 !rStake.bIsLatePenaltyAlreadyPooled)\n\t\t{\n\t\t\t//Split penalty between genesis and pool\n\t\t\tm_nEarlyAndLateUnstakePool = m_nEarlyAndLateUnstakePool.add(nPenalty.div(2));\n\t\t\t_transfer(address(this), m_genesis, nPenalty.div(2));\n\t\t}\n\n\t\tif(a_bWasForAFriend)\n\t\t{\n\t\t\t//Set flag\n\t\t\trStake.bIsLatePenaltyAlreadyPooled =\ttrue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Apply penalty\n\t\t\tnTotalPayout = nTotalPayout.sub(nPenalty);\n\n\t\t\temit EndStakeEvent(\n\t\t\t\trStake.nAmountStaked,\n\t\t\t\tnTotalPayout,\n        block.timestamp \u003c rStake.tEndStakeCommitTime ?\n  \t\t\t\tDifferenceInDays(rStake.tLockTime, block.timestamp) :\n  \t\t\t\tDifferenceInDays(rStake.tLockTime, rStake.tTimeRemovedFromGlobalPool),\n\t\t\t\tnPenalty,\n\t\t\t\trStake.nSharesStaked,\n\t\t\t\tDifferenceInDays(rStake.tLockTime, rStake.tEndStakeCommitTime)\n\t\t\t);\n\n\t\t\t//Payout staked coins from contract\n\t\t\t_transfer(address(this), a_address, nTotalPayout);\n\n\t\t\t//Remove stake\n\t\t\tRemoveStake(a_address, a_nStakeIndex);\n\t\t}\n\t}\n\n  /// @dev Remove stake from array\n  /// @param a_address address of staker\n  /// @param a_nStakeIndex index of the stake to delete\n  function RemoveStake(\n    address a_address,\n    uint256 a_nStakeIndex\n  ) internal\n\t{\n    uint256 nEndingIndex = m_staked[a_address].length.sub(1);\n\n    //Only copy if we aren\u0027t removing the last index\n    if(nEndingIndex != a_nStakeIndex)\n    {\n      //Copy last stake in array over stake we are removing\n      m_staked[a_address][a_nStakeIndex] = m_staked[a_address][nEndingIndex];\n    }\n\n    //Lower array length by 1\n    m_staked[a_address].length = nEndingIndex;\n  }\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://eips.ethereum.org/EIPS/eip-20\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn\u0027t required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return A uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n     * @dev Transfer token to a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Transfer token for a specified addresses\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Approve an address to spend another addresses\u0027 tokens.\n     * @param owner The address that owns the tokens.\n     * @param spender The address that will spend the tokens.\n     * @param value The number of tokens that can be spent.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        _allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender\u0027s allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.2;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"MerkleProof.sol":{"content":"pragma solidity \u003e=0.4.25 \u003c0.6.0;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * @title MerkleProof\n * @dev Merkle proof verification based on\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\n */\nlibrary MerkleProof {\n    /**\n     * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\n     * and each pair of pre-images are sorted.\n     * @param proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\n     * @param root Merkle root\n     * @param leaf Leaf of Merkle tree\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i \u003c proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash \u003c proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"},"Migrations.sol":{"content":"pragma solidity \u003e=0.4.25 \u003c0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.2;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"mul: c / a != b\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"div: b must be \u003e 0\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"sub: b must be \u003c= a\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"add: c must be \u003e= a\");\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"mod: b == 0\");\n        return a % b;\n    }\n}\n"}}