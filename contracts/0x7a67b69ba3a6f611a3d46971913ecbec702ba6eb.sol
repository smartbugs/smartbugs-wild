{"FairPlay.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\nimport \"./SafeMathLib.sol\";\r\n\r\nimport \"./FairPlayOptions.sol\";\r\n\r\ncontract FairPlay {\r\n    \r\n    mapping (address =\u003e bool) private admins;\r\n    mapping (address =\u003e uint) public balance;\r\n    \r\n    event Deposit(address walletAddress, uint amount, uint balance);\r\n    event Withdraw(address walletAddress, uint amount, uint balance);\r\n    event Error(string message);\r\n    \r\n    function deposit() public payable {\r\n        balance[msg.sender] = balance[msg.sender].add(msg.value);\r\n        emit Deposit(msg.sender, msg.value, balance[msg.sender]);\r\n    }\r\n    \r\n    function withdraw(uint _amount) public {\r\n        require(_amount \u003c= balance[msg.sender],\"Insufficient funds\");\r\n        balance[msg.sender] = balance[msg.sender].sub(_amount);\r\n        msg.sender.transfer(_amount);\r\n        emit Withdraw(msg.sender, _amount, balance[msg.sender]);\r\n    }\r\n    \r\n    using SafeMathLib for uint256;\r\n\r\n    event BetEventCreated(uint id);\r\n    event BetPlaced(uint betEventId, uint betId, address user, uint optionId, uint amount);\r\n    event BetClaimed(uint betId, address user, uint winnings);\r\n    event WinningOptionAdded(uint betEventId, uint optionId, string result);\r\n\r\n    enum BetEventStatus {ACTIVE, CANCELED}\r\n    enum BetStatus {PENDING, CLAIMED}\r\n    \r\n    struct BetEvent {\r\n        string title;\r\n        string category;\r\n        string subcategory;\r\n        uint endDate;\r\n        BetEventStatus status;\r\n        address creator;\r\n        uint winningOption;\r\n        uint balance;\r\n        string result;\r\n        uint expirationDate;\r\n    }\r\n    \r\n    struct Bet {\r\n        uint betEventId;\r\n        uint optionId;\r\n        uint amount;\r\n        uint date;\r\n        address creator;\r\n        BetStatus status;\r\n    }\r\n\r\n    uint[] public betEvents;\r\n    mapping(address =\u003e uint[]) public userBets;\r\n    \r\n    uint betEventCounter;\r\n    uint betCounter;\r\n\r\n    mapping(uint =\u003e BetEvent) public betEventMap;\r\n    mapping(uint =\u003e Bet) public betMap;\r\n    \r\n    mapping(uint =\u003e mapping(uint =\u003e uint)) public betEventOptionBalance;\r\n    \r\n    mapping(uint =\u003e uint[]) public betEventOptions;\r\n    mapping(uint =\u003e uint[]) public betEventBets;\r\n    \r\n    mapping(uint =\u003e uint) public betEventMinBet;\r\n    mapping(uint =\u003e uint) public betEventCommission;\r\n    \r\n    FairPlayOptions public options;\r\n    \r\n    modifier isAdmin(address _addr) {\r\n        require(admins[_addr]);\r\n        _;\r\n    }\r\n    \r\n    function() external payable {}\r\n    \r\n    constructor() public {\r\n        options = FairPlayOptions(0x404b47F5eD0c090044873BEbE7Ea53170AA2cb1C);\r\n        admins[msg.sender] = true;\r\n    }\r\n\r\n    function getBetEvents() public view returns(uint[] memory) {return betEvents;}\r\n    function getUserBets() public view returns(uint[] memory) { return userBets[msg.sender]; }\r\n    function getBetEventOptions(uint id) public view returns(uint[] memory) { return betEventOptions[id];}\r\n    function getBetEventBets(uint id) public view returns(uint[] memory) { return betEventBets[id];}\r\n\r\n    function getOptions() public view returns(uint[] memory) {return options.getOptions();}\r\n    \r\n    function getOption(uint _id) public view returns(string memory) {return options.getOption(_id);}\r\n\r\n    function createBetEvent(\r\n        string memory title, \r\n        string memory category, \r\n        string memory subcategory, \r\n        uint endDate, \r\n        uint[] memory possibleOptions,\r\n        uint expirationDate,\r\n        uint minBet,\r\n        uint commission) isAdmin(msg.sender) public {\r\n        \r\n        uint id = betEventCounter;\r\n        betEventCounter = betEventCounter.add(1);\r\n        \r\n        BetEvent memory betEvent;\r\n        \r\n        betEvent.title = title;\r\n        betEvent.category = category;\r\n        betEvent.subcategory = subcategory;\r\n        betEvent.endDate = endDate;\r\n        betEvent.status = BetEventStatus.ACTIVE;\r\n        betEvent.creator = msg.sender;\r\n        betEvent.expirationDate = expirationDate;\r\n        \r\n        betEventOptions[id] = possibleOptions;\r\n        betEventMinBet[id] = minBet;\r\n        betEventCommission[id] = commission;\r\n        \r\n        betEventMap[id] = betEvent;\r\n        betEvents.push(id);\r\n        \r\n        emit BetEventCreated(id);\r\n    }\r\n\r\n    function createBet(\r\n        uint betEventId, \r\n        uint optionId, \r\n        uint amount) public {\r\n        \r\n        require(betEventMap[betEventId].endDate \u003e= now, \"Bet event has ended\");\r\n        require(balance[msg.sender] \u003e= amount, \"Balance too low\");\r\n        require(amount \u003e= betEventMinBet[betEventId], \"Min bet amount not reached\");\r\n        require(betEventMap[betEventId].winningOption == 0, \"Bet event has ended\");\r\n        require(betEventMap[betEventId].status != BetEventStatus.CANCELED, \"Bet event is canceled\");\r\n        \r\n        balance[msg.sender] = balance[msg.sender].sub(amount);\r\n        \r\n        uint id = betCounter;\r\n        betCounter = betCounter.add(1);\r\n        \r\n        Bet memory bet = Bet(betEventId, optionId, amount, now, msg.sender, BetStatus.PENDING);\r\n        betEventOptionBalance[betEventId][optionId] = betEventOptionBalance[betEventId][optionId].add(amount);\r\n        betEventMap[betEventId].balance = betEventMap[betEventId].balance.add(amount);\r\n        betMap[id] = bet;\r\n        betEventBets[betEventId].push(id);\r\n        userBets[msg.sender].push(id);\r\n        \r\n        emit BetPlaced(betEventId, id, msg.sender, optionId, amount);\r\n    }\r\n    \r\n    \r\n    function setWinningOption(uint betEventId, uint optionId, string memory result) isAdmin(msg.sender) public {\r\n        require(betEventMap[betEventId].winningOption == 0, \"Winning Option already set\");\r\n        require(betEventMap[betEventId].status != BetEventStatus.CANCELED, \"Bet event is canceled\");\r\n        \r\n        betEventMap[betEventId].winningOption = optionId;\r\n        betEventMap[betEventId].result = result;\r\n        uint winningOptionSum = betEventOptionBalance[betEventId][betEventMap[betEventId].winningOption];\r\n\r\n        if(winningOptionSum == 0) {\r\n            betEventMap[betEventId].status = BetEventStatus.CANCELED;\r\n            removeBetEventFromList(betEventId);\r\n            return;\r\n        }\r\n        \r\n        uint lostOptionsSum = betEventMap[betEventId].balance.sub(winningOptionSum);\r\n        uint a = lostOptionsSum.mul(betEventCommission[betEventId]); \r\n        uint commission = a.div(100);\r\n        \r\n        betEventMap[betEventId].balance = betEventMap[betEventId].balance.sub(commission);\r\n        balance[betEventMap[betEventId].creator] = balance[betEventMap[betEventId].creator].add(commission);\r\n        \r\n        removeBetEventFromList(betEventId);\r\n        \r\n        emit WinningOptionAdded(betEventId, optionId, result);\r\n    }\r\n    \r\n    function setOptions(address _addr) public isAdmin(msg.sender) {\r\n        options = FairPlayOptions(_addr);\r\n    }\r\n    \r\n    \r\n    function claim(uint betId) public {\r\n        \r\n        Bet memory bet = betMap[betId];\r\n        \r\n        if((betEventMap[bet.betEventId].status == BetEventStatus.CANCELED) || (betEventMap[bet.betEventId].expirationDate \u003c= now)) {\r\n            refund(betId);\r\n            return;\r\n        }\r\n        \r\n        require(bet.creator == msg.sender, \"Cannot claim another player\u0027s bet\");\r\n        require(bet.optionId == betEventMap[bet.betEventId].winningOption, \"Cannot claim a lost bet\");\r\n        require(bet.status != BetStatus.CLAIMED, \"Bet is already claimed\");\r\n\r\n        betMap[betId].status = BetStatus.CLAIMED;\r\n\r\n        uint winningOptionSum = betEventOptionBalance[bet.betEventId][betEventMap[bet.betEventId].winningOption];\r\n        uint a = bet.amount.mul(betEventMap[bet.betEventId].balance);\r\n        uint totalPlayerWinnings = a.div(winningOptionSum);\r\n\r\n        balance[msg.sender] = balance[msg.sender].add(totalPlayerWinnings);\r\n        \r\n        emit BetClaimed(betId, msg.sender, totalPlayerWinnings);\r\n    }\r\n    \r\n    function cancelBetEvent(uint _id) isAdmin(msg.sender) public {\r\n        betEventMap[_id].status = BetEventStatus.CANCELED;\r\n        removeBetEventFromList(_id);\r\n    }\r\n    \r\n    function refund(uint betId) private {\r\n        Bet memory bet = betMap[betId];\r\n        \r\n        require(bet.creator == msg.sender, \"Cannot claim another player\u0027s bet\");\r\n        require(betEventMap[bet.betEventId].status == BetEventStatus.CANCELED, \"Bet event is not canceled\");\r\n        require(bet.status != BetStatus.CLAIMED, \"Bet is already claimed\");\r\n\r\n        betMap[betId].status = BetStatus.CLAIMED;\r\n\r\n        balance[msg.sender] = balance[msg.sender].add(bet.amount);\r\n        \r\n        emit BetClaimed(betId, msg.sender, bet.amount);\r\n    }\r\n    \r\n    function removeBetEventFromList(uint _id) private {\r\n        uint index; bool found;\r\n        for(uint i = 0; i \u003c betEvents.length; i++) {\r\n            if (betEvents[i] == _id) {\r\n                found = true;\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if(found) {\r\n            if(betEvents.length \u003e 1) {\r\n                betEvents[index] = betEvents[betEvents.length - 1];\r\n                delete betEvents[betEvents.length - 1];\r\n            }\r\n            betEvents.length--;\r\n        }\r\n    }\r\n    \r\n    function estimateEarnings(uint betId) public view returns(uint) {\r\n        Bet memory bet = betMap[betId];\r\n        uint betEventId = bet.betEventId;\r\n        \r\n        uint winningOptionSum = betEventOptionBalance[betEventId][bet.optionId];\r\n        \r\n        uint aa = bet.amount.mul(betEventMap[betEventId].balance);\r\n        return aa.div(winningOptionSum);\r\n    }\r\n    \r\n    function gaddress() public view returns(address) { return address(this); }\r\n\r\n    function setExpirationDate(uint id, uint _date) public isAdmin(msg.sender) {\r\n        betEventMap[id].expirationDate = _date;\r\n    }\r\n    \r\n    function setEndDate(uint id, uint _date) public isAdmin(msg.sender) {\r\n        betEventMap[id].endDate = _date;\r\n    }\r\n    \r\n    function getTime()public view returns(uint) {\r\n        return now;\r\n    }\r\n    \r\n}"},"FairPlayOptions.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\nimport \"./SafeMathLib.sol\";\r\n\r\ncontract FairPlayOptions {\r\n    \r\n    using SafeMathLib for uint256;\r\n    \r\n    mapping (address =\u003e bool) private admins;\r\n    \r\n    event OptionCreated(uint id, string text);\r\n    \r\n    struct Option {\r\n        string text;\r\n    }\r\n    \r\n    uint[] public options;\r\n    \r\n    uint optionCounter;\r\n    \r\n    mapping(uint =\u003e Option) public optionMap;\r\n    \r\n    modifier isAdmin(address _addr) {\r\n        require(admins[_addr]);\r\n        _;\r\n    }\r\n    \r\n    constructor() public {\r\n        optionCounter = 1;\r\n        admins[msg.sender] = true;\r\n    }\r\n    \r\n    function getOptions() public view returns(uint[] memory) {return options;}\r\n    \r\n    function getOption(uint _id) public view returns(string memory) {return optionMap[_id].text;}\r\n    \r\n    function createOption(string memory text) isAdmin(msg.sender) public {\r\n        uint id = optionCounter;\r\n        optionCounter = optionCounter.add(1);\r\n        Option memory opt = Option(text);\r\n        optionMap[id] = opt;\r\n        options.push(id);\r\n        emit OptionCreated(id, text);\r\n    }\r\n    \r\n    function gaddress() public view returns(address) { return address(this); }\r\n}"},"SafeMathLib.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\nlibrary SafeMathLib {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b \u003c= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c \u003e= a);\r\n        return c;\r\n    }\r\n}"}}