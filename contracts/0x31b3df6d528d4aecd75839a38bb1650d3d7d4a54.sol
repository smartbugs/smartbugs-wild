{"AuctionityChainId_V1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityLibrary_V1.sol\";\n\n/// @title Auctionity chainId library\ncontract AuctionityChainId_V1 is AuctionityLibrary_V1 {\n    /// @notice getter of ethereum network id\n    /// @return ethereum network id\n    function getEthereumChainId_V1() public view returns (uint8) {\n        return ethereumChainId;\n    }\n\n    /// @notice getter of auctionity network id\n    /// @return auctionity network id\n    function getAuctionityChainId_V1() public view returns (uint8) {\n        return auctionityChainId;\n    }\n\n    /// @notice setter of ethereum network id\n    /// @param _ethereumChainId uint8 : ethereum network id\n    function setEthereumChainId_V1(uint8 _ethereumChainId) public {\n        require(\n            delegatedSendIsContractOwner_V1(),\n            \"setEthereumChainId Contract owner\"\n        );\n        ethereumChainId = _ethereumChainId;\n    }\n\n    /// @notice setter of auctionity network id\n    /// @param _auctionityChainId uint8 : auctionity network id\n    function setAuctionityChainId_V1(uint8 _auctionityChainId) public {\n        require(\n            delegatedSendIsContractOwner_V1(),\n            \"setAuctionityChainId Contract owner\"\n        );\n        auctionityChainId = _auctionityChainId;\n    }\n\n}\n"},"AuctionityDeposit_V1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityStorage1.sol\";\n\nimport \"./SafeMath.sol\";\nimport \"./AuctionityLibrary_V1.sol\";\nimport \"./AuctionityLibraryDecodeRawTx_V1.sol\";\n\nimport \"./AuctionityChainId_V1.sol\";\nimport \"./AuctionityOracable_V1.sol\";\nimport \"./AuctionityPausable_V1.sol\";\n\ncontract AuctionityDeposit_V1 is AuctionityStorage1, AuctionityLibrary_V1, AuctionityChainId_V1 {\n    using SafeMath for uint256;\n\n    struct InfoFromCreateAuction {\n        bytes32 tokenHash;\n        address tokenContractAddress;\n        address auctionSeller;\n        uint8 rewardPercent;\n        uint256 tokenId;\n    }\n\n    struct InfoFromBidding {\n        address auctionContractAddress;\n        address signer;\n        uint256 amount;\n    }\n\n    // For previous compatibility\n    event LogSentEthToWinner(address auction, address user, uint256 amount);\n    event LogSentRewardsDepotEth(address[] user, uint256[] amount);\n    event LogDeposed(address user, uint256 amount);\n    event LogWithdrawalVoucherSubmitted(address user, uint256 amount, bytes32 withdrawalVoucherHash);\n    event LogAuctionEndVoucherSubmitted(\n        bytes32 tokenHash,\n        address tokenContractAddress,\n        uint256 tokenId,\n        address indexed seller,\n        address indexed winner,\n        uint256 amount,\n        bytes32 auctionEndVoucherHash\n    );\n\n    // events\n    event LogWithdrawalVoucherSubmitted_V1(\n        address user,\n        uint256 amount,\n        bytes32 withdrawalVoucherHash\n    );\n\n    event LogAddDepot_V1(\n        address user,\n        address tokenContractAddress,\n        uint256 tokenId,\n        uint256 amount,\n        uint256 totalAmount\n    );\n\n    event LogAuctionEndVoucherSubmitted_V1(\n        bytes32 tokenHash,\n        address tokenContractAddress,\n        uint256 tokenId,\n        address indexed seller,\n        address indexed winner,\n        uint256 amount,\n        bytes32 auctionEndVoucher_V1Hash\n    );\n    event LogSentEthToSeller_V1(address auction, address user, uint256 amount);\n    event LogSentRewardsDepotEth_V1(address[] user, uint256[] amount);\n\n    /// @notice get amount of user\u0027s deposit\n    /// @dev Comptability with previous \u0027AuctionityDeposit_V1\u0027\n    /// @param _user address\n    /// @return _amount uint256\n    function getDepotEth(address _user) public view returns (uint256 _amount) {\n        return getBalanceEth_V1(_user);\n    }\n\n    /// @notice fallback payable function , with revert if is deactivated\n    function() external payable {\n        return receiveDepotEth_V1();\n    }\n\n    /// @notice deposit Eth\n    /// @dev Comptability with previous \u0027AuctionityDeposit\u0027\n    function depositEth() public payable {\n        receiveDepotEth_V1();\n    }\n\n    /// @notice receive depot Eth\n    function receiveDepotEth_V1()  public payable {\n        require(!delegatedSendGetPaused_V1(), \"CONTRACT_PAUSED\");\n\n        address _user = msg.sender;\n        uint256 _amount = uint256(msg.value);\n\n        _addDepotEth_V1(_user, _amount);\n\n        // For previous compatibility\n        emit LogDeposed(_user, _amount);\n\n        emit LogAddDepot_V1(\n            _user,\n            address(0),\n            uint256(0),\n            _amount,\n            getBalanceEth_V1(_user)\n        );\n\n    }\n\n    /// @notice internal add depot Eth\n    /// @param _user address from depot\n    /// @param _amount uint256\n    /// @return _success\n    function _addDepotEth_V1(address _user, uint256 _amount)\n        internal\n        returns (bool)\n    {\n        return _addDepot_V1(_user, address(0), uint256(0), _amount);\n    }\n\n    /// @notice internal add depot (compatibility ERC1155)\n    /// @param _user address from depot\n    /// @param _tokenContractAddress address of NFT smart contract\n    /// @param _tokenId uint256 of ERC1155\n    /// @param _amount uint256 of ERC1155\n    /// @return _success\n    function _addDepot_V1(\n        address _user,\n        address _tokenContractAddress,\n        uint256 _tokenId,\n        uint256 _amount\n    ) internal returns (bool) {\n        require(_amount \u003e 0, \"Amount must be greater than 0\");\n\n        tokens[_tokenContractAddress][_tokenId][_user] = tokens[_tokenContractAddress][_tokenId][_user].add(\n            _amount\n        );\n\n        return true;\n    }\n\n    /// @notice internal subtraction depot eth\n    /// @param _user address\n    /// @param _amount uint256\n    /// @return _success\n    function _subDepotEth_V1(address _user, uint256 _amount)\n        internal\n        returns (bool)\n    {\n        return _subDepot_V1(_user, address(0), uint256(0), _amount);\n    }\n\n    /// @notice internal substration depot (compatibility ERC1155)\n    /// @param _user address from depot\n    /// @param _tokenContractAddress address of NFT smart contract\n    /// @param _tokenId uint256 of ERC1155\n    /// @param _amount uint256 of ERC1155\n    /// @return _success\n    function _subDepot_V1(\n        address _user,\n        address _tokenContractAddress,\n        uint256 _tokenId,\n        uint256 _amount\n    ) internal returns (bool) {\n        require(\n            tokens[_tokenContractAddress][_tokenId][_user] \u003e= _amount,\n            \"Amount too low\"\n        );\n\n        tokens[_tokenContractAddress][_tokenId][_user] = tokens[_tokenContractAddress][_tokenId][_user].sub(\n            _amount\n        );\n\n        return true;\n    }\n\n    /// @notice get balance Eth for a user\n    /// @param _user address\n    /// @return _balanceOf uint256\n    function getBalanceEth_V1(address _user) public view returns (uint256 _balanceOf) {\n        return _getBalance_V1(_user, address(0), uint256(0));\n    }\n\n    /// @notice get balance for a user (compatibility ERC1155)\n    /// @param _user address from depot\n    /// @param _tokenContractAddress address of NFT smart contract\n    /// @param _tokenId uint256 of ERC1155\n    /// @return _balanceOf uint256\n    function _getBalance_V1(\n        address _user,\n        address _tokenContractAddress,\n        uint256 _tokenId\n    ) internal view returns (uint256 _balanceOf) {\n        return tokens[_tokenContractAddress][_tokenId][_user];\n    }\n\n    /// @notice withdrawal voucher\n    /// @param _withdrawalVoucherData bytes , RSV FROM Oracle, user , amount and key (anti replay)\n    /// @param _signedRawTxWithdrawal bytes\n    function withdrawalVoucher_V1(\n        bytes memory _withdrawalVoucherData,\n        bytes memory _signedRawTxWithdrawal\n    ) public {\n        require(!delegatedSendGetPaused_V1(), \"CONTRACT_PAUSED\");\n\n        bytes32 _withdrawalVoucherHash = keccak256(_signedRawTxWithdrawal);\n\n        require(\n            withdrawalVoucherSubmitted[_withdrawalVoucherHash] != true,\n            \"Withdrawal voucher is already submited\"\n        );\n\n        address _withdrawalSigner;\n        uint _withdrawalAmount;\n\n        (_withdrawalSigner, _withdrawalAmount) = AuctionityLibraryDecodeRawTx_V1.decodeRawTxGetWithdrawalInfo_V1(\n            _signedRawTxWithdrawal,\n            getAuctionityChainId_V1()\n        );\n\n        require(\n            _withdrawalAmount != uint256(0),\n            \"Withdrawal voucher amount must be greater than zero\"\n        );\n        require(\n            _withdrawalSigner != address(0),\n            \"Withdrawal voucher invalid signature of oracle\"\n        );\n\n        // if depot is smaller than amount\n        require(\n            getBalanceEth_V1(_withdrawalSigner) \u003e= _withdrawalAmount,\n            \"Withdrawal voucher depot amount is too low\"\n        );\n\n        require(\n            withdrawalVoucherOracleSignatureVerification_V1(\n                _withdrawalVoucherData,\n                _withdrawalSigner,\n                _withdrawalAmount,\n                _withdrawalVoucherHash\n            ),\n            \"Withdrawal voucher invalid signature of oracle\"\n        );\n\n        // send amount\n        require(\n            address(uint160(_withdrawalSigner)).send(_withdrawalAmount),\n            \"Withdrawal voucher transfer failed\"\n        );\n\n        _subDepotEth_V1(_withdrawalSigner, _withdrawalAmount);\n\n        withdrawalVoucherList.push(_withdrawalVoucherHash);\n        withdrawalVoucherSubmitted[_withdrawalVoucherHash] = true;\n\n        // For previous compatibility\n        emit LogWithdrawalVoucherSubmitted(\n            _withdrawalSigner,\n            _withdrawalAmount,\n            _withdrawalVoucherHash\n        );\n\n        emit LogWithdrawalVoucherSubmitted_V1(\n            _withdrawalSigner,\n            _withdrawalAmount,\n            _withdrawalVoucherHash\n        );\n    }\n\n    /// @notice internal withdrawal voucher oracle signature verification\n    /// @param _withdrawalVoucherData bytes\n    /// @param _withdrawalSigner address\n    /// @param _withdrawalAmount uint256\n    /// @param _withdrawalVoucherHash bytes32 : hash of _signedRawTxWithdrawal\n    /// @return _success\n    function withdrawalVoucherOracleSignatureVerification_V1(\n        bytes memory _withdrawalVoucherData,\n        address _withdrawalSigner,\n        uint256 _withdrawalAmount,\n        bytes32 _withdrawalVoucherHash\n    ) internal returns (bool) {\n        /// @dev if oracle is the signer of this withdrawal voucher\n        return delegatedSendGetOracle_V1(\n\n        ) == AuctionityLibraryDecodeRawTx_V1.ecrecoverSigner_V1(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    keccak256(\n                        abi.encodePacked(\n                            address(this),\n                            _withdrawalSigner,\n                            _withdrawalAmount,\n                            _withdrawalVoucherHash\n                        )\n                    )\n                )\n            ),\n                _withdrawalVoucherData,\n            0\n        );\n    }\n\n    /// @notice auctionEndVoucher_V1\n    /// @param _auctionEndVoucherData is a  concatenate of : biddingHashProof, rsv ECDSA signature of oracle validation AEV and transfer token\n    /// @param _signedRawTxCreateAuction bytes of signed transaction of create transaction on auction smart contract\n    /// @param _signedRawTxBidding bytes of signed transaction of bidding transaction on auction smart contract\n    /// @param _send bytes of send external and internal (rewards) amount\n    function auctionEndVoucher_V1(\n        bytes memory _auctionEndVoucherData,\n        bytes memory _signedRawTxCreateAuction,\n        bytes memory _signedRawTxBidding,\n        bytes memory _send\n    ) public {\n        require(!delegatedSendGetPaused_V1(), \"CONTRACT_PAUSED\");\n\n        bytes32 _auctionEndVoucherHash = keccak256(_signedRawTxCreateAuction);\n        require(\n            auctionEndVoucherSubmitted[_auctionEndVoucherHash] != true,\n            \"Auction end voucher already submited\"\n        );\n\n        InfoFromCreateAuction memory _infoFromCreateAuction = getInfoFromCreateAuction_V1(\n            _signedRawTxCreateAuction\n        );\n\n        address _auctionContractAddress;\n        address _winnerSigner;\n        uint256 _winnerAmount;\n\n        InfoFromBidding memory _infoFromBidding;\n\n        if (_signedRawTxBidding.length \u003e 1) {\n            _infoFromBidding = getInfoFromBidding_V1(\n                _signedRawTxBidding,\n                _infoFromCreateAuction.tokenHash\n            );\n\n            if (!verifyWinnerDepot_V1(_infoFromBidding)) {\n                return;\n            }\n        }\n\n        require(\n            auctionEndVoucherOracleSignatureVerification_V1(\n                _auctionEndVoucherData,\n                keccak256(_send),\n                _infoFromCreateAuction,\n                _infoFromBidding\n            ),\n            \"Auction end voucher invalid signature of oracle\"\n        );\n\n        require(\n            sendTransfer_V1(\n                _infoFromCreateAuction.tokenContractAddress,\n                _auctionEndVoucherData,\n                97\n            ),\n            \"Auction end voucher transfer failed\"\n        );\n\n        if (_signedRawTxBidding.length \u003e 1) {\n            if (!sendExchange_V1(\n                _send,\n                _infoFromCreateAuction,\n                _infoFromBidding\n            )) {\n                return;\n            }\n        }\n\n        auctionEndVoucherList.push(_auctionEndVoucherHash);\n        auctionEndVoucherSubmitted[_auctionEndVoucherHash] = true;\n\n        // For previous compatibility\n        emit LogAuctionEndVoucherSubmitted(\n            _infoFromCreateAuction.tokenHash,\n            _infoFromCreateAuction.tokenContractAddress,\n            _infoFromCreateAuction.tokenId,\n            _infoFromCreateAuction.auctionSeller,\n            _infoFromBidding.signer,\n            _infoFromBidding.amount,\n            _auctionEndVoucherHash\n        );\n\n        emit LogAuctionEndVoucherSubmitted_V1(\n            _infoFromCreateAuction.tokenHash,\n            _infoFromCreateAuction.tokenContractAddress,\n            _infoFromCreateAuction.tokenId,\n            _infoFromCreateAuction.auctionSeller,\n            _infoFromBidding.signer,\n            _infoFromBidding.amount,\n            _auctionEndVoucherHash\n        );\n    }\n\n    /// @notice internal get information from create auction signed transaction\n    /// @param _signedRawTxCreateAuction bytes\n    /// @return InfoFromCreateAuction structure\n    function getInfoFromCreateAuction_V1(bytes memory _signedRawTxCreateAuction)\n        internal\n        view\n        returns (InfoFromCreateAuction memory _infoFromCreateAuction)\n    {\n        (_infoFromCreateAuction.tokenHash, , _infoFromCreateAuction.auctionSeller, _infoFromCreateAuction.tokenContractAddress, _infoFromCreateAuction.tokenId, _infoFromCreateAuction.rewardPercent) = AuctionityLibraryDecodeRawTx_V1.decodeRawTxGetCreateAuctionInfo_V1(\n            _signedRawTxCreateAuction,\n            getAuctionityChainId_V1()\n        );\n    }\n\n    /// @notice internal get information from bidding signed transaction\n    /// @param _signedRawTxBidding bytes\n    /// @param _hashSignedRawTxTokenTransfer bytes32 tokenhash :  hash of _signedRawTxTokenTransfer (include into create auction transaction)\n    /// @return InfoFromBidding structure\n    function getInfoFromBidding_V1(\n        bytes memory _signedRawTxBidding,\n        bytes32 _hashSignedRawTxTokenTransfer\n    ) internal returns (InfoFromBidding memory _infoFromBidding) {\n        bytes32 _hashRawTxTokenTransferFromBid;\n\n        (_hashRawTxTokenTransferFromBid, _infoFromBidding.auctionContractAddress, _infoFromBidding.amount, _infoFromBidding.signer) = AuctionityLibraryDecodeRawTx_V1.decodeRawTxGetBiddingInfo_V1(\n            _signedRawTxBidding,\n            getAuctionityChainId_V1()\n        );\n\n        require(\n            _hashRawTxTokenTransferFromBid == _hashSignedRawTxTokenTransfer,\n            \"Auction end voucher hashRawTxTokenTransfer is invalid\"\n        );\n\n        require(\n            _infoFromBidding.amount != uint256(0),\n            \"Auction end voucher bidding amount must be greater than zero\"\n        );\n\n        return _infoFromBidding;\n\n    }\n\n    /// @notice intenral verify winner have enouth depot with bidding information\n    /// @param _infoFromBidding InfoFromBidding structure\n    /// @return _success\n    function verifyWinnerDepot_V1(InfoFromBidding memory _infoFromBidding)\n        internal\n        returns (bool)\n    {\n        // depot is greatuer or eqal than amount\n        require(\n            getBalanceEth_V1(\n                _infoFromBidding.signer\n            ) \u003e= _infoFromBidding.amount,\n            \"Auction end voucher depot amount is too low\"\n        );\n\n        return true;\n    }\n\n    /// @notice internal send external and internal deposit amount\n    /// @param _send bytes of send external and internal (rewards) amount\n    /// @param _infoFromCreateAuction InfoFromCreateAuction structure\n    /// @param _infoFromBidding InfoFromBidding structure\n    /// @return _success\n    function sendExchange_V1(\n        bytes memory _send,\n        InfoFromCreateAuction memory _infoFromCreateAuction,\n        InfoFromBidding memory _infoFromBidding\n    ) internal returns (bool) {\n        require(\n            _subDepotEth_V1(_infoFromBidding.signer, _infoFromBidding.amount),\n            \"Auction end voucher depot amout is too low\"\n        );\n\n        uint offset;\n        address payable _sendAddress;\n        uint256 _sendAmount;\n        bytes12 _sendAmountGwei;\n        uint256 _sentAmount;\n\n        assembly {\n            _sendAddress := mload(add(_send, add(offset, 0x14)))\n            _sendAmount := mload(add(_send, add(add(offset, 20), 0x20)))\n        }\n\n        require(\n            _sendAddress == _infoFromCreateAuction.auctionSeller,\n            \"Auction end voucher sender address is invalider\"\n        );\n\n        _sentAmount += _sendAmount;\n        offset += 52;\n\n        // send amount to seller\n        if (!_sendAddress.send(_sendAmount)) {\n            revert(\"Failed to send funds\");\n        }\n\n        // emit old event for previous compatibility\n        emit LogSentEthToWinner(_infoFromBidding.auctionContractAddress,\n            _sendAddress,\n            _sendAmount);\n\n        emit LogSentEthToSeller_V1(\n            _infoFromBidding.auctionContractAddress,\n            _sendAddress,\n            _sendAmount\n        );\n\n        // if community rewards is informed\n        if (_infoFromCreateAuction.rewardPercent \u003e 0) {\n\n            // get number of rewards\n            bytes2 _numberOfSendDepositBytes2;\n            assembly {\n                _numberOfSendDepositBytes2 := mload(\n                    add(_send, add(offset, 0x20))\n                )\n            }\n\n            offset += 2;\n\n\n            // initiate _rewardsAddress and _rewardsAmount\n            address[] memory _rewardsAddress = new address[](\n                uint16(_numberOfSendDepositBytes2)\n            );\n            uint256[] memory _rewardsAmount = new uint256[](\n                uint16(_numberOfSendDepositBytes2)\n            );\n\n\n            for (uint16 i = 0; i \u003c uint16(_numberOfSendDepositBytes2); i++) {\n\n                // get address and amount in gwei for reward\n                assembly {\n                    _sendAddress := mload(add(_send, add(offset, 0x14)))\n                    _sendAmountGwei := mload(\n                        add(_send, add(add(offset, 20), 0x20))\n                    )\n                }\n\n                // multiply amount in gwei to wei\n                _sendAmount = uint96(_sendAmountGwei) * 1000000000;\n                // sum of all reward amount for verification below\n                _sentAmount += _sendAmount;\n                offset += 32;\n\n                // add internal deposit reward amount for reward address\n                if (!_addDepotEth_V1(_sendAddress, _sendAmount)) {\n                    revert(\"Can\u0027t add deposit\");\n                }\n\n                _rewardsAddress[i] = _sendAddress;\n                _rewardsAmount[i] = uint256(_sendAmount);\n            }\n\n            // For previous compatibility\n            emit LogSentRewardsDepotEth(_rewardsAddress, _rewardsAmount);\n\n            emit LogSentRewardsDepotEth_V1(_rewardsAddress, _rewardsAmount);\n        }\n\n        // verification if sum of sended amount is equal than bidding amount\n        if (uint256(_infoFromBidding.amount) != _sentAmount) {\n            revert(\"Bidding amount is not equal to sent amount\");\n        }\n\n        return true;\n    }\n\n    /// @notice internal get transfert data hash from AEV data (part of transfert token to winner)\n    /// @param _auctionEndVoucherData bytes\n    /// @return _transferDataHash bytes32\n    function getTransferDataHash_V1(bytes memory _auctionEndVoucherData)\n        internal\n        pure\n        returns (bytes32 _transferDataHash)\n    {\n        bytes memory _transferData = new bytes(_auctionEndVoucherData.length - 97);\n\n        for (uint i = 0; i \u003c (_auctionEndVoucherData.length - 97); i++) {\n            _transferData[i] = _auctionEndVoucherData[i + 97];\n        }\n        return keccak256(_transferData);\n\n    }\n\n    /// @notice internal auctionEndVoucher oracle signature verification\n    /// @param _auctionEndVoucherData bytes\n    /// @param _sendDataHash bytes32\n    /// @param _infoFromCreateAuction InfoFromCreateAuction structure\n    /// @param _infoFromBidding InfoFromBidding structure\n    /// @return _success\n    function auctionEndVoucherOracleSignatureVerification_V1(\n        bytes memory _auctionEndVoucherData,\n        bytes32 _sendDataHash,\n        InfoFromCreateAuction memory _infoFromCreateAuction,\n        InfoFromBidding memory _infoFromBidding\n    ) internal returns (bool) {\n        bytes32 _biddingHashProof;\n        assembly {\n            _biddingHashProof := mload(add(_auctionEndVoucherData, add(0, 0x20)))\n        }\n\n        // get hash of transfert data\n        bytes32 _transferDataHash = getTransferDataHash_V1(_auctionEndVoucherData);\n\n        // if oracle is the signer of this auction end voucher\n        return delegatedSendGetOracle_V1() == AuctionityLibraryDecodeRawTx_V1.ecrecoverSigner_V1(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    keccak256(\n                        abi.encodePacked(\n                            address(this),\n                            _infoFromCreateAuction.tokenContractAddress,\n                            _infoFromCreateAuction.tokenId,\n                            _infoFromCreateAuction.auctionSeller,\n                            _infoFromBidding.signer,\n                            _infoFromBidding.amount,\n                            _biddingHashProof,\n                            _infoFromCreateAuction.rewardPercent,\n                            _transferDataHash,\n                            _sendDataHash\n                        )\n                    )\n                )\n            ),\n            _auctionEndVoucherData,\n            32\n        );\n\n    }\n\n    /// @notice send token(s) to winner\n    /// @param _tokenContractAddress address\n    /// @param _auctionEndVoucherData bytes\n    /// @param _offset of begin transfert data\n    function sendTransfer_V1(\n        address _tokenContractAddress,\n        bytes memory _auctionEndVoucherData,\n        uint _offset\n    ) internal returns (bool) {\n        if (!isContract_V1(_tokenContractAddress)) {\n            return false;\n        }\n\n        uint8 _numberOfTransfer = uint8(_auctionEndVoucherData[_offset]);\n\n        _offset += 1;\n\n        bool _success;\n        for (uint8 i = 0; i \u003c _numberOfTransfer; i++) {\n            (_offset, _success) = decodeTransferCall_V1(\n                _tokenContractAddress,\n                _auctionEndVoucherData,\n                _offset\n            );\n\n            if (!_success) {\n                return false;\n            }\n        }\n\n        return true;\n\n    }\n\n    /// @notice decode transfert and call token smart contract\n    /// @param _tokenContractAddress address\n    /// @param _auctionEndVoucherData bytes\n    /// @param _offset of begin transfert data\n    /// @return new offset, and _success\n    function decodeTransferCall_V1(\n        address _tokenContractAddress,\n        bytes memory _auctionEndVoucherData,\n        uint _offset\n    ) internal returns (uint, bool) {\n        bytes memory _sizeOfCallBytes;\n        bytes memory _callData;\n\n        uint _sizeOfCallData;\n\n        if (_auctionEndVoucherData[_offset] == 0xb8) {\n            _sizeOfCallBytes = new bytes(1);\n            _sizeOfCallBytes[0] = bytes1(_auctionEndVoucherData[_offset + 1]);\n\n            _offset += 2;\n        }\n        if (_auctionEndVoucherData[_offset] == 0xb9) {\n            _sizeOfCallBytes = new bytes(2);\n            _sizeOfCallBytes[0] = bytes1(_auctionEndVoucherData[_offset + 1]);\n            _sizeOfCallBytes[1] = bytes1(_auctionEndVoucherData[_offset + 2]);\n            _offset += 3;\n        }\n        \n        _sizeOfCallData = bytesToUint_V1(_sizeOfCallBytes);\n\n        _callData = new bytes(_sizeOfCallData);\n        for (uint j = 0; j \u003c _sizeOfCallData; j++) {\n            _callData[j] = _auctionEndVoucherData[(j + _offset)];\n        }\n\n        _offset += _sizeOfCallData;\n\n        return (_offset, sendCallData_V1(\n            _tokenContractAddress,\n            _sizeOfCallData,\n            _callData\n        ));\n\n    }\n\n    /// @notice call token smart contract with call data\n    /// @param _tokenContractAddress address\n    /// @param _sizeOfCallData uint256 , size of call data\n    /// @param _callData bytes\n    /// @return _success\n    function sendCallData_V1(\n        address _tokenContractAddress,\n        uint256 _sizeOfCallData,\n        bytes memory _callData\n    ) internal returns (bool) {\n        bool _success;\n        bytes4 sig;\n\n        assembly {\n            let _ptr := mload(0x40)\n            sig := mload(add(_callData, 0x20))\n\n            mstore(_ptr, sig) //Place signature at begining of empty storage\n            for {\n                let i := 0x04\n            } lt(i, _sizeOfCallData) {\n                i := add(i, 0x20)\n            } {\n                mstore(add(_ptr, i), mload(add(_callData, add(0x20, i)))) //Add each param\n            }\n\n            // call external smart contract with 10K de gas, return _success\n            _success := call(\n                //This is the critical change (Pop the top stack value)\n                sub(gas, 10000), // gas\n                _tokenContractAddress, //To addr\n                0, //No value\n                _ptr, //Inputs are stored at location _ptr\n                _sizeOfCallData, //Inputs _size\n                _ptr, //Store output over input (saves space)\n                0x20\n            ) //Outputs are 32 bytes long\n\n        }\n\n        return _success;\n    }\n\n}\n"},"AuctionityLibraryDecodeRawTx_V1.sol":{"content":"pragma solidity ^0.5.4;\n\n/**\n * @title AuctionityLibraryDecodeRawTx\n * @dev Library for auctionity\n */\n\nimport \"./RLPReader.sol\";\nimport \"./RLPWriter.sol\";\n\nlibrary AuctionityLibraryDecodeRawTx_V1 {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    function decodeRawTxGetBiddingInfo_V1(\n        bytes memory _signedRawTxBidding,\n        uint8 _chainId\n    )\n        internal\n        pure\n        returns (\n        bytes32 _hashRawTxTokenTransfer,\n        address _auctionContractAddress,\n        uint256 _bidAmount,\n        address _signerBid\n    )\n    {\n        bytes memory _auctionBidlData;\n        RLPReader.RLPItem[] memory _signedRawTxBiddingRLPItem = _signedRawTxBidding.toRlpItem(\n\n        ).toList();\n\n        _auctionContractAddress = _signedRawTxBiddingRLPItem[3].toAddress();\n        _auctionBidlData = _signedRawTxBiddingRLPItem[5].toBytes();\n\n        bytes4 _selector;\n        assembly {\n            _selector := mload(add(_auctionBidlData, 0x20))\n        }\n\n        _signerBid = getSignerFromSignedRawTxRLPItem_V1(\n            _signedRawTxBiddingRLPItem,\n            _chainId\n        );\n\n        // 0x1d03ae68 : bytes4(keccak256(\u0027bid(uint256,address,bytes32)\u0027))\n        if (_selector == 0x1d03ae68) {\n            assembly {\n                _bidAmount := mload(add(_auctionBidlData, add(4, 0x20)))\n                _hashRawTxTokenTransfer := mload(\n                    add(_auctionBidlData, add(68, 0x20))\n                )\n            }\n\n        }\n\n        // 0x8470df06 : bytes4(keccak256(\u0027bid(uint256,address,address,bytes32)\u0027))\n        if (_selector == 0x8470df06) {\n            assembly {\n                _bidAmount := mload(add(_auctionBidlData, add(4, 0x20)))\n                _hashRawTxTokenTransfer := mload(\n                    add(_auctionBidlData, add(100, 0x20))\n                )\n            }\n\n        }\n\n    }\n\n    function decodeRawTxGetCreateAuctionInfo_V1(\n        bytes memory _signedRawTxCreateAuction,\n        uint8 _chainId\n    )\n        internal\n        pure\n        returns (\n        bytes32 _tokenHash,\n        address _auctionFactoryContractAddress,\n        address _signerCreate,\n        address _tokenContractAddress,\n        uint256 _tokenId,\n        uint8 _rewardPercent\n    )\n    {\n        bytes memory _createAuctionlData;\n        RLPReader.RLPItem[] memory _signedRawTxCreateAuctionRLPItem = _signedRawTxCreateAuction.toRlpItem(\n\n        ).toList();\n\n        _auctionFactoryContractAddress = _signedRawTxCreateAuctionRLPItem[3].toAddress(\n\n        );\n        _createAuctionlData = _signedRawTxCreateAuctionRLPItem[5].toBytes();\n\n        _signerCreate = getSignerFromSignedRawTxRLPItem_V1(\n            _signedRawTxCreateAuctionRLPItem,\n            _chainId\n        );\n\n        bytes memory _signedRawTxTokenTransfer;\n\n        (_signedRawTxTokenTransfer, _tokenContractAddress, _tokenId, _rewardPercent) = decodeRawTxGetCreateAuctionInfoData_V1(\n            _createAuctionlData\n        );\n\n        _tokenHash = keccak256(_signedRawTxTokenTransfer);\n\n    }\n\n    function decodeRawTxGetCreateAuctionInfoData_V1(\n        bytes memory _createAuctionlData\n    )\n        internal\n        pure\n        returns (\n        bytes memory _signedRawTxTokenTransfer,\n        address _tokenContractAddress,\n        uint256 _tokenId,\n        uint8 _rewardPercent\n    )\n    {\n        bytes4 _selector;\n        assembly {\n            _selector := mload(add(_createAuctionlData, 0x20))\n        }\n\n        uint _positionOfSignedRawTxTokenTransfer;\n        uint _sizeOfSignedRawTxTokenTransfer;\n        uint i;\n\n        // 0xffd6d828 : bytes4(keccak256(\u0027create(bytes,address,uint256,bytes,address,uint8)\u0027))\n        if (_selector == 0xffd6d828) {\n            assembly {\n                _positionOfSignedRawTxTokenTransfer := mload(\n                    add(_createAuctionlData, add(4, 0x20))\n                )\n                _sizeOfSignedRawTxTokenTransfer := mload(\n                    add(\n                        _createAuctionlData,\n                        add(add(_positionOfSignedRawTxTokenTransfer, 4), 0x20)\n                    )\n                )\n\n                // tokenContractAddress : get 2th param\n                _tokenContractAddress := mload(\n                    add(_createAuctionlData, add(add(mul(1, 32), 4), 0x20))\n                )\n                // tockenId : get 3th param\n                _tokenId := mload(\n                    add(_createAuctionlData, add(add(mul(2, 32), 4), 0x20))\n                )\n                // rewardPercent : get 6th param\n                _rewardPercent := mload(\n                    add(_createAuctionlData, add(add(mul(5, 32), 4), 0x20))\n                )\n\n            }\n\n            _signedRawTxTokenTransfer = new bytes(\n                _sizeOfSignedRawTxTokenTransfer\n            );\n\n            for (i = 0; i \u003c _sizeOfSignedRawTxTokenTransfer; i++) {\n                _signedRawTxTokenTransfer[i] = _createAuctionlData[i + _positionOfSignedRawTxTokenTransfer + 4 + 32];\n            }\n\n        }\n\n        // 0xffd6d828 : bytes4(keccak256(\u0027create(bytes,address,uint256,bytes,address,uint8[])\u0027))\n        if (_selector == 0xfe7ccebd) {\n            uint _positionOfRewards;\n            assembly {\n                _positionOfSignedRawTxTokenTransfer := mload(\n                    add(_createAuctionlData, add(4, 0x20))\n                )\n                _sizeOfSignedRawTxTokenTransfer := mload(\n                    add(\n                        _createAuctionlData,\n                        add(add(_positionOfSignedRawTxTokenTransfer, 4), 0x20)\n                    )\n                )\n\n                // tokenContractAddress : get 2th param\n                _tokenContractAddress := mload(\n                    add(_createAuctionlData, add(add(mul(1, 32), 4), 0x20))\n                )\n                // tockenId : get 3th param\n                _tokenId := mload(\n                    add(_createAuctionlData, add(add(mul(2, 32), 4), 0x20))\n                )\n\n                // rewardPercent : get 6th param\n\n                _positionOfRewards := mload(\n                    add(_createAuctionlData, add(add(mul(5, 32), 4), 0x20))\n                )\n\n                // get 1th param\n                _rewardPercent := mload(\n                    add(\n                        _createAuctionlData,\n                        add(add(_positionOfRewards, 4), 0x40)\n                    )\n                )\n\n            }\n\n            _signedRawTxTokenTransfer = new bytes(\n                _sizeOfSignedRawTxTokenTransfer\n            );\n\n            for (i = 0; i \u003c _sizeOfSignedRawTxTokenTransfer; i++) {\n                _signedRawTxTokenTransfer[i] = _createAuctionlData[i + _positionOfSignedRawTxTokenTransfer + 4 + 32];\n            }\n\n        }\n\n    }\n\n    function decodeRawTxGetWithdrawalInfo_V1(\n        bytes memory _signedRawTxWithdrawal,\n        uint8 _chainId\n    )\n        internal\n        pure\n        returns (address withdrawalSigner, uint256 withdrawalAmount)\n    {\n        bytes4 _selector;\n        bytes memory _withdrawalData;\n        RLPReader.RLPItem[] memory _signedRawTxWithdrawalRLPItem = _signedRawTxWithdrawal.toRlpItem(\n\n        ).toList();\n\n        _withdrawalData = _signedRawTxWithdrawalRLPItem[5].toBytes();\n\n        assembly {\n            _selector := mload(add(_withdrawalData, 0x20))\n        }\n\n        withdrawalSigner = getSignerFromSignedRawTxRLPItem_V1(\n            _signedRawTxWithdrawalRLPItem,\n            _chainId\n        );\n\n        // 0x47960938 : bytes4(keccak256(\u0027withdrawalEth_V1(uint256)\u0027))\n        if (_selector == 0x47960938) {\n            assembly {\n                withdrawalAmount := mload(add(_withdrawalData, add(4, 0x20)))\n            }\n\n        }\n\n    }\n\n    function ecrecoverSigner_V1(\n        bytes32 _hashTx,\n        bytes memory _rsvTx,\n        uint offset\n    ) internal pure returns (address ecrecoverAddress) {\n        bytes32 r;\n        bytes32 s;\n        bytes1 v;\n\n        assembly {\n            r := mload(add(_rsvTx, add(offset, 0x20)))\n            s := mload(add(_rsvTx, add(offset, 0x40)))\n            v := mload(add(_rsvTx, add(offset, 0x60)))\n        }\n\n        ecrecoverAddress = ecrecover(_hashTx, uint8(v), r, s);\n    }\n\n    function getSignerFromSignedRawTxRLPItem_V1(\n        RLPReader.RLPItem[] memory _signedTxRLPItem,\n        uint8 _chainId\n    ) internal pure returns (address ecrecoverAddress) {\n        bytes memory _rawTx;\n        bytes memory _rsvTx;\n\n        (_rawTx, _rsvTx) = explodeSignedRawTxRLPItem(\n            _signedTxRLPItem,\n            _chainId\n        );\n        return ecrecoverSigner_V1(keccak256(_rawTx), _rsvTx, 0);\n    }\n\n    function explodeSignedRawTxRLPItem(\n        RLPReader.RLPItem[] memory _signedTxRLPItem,\n        uint8 _chainId\n    ) internal pure returns (bytes memory _rawTx, bytes memory _rsvTx) {\n        bytes[] memory _signedTxRLPItemRaw = new bytes[](9);\n\n        _signedTxRLPItemRaw[0] = RLPWriter.toRlp(_signedTxRLPItem[0].toBytes());\n        _signedTxRLPItemRaw[1] = RLPWriter.toRlp(_signedTxRLPItem[1].toBytes());\n        _signedTxRLPItemRaw[2] = RLPWriter.toRlp(_signedTxRLPItem[2].toBytes());\n        _signedTxRLPItemRaw[3] = RLPWriter.toRlp(_signedTxRLPItem[3].toBytes());\n        _signedTxRLPItemRaw[4] = RLPWriter.toRlp(_signedTxRLPItem[4].toBytes());\n        _signedTxRLPItemRaw[5] = RLPWriter.toRlp(_signedTxRLPItem[5].toBytes());\n\n        _signedTxRLPItemRaw[6] = RLPWriter.toRlp(_chainId);\n        _signedTxRLPItemRaw[7] = RLPWriter.toRlp(0);\n        _signedTxRLPItemRaw[8] = RLPWriter.toRlp(0);\n\n        _rawTx = RLPWriter.toRlp(_signedTxRLPItemRaw);\n\n        uint8 i;\n        _rsvTx = new bytes(65);\n\n        bytes32 tmp = bytes32(_signedTxRLPItem[7].toUint());\n        for (i = 0; i \u003c 32; i++) {\n            _rsvTx[i] = tmp[i];\n        }\n\n        tmp = bytes32(_signedTxRLPItem[8].toUint());\n\n        for (i = 0; i \u003c 32; i++) {\n            _rsvTx[i + 32] = tmp[i];\n        }\n\n        _rsvTx[64] = bytes1(\n            uint8(_signedTxRLPItem[6].toUint() - uint(_chainId * 2) - 8)\n        );\n\n    }\n\n}\n"},"AuctionityLibrary_V1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityStorage0.sol\";\n\n/// @title Auction library for delegate for some delegated function\ncontract AuctionityLibrary_V1 is AuctionityStorage0 {\n    /// @notice get delegated addrss from a selector\n    /// @param _selector byte4\n    /// @return _contractDelegate address\n    function getDelegate_V1(bytes4 _selector)\n        public\n        view\n        returns (address _contractDelegate)\n    {\n        return delegates[_selector];\n    }\n\n    /// @notice call delegated function\n    /// @param _calldata bytes : data sended to delegated contract\n    /// @param _contractFallback address: address of fallback if selector is not exist, address(0) if no fallback\n    /// @return uint return pointer and uint return size of callData return\n    function _callDelegated_V1(\n        bytes memory _calldata,\n        address _contractFallback\n    ) internal returns (uint returnPtr, uint returnSize) {\n        /// @dev get selector from _calldata\n        bytes4 _selector;\n        assembly {\n            _selector := mload(add(_calldata, 0x20))\n        }\n\n        /// @dev get address of delegated from selector\n        address _contractDelegate = getDelegate_V1(_selector);\n\n        /// @dev if _contractDelegate not found set _contractFallback into _contractFallback\n        if (_contractDelegate == address(0)) {\n            _contractDelegate = _contractFallback;\n        }\n\n        require(\n            _contractDelegate != address(0),\n            \"Auctionity function does not exist.\"\n        );\n\n        /// @dev delegate call and return result, or the eventual revert\n        assembly {\n            let result := delegatecall(\n                gas,\n                _contractDelegate,\n                add(_calldata, 0x20),\n                mload(_calldata),\n                0,\n                0\n            )\n            returnSize := returndatasize\n            returnPtr := mload(0x40)\n            returndatacopy(returnPtr, 0, returnSize)\n            if eq(result, 0) {\n                revert(returnPtr, returnSize)\n            }\n        }\n\n        /// @dev return returndatacopy\n        return (returnPtr, returnSize);\n\n    }\n\n    /// @notice delegate IsContractOwner_V1\n    /// @return  _isContractOwner\n    function delegatedSendIsContractOwner_V1()\n        public\n        returns (bool _isContractOwner)\n    {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"delegatedReceiveIsContractOwner_V1()\"))\n            ),\n            address(0)\n        );\n\n        assembly {\n            _isContractOwner := mload(returnPtr)\n        }\n\n        return _isContractOwner;\n    }\n\n    modifier delegatedSendIsOracle_V1() {\n        require(\n            msg.sender == delegatedSendGetOracle_V1(),\n            \"Sender must be oracle\"\n        );\n        _;\n    }\n\n    /// @notice delegate getOracle_V1\n    /// @return address _oracle\n    function delegatedSendGetOracle_V1() public returns (address _oracle) {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"delegatedReceiveGetOracle_V1()\"))\n            ),\n            address(0)\n        );\n\n        assembly {\n            _oracle := mload(returnPtr)\n        }\n        return _oracle;\n\n    }\n\n    /// @notice delegate getPaused_V1\n    /// @return bool _isPaused\n    function delegatedSendGetPaused_V1() public returns (bool _isPaused) {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"delegatedReceiveGetPaused_V1()\"))\n            ),\n            address(0)\n        );\n        assembly {\n            _isPaused := mload(returnPtr)\n        }\n        return _isPaused;\n\n    }\n\n    /// @notice delegate lockDeposit_V1\n    /// @param _tokenContractAddress address\n    /// @param _tokenId uint256\n    /// @param _amount uint256\n    /// @param _auctionId uint256\n    /// @param _refundUser address\n    /// @return bool _isPaused\n    function delegatedLockDeposit_V1(\n        address _tokenContractAddress,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _auctionId,\n        address _refundUser\n    ) public returns (bool _success) {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(\n                    keccak256(\n                        \"lockDeposit_V1(address,uint256,uint256,uint256,address)\"\n                    )\n                ),\n                _tokenContractAddress,\n                _tokenId,\n                _amount,\n                _auctionId,\n                _refundUser\n            ),\n            address(0)\n        );\n\n        assembly {\n            _success := mload(returnPtr)\n        }\n        return _success;\n\n    }\n\n    /// @notice verify if _contractAddress is a contract\n    /// @param _contractAddress address\n    /// @return _isContract\n    function isContract_V1(address _contractAddress)\n        internal\n        view\n        returns (bool _isContract)\n    {\n        uint _size;\n        assembly {\n            _size := extcodesize(_contractAddress)\n        }\n        return _size \u003e 0;\n    }\n\n    /// @notice cast a bytesmemory into a uint256\n    /// @param b bytes\n    /// @return uint256\n    function bytesToUint_V1(bytes memory b) internal pure returns (uint256) {\n        uint256 _number;\n        for (uint i = 0; i \u003c b.length; i++) {\n            _number = _number + uint8(b[i]) * (2 ** (8 * (b.length - (i + 1))));\n        }\n        return _number;\n    }\n}\n"},"AuctionityOracable_V1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityLibrary_V1.sol\";\n\n/// @title AuctionityOracable_V1\ncontract AuctionityOracable_V1 is AuctionityLibrary_V1 {\n    /// @notice event LogOracleTransfered_V1\n    event LogOracleTransfered_V1(\n        address indexed previousOracle,\n        address indexed newOracle\n    );\n\n    /// @notice delegate receive of getOracle\n    /// @return  _oracle address\n    function delegatedReceiveGetOracle_V1()\n        public\n        payable\n        returns (address _oracle)\n    {\n        return getOracle_V1();\n    }\n\n    /// @notice getter oracle address\n    /// @return  _oracle address\n    function getOracle_V1() public view returns (address _oracle) {\n        return oracle;\n    }\n\n    /// @notice verify if msg.sender is oracle\n    /// @return _isOracle bool\n    function isOracle_V1() public view returns (bool _isOracle) {\n        return msg.sender == oracle;\n    }\n\n    /**\n     * @return true if `_oracle` is the oracle of the contract.\n     */\n\n    /// @notice verify oracle address\n    /// @param _oracle address : address to compare\n    /// @return _isOracle bool\n    function verifyOracle_V1(address _oracle)\n        public\n        view\n        returns (bool _isOracle)\n    {\n        return _oracle == oracle;\n    }\n\n    /// @notice Allows the current oracle or owner to set a new oracle.\n    /// @param _newOracle The address to transfer oracleship to.\n    function transferOracle_V1(address _newOracle) public {\n        require(\n            isOracle_V1() || delegatedSendIsContractOwner_V1(),\n            \"Is not Oracle or Owner\"\n        );\n        _transferOracle_V1(_newOracle);\n    }\n\n    /// @notice Transfers control of the contract to a newOracle.\n    /// @param _newOracle The address to transfer oracleship to.\n    function _transferOracle_V1(address _newOracle) internal {\n        require(_newOracle != address(0), \"Oracle can\u0027t be 0x0\");\n        emit LogOracleTransfered_V1(oracle, _newOracle);\n        oracle = _newOracle;\n    }\n}\n"},"AuctionityPausable_V1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityLibrary_V1.sol\";\n\n/// @title Pausable\n/// @dev Base contract which allows children to implement an emergency stop mechanism.\n\ncontract AuctionityPausable_V1 is AuctionityLibrary_V1 {\n    event LogPaused_V1(bool paused);\n\n    /// @notice constructor, default is false, no incidence if called by proxy\n    constructor() public {\n        paused = false;\n    }\n\n    /// @notice delegate receive of get Paused\n    /// @return _isPaused bool\n    function delegatedReceiveGetPaused_V1()\n        public\n        payable\n        returns (bool _isPaused)\n    {\n        return getPaused_V1();\n    }\n\n    /// @notice verify if is paused\n    /// @return _isPaused bool\n    function getPaused_V1() public returns (bool _isPaused) {\n        if (delegatedSendIsContractOwner_V1() == true) {\n            return false;\n        }\n        return paused;\n    }\n\n    /// @dev Modifier to make a function callable only when the contract is not paused.\n    modifier whenNotPaused_V1() {\n        require(!delegatedSendGetPaused_V1(), \"Contrat is paused\");\n        _;\n    }\n\n    /// @dev Modifier to make a function callable only when the contract is paused.\n    modifier whenPaused_V1() {\n        require(delegatedSendGetPaused_V1(), \"Contrat is not paused\");\n        _;\n    }\n\n    /// @notice called by the owner to pause, triggers stopped state\n    /// @param _paused bool\n    function setPaused_V1(bool _paused) public {\n        require(delegatedSendIsContractOwner_V1(), \"Not Contract owner\");\n        paused = _paused;\n        emit LogPaused_V1(_paused);\n    }\n}\n"},"AuctionityStorage0.sol":{"content":"pragma solidity ^0.5.4;\n\ncontract AuctionityStorage0 {\n    // selector =\u003e delegate contract\n    mapping(bytes4 =\u003e address) internal delegates;\n\n    // If selector not found, fallback contract address\n    address public proxyFallbackContract;\n\n    address public contractOwner;\n    address public oracle;\n\n    bool public paused;\n\n    uint8 public ethereumChainId;\n    uint8 public auctionityChainId;\n}\n"},"AuctionityStorage1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityStorage0.sol\";\n\ncontract AuctionityStorage1 is AuctionityStorage0 {\n    // TokenContract =\u003e TokenIds =\u003e Users =\u003e amount\n    mapping(address =\u003e mapping(uint256 =\u003e mapping(address =\u003e uint256))) tokens;\n\n    bytes32[] public withdrawalVoucherList; // List of withdrawal voucher\n    mapping(bytes32 =\u003e bool) public withdrawalVoucherSubmitted; // is withdrawal voucher is already submitted\n\n    bytes32[] public auctionEndVoucherList; // List of auction end voucher\n    mapping(bytes32 =\u003e bool) public auctionEndVoucherSubmitted; // is auction end voucher is already submitted\n\n}\n"},"RLPReader.sol":{"content":"/*\n* @author Hamdi Allam hamdi.allam97@gmail.com\n* Please reach our for any questions/concerns\n*/\npragma solidity ^0.5.4;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item)\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        if (item.length == 0) return RLPItem(0, 0);\n\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @param item RLP encoded list in bytes\n    */\n    function toList(RLPItem memory item)\n        internal\n        pure\n        returns (RLPItem[] memory result)\n    {\n        require(isList(item));\n\n        uint items = numItems(item);\n        result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i \u003c items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n    }\n\n    /*\n    * Helpers\n    */\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 \u003c LIST_SHORT_START) return false;\n        return true;\n    }\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) internal pure returns (uint) {\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr \u003c endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) internal pure returns (uint len) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 \u003c STRING_SHORT_START) return 1;\n        else if (byte0 \u003c STRING_LONG_START) return byte0 - STRING_SHORT_START + 1;\n        else if (byte0 \u003c LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                len := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 \u003c LIST_LONG_START) {\n            return byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                len := add(dataLen, add(byteLen, 1))\n            }\n        }\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) internal pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 \u003c STRING_SHORT_START) return 0;\n        else if (byte0 \u003c STRING_LONG_START || (byte0 \u003e= LIST_SHORT_START \u0026\u0026 byte0 \u003c LIST_LONG_START)) return 1;\n        else if (byte0 \u003c LIST_SHORT_START) // being explicit\n        return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(\n            item.len == 1,\n            \"Invalid RLPItem. Booleans are encoded in 1 byte\"\n        );\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix according to RLP spec\n        require(\n            item.len == 21,\n            \"Invalid RLPItem. Addresses are encoded in 20 bytes\"\n        );\n\n        uint memPtr = item.memPtr + 1; // skip the length prefix\n        uint addr;\n        assembly {\n            addr := div(mload(memPtr), exp(256, 12)) // right shift 12 bytes. we want the most significant 20 bytes\n        }\n\n        return address(addr);\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset;\n        uint memPtr = item.memPtr + offset;\n\n        uint result;\n        assembly {\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) internal pure {\n        // copy as many word sizes as possible\n        for (; len \u003e= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"},"RLPWriter.sol":{"content":"pragma solidity ^0.5.4;\n\nlibrary RLPWriter {\n    function toRlp(bytes memory _value)\n        internal\n        pure\n        returns (bytes memory _bytes)\n    {\n        uint _valuePtr;\n        uint _rplPtr;\n        uint _valueLength = _value.length;\n\n        assembly {\n            _valuePtr := add(_value, 0x20)\n            _bytes := mload(0x40) // Free memory ptr\n            _rplPtr := add(_bytes, 0x20) // RLP first byte ptr\n        }\n\n        // [0x00, 0x7f]\n        if (_valueLength == 1 \u0026\u0026 _value[0] \u003c= 0x7f) {\n            assembly {\n                mstore(_bytes, 1) // Bytes size is 1\n                mstore(_rplPtr, mload(_valuePtr)) // Set value as-is\n                mstore(0x40, add(_rplPtr, 1)) // Update free ptr\n            }\n            return _bytes;\n        }\n\n        // [0x80, 0xb7]\n        if (_valueLength \u003c= 55) {\n            assembly {\n                mstore(_bytes, add(1, _valueLength)) // Bytes size\n                mstore8(_rplPtr, add(0x80, _valueLength)) // RLP small string size\n                mstore(0x40, add(add(_rplPtr, 1), _valueLength)) // Update free ptr\n            }\n\n            copy(_valuePtr, _rplPtr + 1, _valueLength);\n            return _bytes;\n        }\n\n        // [0xb8, 0xbf]\n        uint _lengthSize = uintMinimalSize(_valueLength);\n\n        assembly {\n            mstore(_bytes, add(add(1, _lengthSize), _valueLength)) // Bytes size\n            mstore8(_rplPtr, add(0xb7, _lengthSize)) // RLP long string \"size size\"\n            mstore(\n                add(_rplPtr, 1),\n                mul(_valueLength, exp(256, sub(32, _lengthSize)))\n            ) // Bitshift to store the length only _lengthSize bytes\n            mstore(0x40, add(add(add(_rplPtr, 1), _lengthSize), _valueLength)) // Update free ptr\n        }\n\n        copy(_valuePtr, _rplPtr + 1 + _lengthSize, _valueLength);\n        return _bytes;\n    }\n\n    function toRlp(uint _value) internal pure returns (bytes memory _bytes) {\n        uint _size = uintMinimalSize(_value);\n\n        bytes memory _valueBytes = new bytes(_size);\n\n        assembly {\n            mstore(\n                add(_valueBytes, 0x20),\n                mul(_value, exp(256, sub(32, _size)))\n            )\n        }\n\n        return toRlp(_valueBytes);\n    }\n\n    function toRlp(bytes[] memory _values)\n        internal\n        pure\n        returns (bytes memory _bytes)\n    {\n        uint _ptr;\n        uint _size;\n        uint i;\n\n        // compute data size\n        for (; i \u003c _values.length; ++i) _size += _values[i].length;\n\n        // create rlp header\n        assembly {\n            _bytes := mload(0x40)\n            _ptr := add(_bytes, 0x20)\n        }\n\n        if (_size \u003c= 55) {\n            assembly {\n                mstore8(_ptr, add(0xc0, _size))\n                _ptr := add(_ptr, 1)\n            }\n        } else {\n            uint _size2 = uintMinimalSize(_size);\n\n            assembly {\n                mstore8(_ptr, add(0xf7, _size2))\n                _ptr := add(_ptr, 1)\n                mstore(_ptr, mul(_size, exp(256, sub(32, _size2))))\n                _ptr := add(_ptr, _size2)\n            }\n        }\n\n        // copy data\n        for (i = 0; i \u003c _values.length; ++i) {\n            bytes memory _val = _values[i];\n            uint _valPtr;\n\n            assembly {\n                _valPtr := add(_val, 0x20)\n            }\n\n            copy(_valPtr, _ptr, _val.length);\n\n            _ptr += _val.length;\n        }\n\n        assembly {\n            mstore(0x40, _ptr)\n            mstore(_bytes, sub(sub(_ptr, _bytes), 0x20))\n        }\n    }\n\n    function uintMinimalSize(uint _value) internal pure returns (uint _size) {\n        for (; _value != 0; _size++) _value /= 256;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) internal pure {\n        // copy as many word sizes as possible\n        for (; len \u003e= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // left over bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.4;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\n\nlibrary SafeMath {\n    /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return a / b;\n    }\n\n    /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n\n    /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c \u003e= a);\n        return c;\n    }\n}\n"}}