{"Blacklistable.sol":{"content":"pragma solidity ^0.5.1;\n\nimport \"./Ownable.sol\";\n\n/**\n * @title Blacklistable Token\n * @dev Allows accounts to be blacklisted by a \"blacklister\" role\n*/\ncontract Blacklistable is Ownable {\n\n    address public blacklister;\n    mapping(address =\u003e bool) internal blacklisted;\n\n    event Blacklisted(address indexed _account);\n    event UnBlacklisted(address indexed _account);\n    event BlacklisterChanged(address indexed newBlacklister);\n\n    /**\n     * @dev Throws if called by any account other than the blacklister\n    */\n    modifier onlyBlacklister() {\n        require(msg.sender == blacklister);\n        _;\n    }\n\n    /**\n     * @dev Throws if argument account is blacklisted\n     * @param _account The address to check\n    */\n    modifier notBlacklisted(address _account) {\n        require(blacklisted[_account] == false);\n        _;\n    }\n\n    /**\n     * @dev Checks if account is blacklisted\n     * @param _account The address to check\n    */\n    function isBlacklisted(address _account) public view returns (bool) {\n        return blacklisted[_account];\n    }\n\n    /**\n     * @dev Adds account to blacklist\n     * @param _account The address to blacklist\n    */\n    function blacklist(address _account) public onlyBlacklister {\n        blacklisted[_account] = true;\n        emit Blacklisted(_account);\n    }\n\n    /**\n     * @dev Removes account from blacklist\n     * @param _account The address to remove from the blacklist\n    */\n    function unBlacklist(address _account) public onlyBlacklister {\n        blacklisted[_account] = false;\n        emit UnBlacklisted(_account);\n    }\n\n    function updateBlacklister(address _newBlacklister) public onlyOwner {\n        require(_newBlacklister != address(0));\n        blacklister = _newBlacklister;\n        emit BlacklisterChanged(blacklister);\n    }\n}\n"},"ECDSA.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * (.note) This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * (.warning) `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise)\n     * be too long), and then calling `toEthSignedMessageHash` on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 \u0026\u0026 v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\n     * JSON-RPC method.\n     *\n     * See `recover`.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.1;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"Pausable.sol":{"content":"pragma solidity ^0.5.1;\n\nimport \"./Ownable.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n * Based on openzeppelin tag v1.10.0 commit: feb665136c0dae9912e08397c1a21c4af3651ef3\n * Modifications:\n * 1) Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018)\n * 2) Removed whenNotPause/whenPaused from pause/unpause (6/14/2018)\n * 3) Removed whenPaused (6/14/2018)\n * 4) Switches ownable library to use zeppelinos (7/12/18)\n * 5) Remove constructor (7/13/18)\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n  event PauserChanged(address indexed newAddress);\n\n\n  address public pauser;\n  bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev throws if called by any account other than the pauser\n   */\n  modifier onlyPauser() {\n    require(msg.sender == pauser);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyPauser public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyPauser public {\n    paused = false;\n    emit Unpause();\n  }\n\n  /**\n   * @dev update the pauser role\n   */\n  function updatePauser(address _newPauser) onlyOwner public {\n    require(_newPauser != address(0));\n    pauser = _newPauser;\n    emit PauserChanged(pauser);\n  }\n\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * lopiddyuirt\n * Math` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"uCNY.sol":{"content":"/**\nuCNY is a Renminbi Fiat Token developed and released by uFiats,\na UCASH Network initiative.  uCNY and other uFiats are used as\ntokenized gift certificate currency units which are purchasable\nand sellable through a global converter network.\n\nUCASH Network partners, smart-contract Dapps, services,\ninitiatives and other 3rd parties can use uFiats to provide\na range of digital financial services.\n*/\n\npragma solidity ^0.5.1;\n\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./Ownable.sol\u0027;\nimport \u0027./Blacklistable.sol\u0027;\nimport \u0027./Pausable.sol\u0027;\nimport \u0027./ECDSA.sol\u0027;\n\n/**\n * @title uCNY Fiat Token\n * @dev ERC20 Token backed by fiat reserves\n */\n\n\ncontract uCNY is IERC20, Ownable, Pausable, Blacklistable {\n    using SafeMath for uint256;\n\n    string public name = \"uCNY Fiat Token\";\n    string public symbol = \"uCNY\";\n    uint8 public decimals = 18;\n    string public currency = \"CNY\";\n    address public masterCreator;\n\n    mapping(address =\u003e uint256) private balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private allowed;\n    uint256 public totalSupply = 0;\n\n    mapping(address =\u003e bool) internal creators;\n    mapping(address =\u003e uint256) internal creatorAllowed;\n\n    mapping(address=\u003e uint256) internal metaNonces;\n\n    event Create(address indexed creator, address indexed to, uint256 amount);\n    event Destroy(address indexed destroyer, uint256 amount);\n    event CreatorConfigured(address indexed creator, uint256 creatorAllowedAmount);\n    event CreatorRemoved(address indexed oldCreator);\n    event MasterCreatorChanged(address indexed newMasterCreator);\n\n    constructor() public {\n        masterCreator = msg.sender;\n        pauser = msg.sender;\n        blacklister = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than a creator\n    */\n    modifier onlyCreators() {\n        require(creators[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev Function to create tokens\n     * @param _to The address that will receive the createed tokens.\n     * @param _amount The amount of tokens to create. Must be less than or equal to the creatorAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n    */\n    function create(address _to, uint256 _amount) whenNotPaused onlyCreators notBlacklisted(msg.sender) notBlacklisted(_to) public returns (bool) {\n        require(_to != address(0));\n        require(_amount \u003e 0);\n\n        uint256 creatingAllowedAmount = creatorAllowed[msg.sender];\n        require(_amount \u003c= creatingAllowedAmount);\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        creatorAllowed[msg.sender] = creatingAllowedAmount.sub(_amount);\n        emit Create(msg.sender, _to, _amount);\n        emit Transfer(address(0x0), _to, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the masterCreator\n    */\n    modifier onlyMasterCreator() {\n        require(msg.sender == masterCreator);\n        _;\n    }\n\n    /**\n     * @dev Get creator allowance for an account\n     * @param creator The address of the creator\n    */\n    function creatorAllowance(address creator) public view returns (uint256) {\n        return creatorAllowed[creator];\n    }\n\n    /**\n     * @dev Checks if account is a creator\n     * @param account The address to check\n    */\n    function isCreator(address account) public view returns (bool) {\n        return creators[account];\n    }\n\n    /**\n     * @dev Function to add/update a new creator\n     * @param creator The address of the creator\n     * @param creatorAllowedAmount The reatingc amount allowed for the creator\n     * @return True if the operation was successful.\n    */\n    function configureCreator(address creator, uint256 creatorAllowedAmount) whenNotPaused onlyMasterCreator public returns (bool) {\n        creators[creator] = true;\n        creatorAllowed[creator] = creatorAllowedAmount;\n        emit CreatorConfigured(creator, creatorAllowedAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function to remove a creator\n     * @param creator The address of the creator to remove\n     * @return True if the operation was successful.\n    */\n    function removeCreator(address creator) onlyMasterCreator public returns (bool) {\n        creators[creator] = false;\n        creatorAllowed[creator] = 0;\n        emit CreatorRemoved(creator);\n        return true;\n    }\n\n    /**\n     * @dev allows a creator to destroy some of its own tokens\n     * Validates that caller is a creator and that sender is not blacklisted\n     * amount is less than or equal to the creator\u0027s account balance\n     * @param _amount uint256 the amount of tokens to be destroyed\n    */\n    function destroy(uint256 _amount) whenNotPaused onlyCreators notBlacklisted(msg.sender) public {\n        uint256 balance = balances[msg.sender];\n        require(_amount \u003e 0);\n        require(balance \u003e= _amount);\n\n        totalSupply = totalSupply.sub(_amount);\n        balances[msg.sender] = balance.sub(_amount);\n        emit Destroy(msg.sender, _amount);\n        emit Transfer(msg.sender, address(0), _amount);\n    }\n\n  /**\n     * @dev allows masterCreator to allocate role to another address\n     * Validates that caller is the current masterCreator\n     * @param _newMasterCreator address the address to allocate role to\n   */\n\n    function updateMasterCreator(address _newMasterCreator) onlyOwner public {\n        require(_newMasterCreator != address(0));\n        masterCreator = _newMasterCreator;\n        emit MasterCreatorChanged(masterCreator);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return A uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    /**\n     * @dev Transfer token to a specified address.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev gets the payload to sign when a user wants to do a metaTransfer\n     * @param _from uint256 address of the transferer\n     * @param _to uint256 address of the recipient\n     * @param value uint256 the amount of tokens to be transferred\n     * @param fee uint256 the fee paid to the relayer in uCNY\n     * @param nonce uint256 the metaNonce of the usere\u0027s metatransaction\n    */\n  function getTransferPayload(\n        address _from,\n        address _to,\n        uint256 value,\n        uint256 fee,\n        uint256 nonce\n    ) public\n    view\n    returns (bytes32 payload)\n  {\n    return ECDSA.toEthSignedMessageHash(\n      keccak256(abi.encodePacked(\n        \"transfer\",     // function specfic text\n        _from,          // transferer.\n        _to,            // recipient\n        address(this),  // Token address (replay protection).\n        value,          // Number of tokens.\n        fee,            // fee paid to metaTransfer relayer, in uCNY\n        nonce           // Local sender specific nonce (replay protection).\n      ))\n    );\n  }\n\n\n/**\n     * @dev gets the payload to sign when a user wants to do a metaApprove\n     * @param _from uint256 address of the approver\n     * @param _to uint256 address of the approvee\n     * @param value uint256 the amount of tokens to be approved\n     * @param fee uint256 the fee paid to the relayer in uCNY\n     * @param metaNonce uint256 the metaNonce of the usere\u0027s metatransaction\n    */\n    function getApprovePayload(\n        address _from,\n        address _to,\n        uint256 value,\n        uint256 fee,\n        uint256 metaNonce\n    ) public\n    view\n    returns (bytes32 payload)\n  {\n    return ECDSA.toEthSignedMessageHash(\n      keccak256(abi.encodePacked(\n        \"approve\",      // function specfic text\n        _from,          // Approver.\n        _to,            // Approvee\n        address(this),  // Token address (replay protection).\n        value,          // Number of tokens.\n        fee,            // Local sender specific nonce (replay protection).\n        metaNonce       // fee paid to metaApprove relayer, in uCNY\n      ))\n    );\n  }\n\n\n/**\n     * @dev gets the payload to sign when a user wants to do a metaTransferFrom\n     * @param _from uint256 the from address of the approver\n     * @param _to uint256 address of the recipient\n     * @param _by uint256 by address of the approvee\n     * @param value uint256 the amount of tokens to be transferred\n     * @param fee uint256 the fee paid to the relayer in uCNY\n     * @param metaNonce uint256 the metaNonce of the usere\u0027s metatransaction\n    */\n    function getTransferFromPayload(\n        address _from,\n        address _to,\n        address _by,\n        uint256 value,\n        uint256 fee,\n        uint256 metaNonce\n    ) public\n    view\n    returns (bytes32 payload)\n  {\n    return ECDSA.toEthSignedMessageHash(\n      keccak256(abi.encodePacked(\n        \"transferFrom\",     // function specfic text\n        _from,              // Approver\n        _to,                // Recipient\n        _by,                // Approvee\n        address(this),      // Token address (replay protection).\n        value,              // Number of tokens.\n        fee,                // fee paid to metaApprove relayer, in uCNY\n        metaNonce           // Local sender specific nonce (replay protection).\n      ))\n    );\n  }\n\n  /**\n     * @dev gets the current metaNonce of an address\n     * @param sender address of the metaTransaction sender\n **/\n  function getMetaNonce(address sender) public view returns (uint256) {\n    return metaNonces[sender];\n  }\n\n   /**\n     * @dev extra getter function to potentially satisfy ERC1776\n     * @param _from address of the metaTransaction sender\n **/\n\n  function meta_nonce(address _from) external view returns (uint256 nonce) {\n        return metaNonces[_from];\n    }\n\n\n  /**\n     * @dev function to validate a signiture with a given address and payload that has been signed\n **/\n  function isValidSignature(\n    address _signer,\n    bytes32 payload,\n    bytes memory signature\n  )\n    public\n    pure\n    returns (bool)\n  {\n    return (_signer == ECDSA.recover(\n      ECDSA.toEthSignedMessageHash(payload),\n      signature\n    ));\n  }\n /**\n     * @dev Emitted when metaTransfer is successfully executed\n     */\n      event MetaTransfer(address indexed relayer, address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when metaApprove is successfully executed\n     */\n    event MetaApproval(address indexed relayer, address indexed owner, address indexed spender, uint256 value);\n\n\n    /**\n     * @dev metaTransfer function called by relayer which executes a token transfer\n     * on behalf of the original sender who provided a vaild signature.\n     * @param _from address of the original sender\n     * @param _to address of the  recipient\n     * @param value uint256 amount of uCNY being sent\n     * @param fee uint256 uCNY fee rewarded to the relayer\n     * @param metaNonce uint256 metaNonce of the original sender\n     * @param signature bytes signature provided by original sender\n     */\n  function metaTransfer(\n        address _from,\n        address _to,\n        uint256 value,\n        uint256 fee,\n        uint256 metaNonce,\n        bytes memory signature\n  ) public returns (bool success) {\n\n\n    // Verify and increment nonce.\n    require(getMetaNonce(_from) == metaNonce);\n    metaNonces[_from] = metaNonces[_from].add(1);\n    // Verify signature.\n    bytes32 payload = getTransferPayload(_from,_to, value, fee, metaNonce);\n    require(isValidSignature(_from,payload,signature));\n\n    require(_from != address(0));\n\n    //_transfer(sender,receiver,value);\n    _transfer(_from,_to,value);\n    //send Fee to metaTx miner\n    _transfer(_from,msg.sender,fee);\n\n    emit MetaTransfer(msg.sender, _from,_to,value);\n    return true;\n  }\n\n/**\n     * @dev metaApprove function called by relayer which executes a token approval\n     * on behalf of the original sender who provided a vaild signature.\n     * @param _from address of the original approver\n     * @param _to address of the  recipient\n     * @param value uint256 amount of uCNY being sent\n     * @param fee uint256 uCNY fee rewarded to the relayer\n     * @param metaNonce uint256 metaNonce of the original approver\n     * @param signature bytes signature provided by original approver\n     */\n    function metaApprove(\n        address _from,\n        address _to,\n        uint256 value,\n        uint256 fee,\n        uint256 metaNonce,\n        bytes memory signature\n    ) public returns (bool success) {\n    // Verify and increment nonce.\n    require(getMetaNonce(_from) == metaNonce);\n    metaNonces[_from] = metaNonces[_from].add(1);\n\n    // Verify signature.\n    bytes32 payload = getApprovePayload(_from,_to, value, fee,metaNonce);\n    require(isValidSignature(_from, payload, signature));\n\n    require(_from != address(0));\n\n    //_approve(sender,receiver,value);\n    _approve(_from,_to,value);\n\n    //send Fee to metaTx miner\n    _transfer(_from,msg.sender,fee);\n\n    emit MetaApproval(msg.sender,_from,_to,value);\n    return true;\n    }\n\n\n/**\n     * @dev metaTransferFrom function called by relayer which executes a token transferFrom\n     * on behalf of the original sender who provided a vaild signature.\n     * @param _from address of the original sender\n     * @param _to address of the  recipient\n     * @param value uint256 amount of uCNY being sent\n     * @param fee uint256 uCNY fee rewarded to the relayer\n     * @param metaNonce uint256 metaNonce of the original sender\n     * @param signature bytes signature provided by original sender\n     */\n    function metaTransferFrom(\n        address _from,\n        address _to,\n        address _by,\n        uint256 value,\n        uint256 fee,\n        uint256 metaNonce,\n        bytes memory signature\n        ) public returns(bool){\n    // Verify and increment nonce.\n    require(getMetaNonce(_by) == metaNonce);\n    metaNonces[_by] = metaNonces[_by].add(1);\n\n    // Verify signature.\n    bytes32 payload = getTransferFromPayload(_from,_to,_by, value,fee, metaNonce);\n    require(isValidSignature(_by, payload, signature));\n\n    require(_by != address(0));\n\n    //_transfer(sender,receiver,value);\n    _transfer(_from,_to,value);\n\n      //send Fee to metaTx miner\n    _transfer(_by,msg.sender,fee);\n\n    //subtract approved amount by value+fee\n    _approve(_from, _by, allowed[_from][_by].sub(value));\n\n    emit MetaTransfer(msg.sender, _from,_to,value);\n\n    return true;\n    }\n\n       /**\n     * @dev Transfer token for a specified addresses.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Approve an address to spend another addresses\u0027 tokens.\n     * @param owner The address that owns the tokens.\n     * @param spender The address that will spend the tokens.\n     * @param value The number of tokens that can be spent.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n}\n"}}