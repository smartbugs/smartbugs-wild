{"AddressUtils.sol":{"content":"pragma solidity ^0.4.24;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param _addr address to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address _addr) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(_addr) }\n        return size \u003e 0;\n    }\n\n}\n"},"Ownable.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\". This adds two-phase\n * ownership control to OpenZeppelin\u0027s Ownable class. In this model, the original owner\n * designates a new owner but does not actually transfer ownership. The new owner then accepts\n * ownership and completes the transfer.\n */\ncontract Ownable {\n    address _owner;\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"OwnerRole: caller does not have the Owner role\");\n        _;\n    }\n\n    function isOwner(address account) public view returns (bool) {\n        return account == _owner;\n    }\n}\n"},"Proxy.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    function () payable external {\n        _fallback();\n    }\n\n    /**\n     * @return The Address of the implementation.\n     */\n    function _implementation() internal view returns (address);\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn\u0027t return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param implementation Address to delegate.\n     */\n    function _delegate(address implementation) internal {\n        assembly {\n        // Copy msg.data. We take full control of memory in this inline assembly\n        // block because it will not return to Solidity code. We overwrite the\n        // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n        // Call the implementation.\n        // out and outsize are 0 because we don\u0027t know the size yet.\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n        // Copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize) }\n            default { return(0, returndatasize) }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal {\n    }\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        c = _a * _b;\n        assert(c / _a == _b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // assert(_b \u003e 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\u0027t hold\n        return _a / _b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        assert(_b \u003c= _a);\n        return _a - _b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        c = _a + _b;\n        assert(c \u003e= _a);\n        return c;\n    }\n}\n"},"TokenProxy.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\nimport \"./TokenStorage.sol\";\nimport \"./UpgradeabilityProxy.sol\";\nimport \u0027./Ownable.sol\u0027;\n\n/**\n* @title TokenProxy\n* @notice A proxy contract that serves the latest implementation of TokenProxy.\n*/\ncontract TokenProxy is UpgradeabilityProxy, Ownable {\n    TokenStorage private dataStore;\n\n\n    constructor(address _implementation, address storageAddress)\n    UpgradeabilityProxy(_implementation)\n    public {\n        _owner = msg.sender;\n        dataStore = TokenStorage(storageAddress);\n    }\n\n    /**\n    * @dev Upgrade the backing implementation of the proxy.\n    * Only the admin can call this function.\n    * @param newImplementation Address of the new implementation.\n    */\n    function upgradeTo(address newImplementation) public onlyOwner {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n    * @return The address of the implementation.\n    */\n    function implementation() public view returns (address) {\n        return _implementation();\n    }\n}"},"TokenStorage.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\nimport \"./SafeMath.sol\";\nimport \u0027./Ownable.sol\u0027;\n\n/**\n* @title TokenStorage\n*/\ncontract TokenStorage  is Ownable{\n    using SafeMath for uint256;\n\n    //    mapping (address =\u003e bool) internal _allowedAccess;\n\n    // Access Modifier for Storage contract\n    address internal _registryContract;\n\n    constructor() public {\n        _owner = msg.sender;\n        _totalSupply = 1000000000 * 10 ** 18;\n        _balances[_owner] = _totalSupply;\n    }\n\n    function setProxyContractAndVersionOneDeligatee(address registryContract) onlyOwner public{\n        require(registryContract != address(0), \"InvalidAddress: invalid address passed for proxy contract\");\n        _registryContract = registryContract;\n    }\n\n    function getRegistryContract() view public returns(address){\n        return _registryContract;\n    }\n\n    //    function addDeligateContract(address upgradedDeligatee) public{\n    //        require(msg.sender == _registryContract, \"AccessDenied: only registry contract allowed access\");\n    //        _allowedAccess[upgradedDeligatee] = true;\n    //    }\n\n    modifier onlyAllowedAccess() {\n        require(msg.sender == _registryContract, \"AccessDenied: This address is not allowed to access the storage\");\n        _;\n    }\n\n    // Allowances with its Getter and Setter\n    mapping (address =\u003e mapping (address =\u003e uint256)) internal _allowances;\n\n    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyAllowedAccess {\n        _allowances[_tokenHolder][_spender] = _value;\n    }\n\n    function getAllowance(address _tokenHolder, address _spender) public view onlyAllowedAccess returns(uint256){\n        return _allowances[_tokenHolder][_spender];\n    }\n\n\n    // Balances with its Getter and Setter\n    mapping (address =\u003e uint256) internal _balances;\n    function addBalance(address _addr, uint256 _value) public onlyAllowedAccess {\n        _balances[_addr] = _balances[_addr].add(_value);\n    }\n\n    function subBalance(address _addr, uint256 _value) public onlyAllowedAccess {\n        _balances[_addr] = _balances[_addr].sub(_value);\n    }\n\n    function setBalance(address _addr, uint256 _value) public onlyAllowedAccess {\n        _balances[_addr] = _value;\n    }\n\n    function getBalance(address _addr) public view onlyAllowedAccess returns(uint256){\n        return _balances[_addr];\n    }\n\n    // Total Supply with Getter and Setter\n    uint256 internal _totalSupply = 0;\n\n    function addTotalSupply(uint256 _value) public onlyAllowedAccess {\n        _totalSupply = _totalSupply.add(_value);\n    }\n\n    function subTotalSupply(uint256 _value) public onlyAllowedAccess {\n        _totalSupply = _totalSupply.sub(_value);\n    }\n\n    function setTotalSupply(uint256 _value) public onlyAllowedAccess {\n        _totalSupply = _value;\n    }\n\n    function getTotalSupply() public view onlyAllowedAccess returns(uint256) {\n        return(_totalSupply);\n    }\n\n\n    // Locking Storage\n    /**\n    * @dev Reasons why a user\u0027s tokens have been locked\n    */\n    mapping(address =\u003e bytes32[]) internal lockReason;\n\n    /**\n     * @dev locked token structure\n     */\n    struct lockToken {\n        uint256 amount;\n        uint256 validity;\n        bool claimed;\n    }\n\n    /**\n     * @dev Holds number \u0026 validity of tokens locked for a given reason for\n     *      a specified address\n     */\n    mapping(address =\u003e mapping(bytes32 =\u003e lockToken)) internal locked;\n\n\n    // Lock Access Functions\n    function getLockedTokenAmount(address _of, bytes32 _reason) public view onlyAllowedAccess returns (uint256 amount){\n        if (!locked[_of][_reason].claimed)\n            amount = locked[_of][_reason].amount;\n    }\n\n    function getLockedTokensAtTime(address _of, bytes32 _reason, uint256 _time) public view onlyAllowedAccess returns(uint256 amount){\n        if (locked[_of][_reason].validity \u003e _time)\n            amount = locked[_of][_reason].amount;\n    }\n\n    function getTotalLockedTokens(address _of) public view onlyAllowedAccess returns(uint256 amount){\n        for (uint256 i = 0; i \u003c lockReason[_of].length; i++) {\n            amount = amount.add(getLockedTokenAmount(_of, lockReason[_of][i]));\n        }\n    }\n\n    function extendTokenLock(address _of, bytes32 _reason, uint256 _time) public onlyAllowedAccess returns(uint256 amount, uint256 validity){\n\n        locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\n        amount = locked[_of][_reason].amount;\n        validity = locked[_of][_reason].validity;\n    }\n\n    function increaseLockAmount(address _of, bytes32 _reason, uint256 _amount) public onlyAllowedAccess returns(uint256 amount, uint256 validity){\n        locked[_of][_reason].amount = locked[_of][_reason].amount.add(_amount);\n        amount = locked[_of][_reason].amount;\n        validity = locked[_of][_reason].validity;\n    }\n\n    function getUnlockable(address _of, bytes32 _reason) public view onlyAllowedAccess returns(uint256 amount){\n        if (locked[_of][_reason].validity \u003c= now \u0026\u0026 !locked[_of][_reason].claimed)\n            amount = locked[_of][_reason].amount;\n    }\n\n    function addLockedToken(address _of, bytes32 _reason, uint256 _amount, uint256 _validity) public onlyAllowedAccess {\n        locked[_of][_reason] = lockToken(_amount, _validity, false);\n    }\n\n    function addLockReason(address _of, bytes32 _reason) public onlyAllowedAccess {\n        lockReason[_of].push(_reason);\n    }\n\n    function getNumberOfLockReasons(address _of) public view onlyAllowedAccess returns(uint256 number){\n        number = lockReason[_of].length;\n    }\n\n    function getLockReason(address _of, uint256 _i) public view onlyAllowedAccess returns(bytes32 reason){\n        reason = lockReason[_of][_i];\n    }\n\n    function setClaimed(address _of, bytes32 _reason) public onlyAllowedAccess{\n        locked[_of][_reason].claimed = true;\n    }\n\n    function caller(address _of) public view  onlyAllowedAccess returns(uint){\n        return getTotalLockedTokens(_of);\n    }\n}"},"UpgradeabilityProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \u0027./Proxy.sol\u0027;\nimport \u0027./AddressUtils.sol\u0027;\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\n     * validated in the constructor.\n     */\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n\n    /**\n     * @dev Contract constructor.\n     * @param _implementation Address of the initial implementation.\n     */\n    constructor(address _implementation) public {\n        assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\n\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     * @return Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUtils.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"}}