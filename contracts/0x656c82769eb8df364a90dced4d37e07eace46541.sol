{"Address.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract\u0027s constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * \u003e It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n}\n"},"CapperRole.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"../Roles.sol\";\n\ncontract CapperRole {\n    using Roles for Roles.Role;\n\n    event CapperAdded(address indexed account);\n    event CapperRemoved(address indexed account);\n\n    Roles.Role private _cappers;\n\n    constructor () internal {\n        _addCapper(msg.sender);\n    }\n\n    modifier onlyCapper() {\n        require(isCapper(msg.sender), \"CapperRole: caller does not have the Capper role\");\n        _;\n    }\n\n    function isCapper(address account) public view returns (bool) {\n        return _cappers.has(account);\n    }\n\n    function addCapper(address account) public onlyCapper {\n        _addCapper(account);\n    }\n\n    function renounceCapper() public {\n        _removeCapper(msg.sender);\n    }\n\n    function _addCapper(address account) internal {\n        _cappers.add(account);\n        emit CapperAdded(account);\n    }\n\n    function _removeCapper(address account) internal {\n        _cappers.remove(account);\n        emit CapperRemoved(account);\n    }\n}\n"},"CrowdliExchangeVault.sol":{"content":"pragma solidity 0.5.0;\n\nimport \"./CrowdliSTO.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Pausable.sol\";\n\n/**\n* This contract can be in one of the following states:\n* - Active      The contract is open to new payment requests\n* - Closed      No new payments will be accepted nor payments can be rejected though refunds can be claimed for payments that had been prior to closing.\n*/\ncontract CrowdliExchangeVault is Ownable, Pausable {\n\n    struct EtherPayment {\n        address from;\n        uint64 date;\n        PaymentStatus status;\n        uint weiAmount;\n        uint pendingTokens;\n        uint mintedTokens;\n        uint exchangeRate;\n    }\n\n    struct ExchangeOrder {\n        uint256 exchangeRate;\n        uint64 date;\n        address exchangeWallet;\n        ExchangeStatus status;\n    }\n    \n    /**\n     * Defines the statuses an exchange order can have\n     */\n    enum ExchangeStatus { Pending, Confirmed }\n\n    /**\n    * Defines the statuses an payment can have\n    */\n    enum PaymentStatus { None, Requested, Accepted, TokensDelivered, Rejected, Refunded, PurchaseFailed }\n    \n    /**\n    * The safe math library for safety math operations provided by Zeppelin\n    */\n    using SafeMath for uint256;\n\n    /**\n    * Holds all exchange orders, each of them containing multiple payments\n    */\n   \tExchangeOrder[] public exchangeOrders;\n   \n    /**\n    * Holds all ether payments in different states (PaymentStatu\n    */\n    EtherPayment[] public payments;\n    \n    /**\n     * A dictionary holind the number of requested payment per investor\n     */\n    mapping(address =\u003e uint) public nrRequestedPayments; \n    \n    /**\n     * A dictionary to lookup the related payments (paymentsIds: uint[]) for a given exchange order (exchangeOrderId: uint)\n     */\n    mapping(uint =\u003e uint[]) private exchangeOrderForPayments; //exchangeOrderId =\u003e array of paymentsIds\n    \n    \n    address public paymentConfirmer;\n    \n    /**\n     * Used to process payments once they are confirmed \n     */\n    CrowdliSTO private crowdliSTO;\n    \n     /**\n     * Event will be fired whenever payments processing is enabled\n     * @param sender The account that has enabled the payment processing\n     */\n    event PaymentsEnabled(address indexed sender);\n    \n    /**\n     * Event will be fired whenever payments processing is disabled\n     * @param sender The account that has disabled the payment processing\n     */\n    event PaymentsDisabled(address indexed sender);\n    event EtherPaymentRefunded(address indexed beneficiary, uint256 weiAmount);\n    event EtherPaymentRequested(address indexed beneficiary, uint256 weiAmount, uint paymentIndex);\n    event EtherPaymentRejected(address indexed sender, uint etherPaymentIndex);\n    event LogGasUsed(address indexed sender, uint indexed value);\n    event EtherPaymentPurchaseFailed(address indexed sender, uint indexed etherPaymentIndex);\n    event OrderCreated(address indexed sender, uint[] payments);\n    event OrderConfirmed(address indexed sender, uint indexed etherPaymentIndex);\n\n\tmodifier isInInvestmentState() {\n         require(crowdliSTO.hasState(CrowdliSTO.States.Investment) || !crowdliSTO.paused(), \"bot in state investment\");\n        _;\n    }\n\n    modifier onlyCrowdliSTO() {\n        require((msg.sender == address(crowdliSTO)), \"Sender should be CrowdliSTO\");\n        _;\n    }\n    \n    modifier onlyEtherPaymentConfirmer() {\n        require((msg.sender == paymentConfirmer), \"Sender should be EtherPaymentConfirmer\");\n        _;\n    }\n    \n    constructor(address _paymentConfirmer) public {\n        paymentConfirmer = _paymentConfirmer; \n    }\n    \n\tfunction setCrowdliSTO(CrowdliSTO _crowdliSTO) external onlyOwner {\n    \tcrowdliSTO = _crowdliSTO;\n    }\n\n\tfunction initExchangeVault(address _directorsBoard, address _crowdliSTO) external onlyOwner{\n    \tcrowdliSTO = CrowdliSTO(_crowdliSTO);\n    \ttransferOwnership(_crowdliSTO);\n    \taddPauser(_directorsBoard);\n    \taddPauser(_crowdliSTO);\n    }\n    \n    function confirmMintedTokensForPayment(uint paymentId, uint _mintedTokens) external onlyOwner {\n        payments[paymentId].mintedTokens = payments[paymentId].mintedTokens.add(_mintedTokens);\n    }\n    /**\n    * @dev The ether provided by the investor will be collected for a new fiat exchange order will be triggered by the owner\n    * @dev Since the exact conversion rate that will be used for the fiat exchange is unknown the tokens will be minted AFTER once the order is completed\n    */\n\n    function requestPayment() external whenNotPaused payable  {\n        uint[] memory tokenStatement = crowdliSTO.calculateTokenStatementEther(msg.sender, msg.value, CrowdliSTO.Currency.ETH, false, 0); \n        // only process if validation code == OK\n        require(CrowdliSTO.TokenStatementValidation(tokenStatement[8]) == CrowdliSTO.TokenStatementValidation.OK, crowdliSTO.resolvePaymentError(CrowdliSTO.TokenStatementValidation(tokenStatement[8])));\n        \n        payments.push(EtherPayment(msg.sender, uint64(now), PaymentStatus.Requested, msg.value, 0, 0, 0));\n        nrRequestedPayments[msg.sender] = nrRequestedPayments[msg.sender].add(1);\n        emit EtherPaymentRequested(msg.sender, msg.value, payments.length.sub(1));\n    }\n    \n    /**\n    * @dev An investor can be subsequently rejected if the AML and PEP checks were negative\n    */\n    function rejectPayment(uint[] calldata _paymentIds) external onlyEtherPaymentConfirmer {\n        for(uint id = 0; id \u003c _paymentIds.length; id++){\n        \tuint paymentId = _paymentIds[id];\n            // we only allow payments that have not been confirmed, rejected or refunded yet\n            require(payments[paymentId].status == PaymentStatus.Requested, \"Payment must be in state Requested\");\n    \n            // mark ether payment as rejected and therby allowing the investor to claim refund\n            payments[paymentId].status = PaymentStatus.Rejected;\n            \n            nrRequestedPayments[payments[paymentId].from] = nrRequestedPayments[payments[paymentId].from].sub(1);\n            // fire an event so the investor can be informed that his payment was rejected\n            emit EtherPaymentRejected(payments[paymentId].from, paymentId);\n        }\n    }\n\n    /**\n    * @dev Once an investor has been rejected a refund can be claimed\n    */\n    function refundPayment(uint index) external {\n    \n        EtherPayment storage etherPayment = payments[index];\n        uint256 depositedValue = etherPayment.weiAmount;\n\n        // only allow refund for payments which have been rejected \n        require((etherPayment.from == msg.sender) || (msg.sender == paymentConfirmer), \"Refund are not enabled for sender\");\n        require(etherPayment.status == PaymentStatus.Rejected , \"etherPayment.status should be PaymentStatus.Rejected\");\n\t\trequire(address(this).balance \u003e= depositedValue , \"Exchange Vault balance doesn\u0027t have enough funds.\");\n        // mark ether payment status to refunded\n        etherPayment.status = PaymentStatus.Refunded;\n\n        // send the ether back to investors address\n        msg.sender.transfer(depositedValue);\n\n        emit EtherPaymentRefunded(msg.sender, depositedValue);\n    }\n\n    /**\n     * @param _exchangeWallet The wallet of the exchange provider where the ether will be sent for FIAT exchange\n     */\n    function createOrder(address payable _exchangeWallet, uint[] calldata _paymentsToAccept) external whenNotPaused onlyEtherPaymentConfirmer isInInvestmentState {\n        require(payments.length \u003e 0, \"At least one payment is required to exchange\");\n        ExchangeOrder memory exchangeOrder = ExchangeOrder(0, uint64(now), _exchangeWallet, ExchangeStatus.Pending);\n        exchangeOrders.push(exchangeOrder);\n        uint weiAmountForTransfering = 0;\n        // iterate through all payments which are not assigned to an exchange order\n       \tuint[] storage orderForPaymentIds = exchangeOrderForPayments[exchangeOrders.length-1];\n        for (uint64 i = 0; i \u003c _paymentsToAccept.length; i++) {\n            uint paymentId = _paymentsToAccept[i];\n            EtherPayment storage etherPayment = payments[paymentId];\n            require(etherPayment.status == PaymentStatus.Requested, \"should be in status requested\"); \n            etherPayment.status = PaymentStatus.Accepted;\n            orderForPaymentIds.push(paymentId);\n            processPayment(paymentId);\n            weiAmountForTransfering = weiAmountForTransfering.add(etherPayment.weiAmount);\n        }\n        emit OrderCreated(msg.sender, orderForPaymentIds);\n        _exchangeWallet.transfer(weiAmountForTransfering);\n    }\n\n\t/**\n\t* buy tokens on behalf of the investor\n\t*/\n\tfunction processPayment(uint _paymentId) internal {\n\t\tEtherPayment storage etherPayment = payments[_paymentId];\n\t    nrRequestedPayments[etherPayment.from] = nrRequestedPayments[etherPayment.from].sub(1);\n\t    crowdliSTO.processEtherPayment(etherPayment.from, etherPayment.weiAmount, _paymentId);\n\t    etherPayment.status = PaymentStatus.TokensDelivered;\n\t    etherPayment.exchangeRate = crowdliSTO.exchangeRate();\n    }\n    \n    function confirmOrder(uint64 _orderIndex, uint256 _exchangeRate) external whenNotPaused onlyEtherPaymentConfirmer {\n        require(_orderIndex \u003c exchangeOrders.length, \"_orderIndex is too high\");\n        ExchangeOrder storage exchangeOrder = exchangeOrders[_orderIndex];\n        require(exchangeOrder.status != ExchangeStatus.Confirmed, \"exchangeOrder.status is confirmed\");\n        exchangeOrder.exchangeRate = _exchangeRate;\n        exchangeOrder.status = ExchangeStatus.Confirmed;\n    }\n    \n    function hasRequestedPayments(address _beneficiary) public view returns(bool) {\n        return (nrRequestedPayments[_beneficiary] != 0);\n    }    \n        \n    function getEtherPaymentsCount() external view returns(uint256) {\n        return payments.length;\n    }\n    \n    function getExchangeOrdersCount() external view returns(uint256) {\n        return exchangeOrders.length;\n    }\n    \n    function getExchangeOrdersToPayments(uint orderId) external view returns (uint[] memory) {\n        return exchangeOrderForPayments[orderId];\n    }     \n    \n}\n"},"CrowdliKYCProvider.sol":{"content":"\npragma solidity 0.5.0;\n\nimport \"./Pausable.sol\";\nimport \"./WhitelistAdminRole.sol\";\n\ncontract CrowdliKYCProvider is Pausable, WhitelistAdminRole {\n\n\t/**\n\t * The verification levels supported by this ICO\n\t */\n\tenum VerificationTier { None, KYCAccepted, VideoVerified, ExternalTokenAgent } \n    \n    /**\n     * Defines the max. amount of tokens an investor can purchase for a given verification level (tier)\n     */\n\tmapping (uint =\u003e uint) public maxTokenAmountPerTier; \n    \n    /**\n    * Dictionary that maps addresses to investors which have successfully been verified by the external KYC process\n    */\n    mapping (address =\u003e VerificationTier) public verificationTiers;\n\n    /**\n    * This event is fired when a user has been successfully verified by the external KYC verification process\n    */\n    event LogKYCConfirmation(address indexed sender, VerificationTier verificationTier);\n\n\t/**\n\t * This constructor initializes a new  CrowdliKYCProvider initializing the provided token amount threshold for the supported verification tiers\n\t */\n    constructor(address _kycConfirmer, uint _maxTokenForKYCAcceptedTier, uint _maxTokensForVideoVerifiedTier, uint _maxTokensForExternalTokenAgent) public {\n        addWhitelistAdmin(_kycConfirmer);\n        // Max token amount for non-verified investors\n        maxTokenAmountPerTier[uint(VerificationTier.None)] = 0;\n        \n        // Max token amount for auto KYC auto verified investors\n        maxTokenAmountPerTier[uint(VerificationTier.KYCAccepted)] = _maxTokenForKYCAcceptedTier;\n        \n        // Max token amount for auto KYC video verified investors\n        maxTokenAmountPerTier[uint(VerificationTier.VideoVerified)] = _maxTokensForVideoVerifiedTier;\n        \n        // Max token amount for external token sell providers\n        maxTokenAmountPerTier[uint(VerificationTier.ExternalTokenAgent)] = _maxTokensForExternalTokenAgent;\n    }\n\n    function confirmKYC(address _addressId, VerificationTier _verificationTier) public onlyWhitelistAdmin whenNotPaused {\n        emit LogKYCConfirmation(_addressId, _verificationTier);\n        verificationTiers[_addressId] = _verificationTier;\n    }\n\n    function hasVerificationLevel(address _investor, VerificationTier _verificationTier) public view returns (bool) {\n        return (verificationTiers[_investor] == _verificationTier);\n    }\n    \n    function getMaxChfAmountForInvestor(address _investor) public view returns (uint) {\n        return maxTokenAmountPerTier[uint(verificationTiers[_investor])];\n    }    \n}"},"CrowdliSTO.sol":{"content":"pragma solidity 0.5.0;\n\nimport \"./CrowdliToken.sol\";\nimport \"./CrowdliKYCProvider.sol\";\nimport \"./CrowdliExchangeVault.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pausable.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Crowdli STO Contract\n */\ncontract CrowdliSTO is Pausable, Ownable {\n    /**\n     * The safe math library for safety math operations provided by Open Zeppelin\n     */\n    using SafeMath for uint;\n\n    /**\n     * Defines all states the STO can be in\n     */\n    enum States {\n        PrepareInvestment,\n        Investment,\n        Finalizing,\n        Finalized\n    }\n\n    struct InvestmentPhase {\n        bytes32 label;\n        bool allowManualSwitch;\n        uint discountBPS;\n        uint capAmount;\n        uint tokensSoldAmount;\n    }\n\n    struct TokenAllocation {\n        bytes32 label;\n        AllocationActionType actionType;\n        AllocationValueType valueType;\n        uint valueAmount;\n        address beneficiary;\n        bool isAllocated;\n    }\n\n    struct TokenStatement {\n        uint requestedBase;\n        uint requestedCHF;\n        uint feesCHF;\n        uint currentPhaseDiscount;\n        uint earlyBirdCreditTokenAmount;\n        uint voucherCreditTokenAmount;\n        uint currentPhaseTokenAmount;\n        uint nextPhaseBaseAmount;\n        TokenStatementValidation validationCode;\n    }\n\n    enum Currency {\n        ETH,\n        CHF,\n        EUR\n    }\n\n    enum ExecutionType {\n        SinglePayment,\n        SplitPayment\n    }\n\n    enum AllocationActionType {\n        POST_ALLOCATE\n    }\n\n    enum AllocationValueType {\n        FIXED_TOKEN_AMOUNT,\n        BPS_OF_TOKENS_SOLD\n    }\n\n    enum TokenStatementValidation {\n        OK,\n        BELOW_MIN_LIMIT,\n        ABOVE_MAX_LIMIT,\n        EXCEEDS_HARD_CAP\n    }\n\n    /**\n     * This event is fired when a ether payment is confirmed by payment confirmer\n     */\n    event LogPaymentConfirmation(address indexed beneficiary, uint indexed investment, uint[] paymentDetails, uint id, Currency currency, ExecutionType executionType);\n    /**\n     * This event is fired when a new investment sub-phase is registered during the PrepareInvestment phase\n     */\n    event LogRegisterInvestmentPhase(address indexed sender, bool allowManualSwitch, bytes32 indexed label, uint indexed discountBPS, uint cap);\n\n    /**\n     * This event is fired when the start date is updated\n     */\n    event LogSaleStartUpdated(address indexed sender, uint indexed saleStartDate);\n\n    /**\n     * This event is fired whenever the CrowdliKYCProvider used for the STO is updated\n     */\n    event LogKYCProviderUpdated(address indexed sender, address indexed crowdliKycProvider);\n\n    /**\n     * This event is fired when the STO has started\n     */\n    event LogStarted(address indexed sender);\n\n    /**\n     * This event is fired when a new investment phase starts\n     */\n    event LogInvestmentPhaseSwitched(uint phaseIndex);\n\n    /**\n     * This event is fired when the STO closes\n     */\n    event LogEndDateExtended(address indexed sender, uint endDate);\n\n    /**\n     * This event is fired when the STO closes\n     */\n    event LogClosed(address indexed sender, bool stoSucessfull);\n\n    /**\n     * This event will be fired when the customer finalizes the STO\n     */\n    event LogFinalized(address indexed sender);\n\n    /**\n     * Whenever the state of the contract changes, this event will be fired.\n     */\n    event LogStateChanged(States _states);\n    \n    /**\n     * Whenever the investor gets pending voucher.\n     */\n    event LogPendingVoucherAdded(address _investor);\n\n    /**\n     * State variable: Defines the state of the STO\n     */\n    States public state;\n\n    /**\n     * Only the foundation board is able to finalize the STO.\n     * Two of four members have to confirm the finalization. Therefore a multisig contract is used.\n     */\n    address public directorsBoard;\n\n    /**\n     * This account is authorized to confirm payments\n     */\n    address public paymentConfirmer;\n\n    /**\n     * This the wallet where for an external agent all tokens tokens are minted for the incoming payments\n     */\n    address public tokenAgentWallet;\n\n    /**\n     * The token we are giving the investors in return for their investments\n     */\n    CrowdliToken public token;\n\n    /**\n     * The exchange vault used to exchange ether payments in a restricted an safe manner with the authorized bank into fiat money\n     */\n    CrowdliExchangeVault public crowdliExchangeVault;\n\n    /**\n     * The kyc provider used to whitelist the investors for verification tiers\n     */\n    CrowdliKYCProvider public crowdliKycProvider;\n\n    /**\n     * STO settings \u0026 statistics: Pre- and post allocated tokens\n     */\n    TokenAllocation[] public tokenAllocations;\n\n    /**\n     * STO settings \u0026 statistics: Defines the phases for an STO\n     */\n    InvestmentPhase[] public investmentPhases;\n\n    /**\n     * STO Setting:  The total amount of tokens sold during the STO(includes all phases)\n     */\n    uint public hardCapAmount = 0;\n\n    /**\n     * The lower hardcap threshold allows a bandwith in which the hard cap is regarded as reached\n     */\n    uint public hardCapThresholdAmount;\n\n    /**\n     * STO Setting: The min. token amount that have to be sold so that the STO successful\n     */\n    uint public softCapAmount;\n\n    /**\n     * STO Setting: Minimum amount of tokens a investor is able to buy\n     */\n    uint public minChfAmountPerInvestment;\n    /**\n     * STO Setting: The UNIX timestamp (in seconds) defining when 1the STO will start\n     */\n    uint public saleStartDate;\n\n    /**\n     * The date the STO Organizer can extend the STO at latest for the defined offset\n     */\n    uint public endDateExtensionDecissionDate;\n\n    /**\n     * The endDate can be extended with this offset\n     */\n    uint public endDateExtensionOffset;\n\n    /**\n     * STO Setting: \n     */\n    uint public endDate;\n\n    /**\n     * STO settings: Video Verification cost\n     */\n    uint public videoVerificationCostAmount ;\n\n    /**\n     * STO settings: gas fees used for further processing of payments\n     */\n    uint internal gasCostAmount;\n\n    /**\n     * STO state: Defines the index of the current phase\n     */\n    uint public investmentPhaseIndex;\n\n    /**\n     * The board of directors can comment the finalization\n     * Crowdli change: change to bytes32 to reduce gas costs\n     */\n    bytes32 public boardComment;\n\n    /**\n     * Threshold to define if the investor should get \u0027earlyBird\u0027 status.\n     */\n    uint public earlyBirdTokensThresholdAmount;\n\n    /**\n     * Token to be added to the purchased tokens amount.\n     */\n    uint public earlyBirdAdditionalTokensAmount;\n\n    /**\n     * Maximum number of the \u0027earlyBird\u0027 investors.\n     */\n    uint public earlyBirdInvestorsCount;\n\n    /**\n     * First available investment phase for \u0027earlyBird\u0027 investor.\n     */\n    uint public earlyBirdInvestmentPhase = 0;\n\n    /**\n     * Current number of the \u0027earlyBird\u0027 investor.\n     */\n    uint public currentEarlyBirdInvestorsCount = 0;\n\n    /**\n     * The token amount an investor receives for redeeming a voucher\n     */\n    uint public voucherTokensAmount;\n\n    /**\n     * Investors that have a pending vouchers to be redeemed\n     */\n    mapping(address =\u003e bool) public investorsWithEarlyBird;\n\n    /**\n     * Investors that have pending vouchers.\n     */\n    mapping(address =\u003e bool) public investorsWithPendingVouchers;\n\n    /**\n     * Investors that have paid for the video verification\n     */\n    mapping(address =\u003e bool) public paidForVideoVerification;\n\n    /**\n     * STO Statistic: The total amount of tokens sold\n     */\n    uint public tokensSoldAmount;\n\n    /**\n     * STO Statistic: The total amount of WEI invested by this STO\n     */\n    uint public weiInvested ;\n\n    /**\n     * STO Statistic: The number of investors that have invested in this STO\n     */\n    uint public numberOfInvestors;\n\n    /**\n     * STO Statistic: The total amount of investments (FIAT and ETH) in CHF\n     */\n    mapping(address =\u003e uint) public allInvestmentsInChf;\n\n    /**\n     * STO Statistic: The total amount of WEI\u0027s per investor\n     */\n    mapping(address =\u003e uint) public weiPerInvestor;\n\n    /**\n     * STO Statistic: The total amount of CHF\u0027s per investor\n     */\n    mapping(address =\u003e uint) public chfPerInvestor;\n\n    /**\n     * STO Statistic: The total amount of CHF\u0027s investments\n     */\n    uint public chfOverallInvested;\n\n    /**\n     * STO Statistic: The total amount of EUR\u0027s per investor\n     */\n    mapping(address =\u003e uint) public eurPerInvestor;\n\n    /**\n     * STO Statistic: The total amount of EUR\u0027s investments\n     */\n    uint public eurOverallInvested;\n\n    /**\n     * The exchangeRate that was last used \n     */\n    uint public exchangeRate;\n\n    uint public exchangeRateDecimals;\n\n    /**\n     * Limit the size of arrays to avoid gas limit deadlocks \n     */\n\tuint constant public arrayMaxEntryLimit = 10;\n\t\n    // ============================================================================================================================================================================================================================   \n    // All modifiers come here\n    // ============================================================================================================================================================================================================================\n    /**\n     * @dev Throws if called by any account other than the foundation board\n     */\n    modifier onlyDirectorsBoard() {\n        require(msg.sender == directorsBoard, \"not directorsBoard\");\n        _;\n    }\n\n    /**\n     * @dev Throws if sender is not payment confirmer\n     */\n    modifier onlyFiatPaymentConfirmer() {\n        require((msg.sender == paymentConfirmer), \"not paymentConfirmer\");\n        _;\n    }\n\n    /**\n     * @dev Throws if sender is not payment confirmer\n     */\n    modifier onlyEtherPaymentProvider() {\n        require(msg.sender == address(crowdliExchangeVault), \"not crowdliExchangeVault\");\n        _;\n    }\n\n    /**\n     * @dev Throws if sender is not token agent payment confirmer\n     */\n    modifier onlyTokenAgentPaymentConfirmer() {\n        require((msg.sender == paymentConfirmer), \"not tokenAgentPaymentConfirmer\");\n        _;\n    }\n\n    /**\n     * @dev Throws if sender is not in state\n     */\n    modifier inState(States _state) {\n        require(hasState(_state), \"not in required state\");\n        _;\n    }\n\n\n    constructor (CrowdliToken _token, CrowdliKYCProvider _crowdliKycProvider, CrowdliExchangeVault _crowdliExchangeVault, address _directorsBoard, address _paymentConfirmer, address _tokenAgentWallet) public {\n        token = _token;\n        crowdliKycProvider = _crowdliKycProvider;\n        crowdliExchangeVault = _crowdliExchangeVault;\n        directorsBoard = _directorsBoard;\n        paymentConfirmer = _paymentConfirmer;\n        tokenAgentWallet = _tokenAgentWallet;\n    }\n\n    // ============================================================================================================================================================================================================================   \n    // External functions\n    // ============================================================================================================================================================================================================================v\n    function initSTO(uint _saleStartDate, uint _earlyBirdTokensThreshold,\n        uint _earlyBirdAdditionalTokens,\n        uint _earlyBirdInvestorsCount,\n        uint _earlyBirdInvestmentPhase,\n        uint _voucherTokensAmount,\n        uint _videoVerificationCost,\n        uint _softCap,\n        uint _endDate,\n        uint _endDateExtensionDecissionDate,\n        uint _endDateExtensionOffset,\n        uint _gasCost,\n        uint _hardCapThresholdAmount,\n        uint _minChfAmountPerInvestment) external onlyOwner {\n\n        // we must disallow any transfers until the end of the STO\n        token.pause();\n\n        saleStartDate = _saleStartDate;\n        state = States.PrepareInvestment;\n        earlyBirdTokensThresholdAmount = _earlyBirdTokensThreshold;\n        earlyBirdInvestorsCount = _earlyBirdInvestorsCount;\n        earlyBirdAdditionalTokensAmount = _earlyBirdAdditionalTokens;\n        earlyBirdInvestmentPhase = _earlyBirdInvestmentPhase;\n        voucherTokensAmount = _voucherTokensAmount;\n        videoVerificationCostAmount = _videoVerificationCost;\n        gasCostAmount = _gasCost;\n        softCapAmount = _softCap;\n        endDate = _endDate;\n        endDateExtensionDecissionDate = _endDateExtensionDecissionDate;\n        endDateExtensionOffset = _endDateExtensionOffset;\n        hardCapThresholdAmount = _hardCapThresholdAmount;\n        minChfAmountPerInvestment = _minChfAmountPerInvestment;\n\n    }\n\n    function registerPostAllocation(bytes32 _label, AllocationValueType _valueType, address _beneficiary, uint _value) external onlyOwner inState(States.PrepareInvestment) {\n        require(_label != 0, \"_label not set\");\n        require(_beneficiary != address(0), \"_beneficiary not set\");\n        require(_value \u003e 0, \"_value not set\");\n        require(tokenAllocations.length \u003c arrayMaxEntryLimit, \"tokenAllocations.length is too high\");\n        tokenAllocations.push(TokenAllocation(_label, AllocationActionType.POST_ALLOCATE, _valueType, _value, _beneficiary, false));\n    }\n\n    function updateStartDate(uint _saleStartDate) external onlyOwner inState(States.PrepareInvestment) {\n        require(_saleStartDate \u003e= now, \"saleStartDate not in future\");\n        saleStartDate = _saleStartDate;\n        emit LogSaleStartUpdated(msg.sender, _saleStartDate);\n    }\n\n    function updateCrowdliKYCProvider(CrowdliKYCProvider _crowdliKycProvider) external onlyOwner inState(States.PrepareInvestment) {\n        crowdliKycProvider = _crowdliKycProvider;\n        emit LogKYCProviderUpdated(msg.sender, address(_crowdliKycProvider));\n    }\n\n    function updateExchangeRate(uint _exchangeRate, uint _exchangeRateDecimals) external onlyOwner {\n        exchangeRate = _exchangeRate;\n        exchangeRateDecimals = _exchangeRateDecimals;\n    }\n\n    function registerInvestmentPhase(bytes32 _label, bool allowManualSwitch, uint _discountBPS, uint _cap) external onlyOwner inState(States.PrepareInvestment) {\n        require(_label != 0, \"label should not be empty\");\n        require(investmentPhases.length \u003c= arrayMaxEntryLimit, \"investmentPhases.length is too high\");\n        investmentPhases.push(InvestmentPhase(_label, allowManualSwitch, _discountBPS, _cap, 0));\n        emit LogRegisterInvestmentPhase(msg.sender, allowManualSwitch, _label, _discountBPS, _cap);\n        //the hardcap is the sum of all phases caps\n        hardCapAmount = hardCapAmount.add(_cap);\n    }\n\n    function processEtherPayment(address _beneficiary, uint _weiAmount, uint _paymentId) external whenNotPaused onlyEtherPaymentProvider inState(States.Investment) {\n        processPayment(_beneficiary, _paymentId, _weiAmount, Currency.ETH, exchangeRate, exchangeRateDecimals, false, true);\n    }\n\n    function processBankPaymentCHF(address _beneficiary, uint _chfAmount, bool _hasRequestedPayments, uint _paymentId) external whenNotPaused onlyFiatPaymentConfirmer inState(States.Investment) {\n        processPayment(_beneficiary, _paymentId, _chfAmount, Currency.CHF, 1, 1, _hasRequestedPayments, true);\n    }\n\n    function processBankPaymentEUR(address _beneficiary, uint _eurAmount, uint _exchangeRate, uint _exchangeRateDecimals, bool _hasRequestedPayments, uint _paymentId) external whenNotPaused onlyFiatPaymentConfirmer inState(States.Investment) {\n        processPayment(_beneficiary, _paymentId, _eurAmount, Currency.EUR, _exchangeRate, _exchangeRateDecimals, _hasRequestedPayments, true);\n    }\n\n    function processTokenAgentPaymentCHF(uint _chfAmount, uint _paymentId) external whenNotPaused onlyTokenAgentPaymentConfirmer inState(States.Investment) {\n        processPayment(tokenAgentWallet, _paymentId, _chfAmount, Currency.CHF, 1, 1, false, true);\n    }\n\n    function addPendingVoucher(address _investor) external onlyOwner whenNotPaused {\n        investorsWithPendingVouchers[_investor] = true;\n        emit LogPendingVoucherAdded(_investor);\n    }\n\n    function switchCurrentPhaseManually() external onlyDirectorsBoard inState(States.Investment) {\n        require(isCurrentPhaseManuallySwitchable(), \"manual switch disallowed\");\n\n        // calculate the gap between current phase and cap amount\n        InvestmentPhase memory currentInvestmentPhase = investmentPhases[investmentPhaseIndex];\n        uint phaseDeltaTokenAmount = currentInvestmentPhase.capAmount.sub(currentInvestmentPhase.tokensSoldAmount);\n\n        // all tokens which were not sold after manual close will be made available in the last investment phase\n        uint lastIndex = investmentPhases.length.sub(1);\n        investmentPhases[lastIndex].capAmount = investmentPhases[lastIndex].capAmount.add(phaseDeltaTokenAmount);\n        nextInvestmentPhase();\n    }\n\n    function start() external onlyDirectorsBoard inState(States.PrepareInvestment) {\n        startInternal();\n    }\n    \n    function calculateTokenStatementFiat(address _investor, uint _currencyAmount, Currency _currency, uint256 _exchangeRate, uint256 _exchangeRateDecimals, bool _hasRequestedBankPayments, uint investmentPhaseOffset) external view returns(uint[] memory) {\n        TokenStatement memory tokenStatement = calculateTokenStatementStruct(_investor, _currencyAmount, _currency, _exchangeRate, _exchangeRateDecimals, _hasRequestedBankPayments, (investmentPhaseOffset == 0), investmentPhaseOffset);\n        return convertTokenStatementToArray(tokenStatement);\n    }\n    \n    function calculateTokenStatementEther(address _investor, uint _currencyAmount, Currency _currency, bool _hasRequestedBankPayments, uint investmentPhaseOffset) external view returns(uint[] memory) {\n        //exchangeRate and exchangeRateDecimals will be used from internal parameters\n        TokenStatement memory tokenStatement = calculateTokenStatementStruct(_investor, _currencyAmount, _currency, exchangeRate, exchangeRateDecimals, _hasRequestedBankPayments, (investmentPhaseOffset == 0), investmentPhaseOffset);\n        return convertTokenStatementToArray(tokenStatement);\n    }\n\n    function evalTimedStates() external view returns (bool) {\n        return ((isEndDateReached() \u0026\u0026 state == States.Investment) || isStartRequired());\n    }\n\n    function extendEndDate() external inState(States.Investment) onlyDirectorsBoard {\n        require(isEndDateExtendable(), \"isEndDateExtendable() is false\");\n        endDate = endDate.add(endDateExtensionOffset);\n        endDateExtensionOffset = 0;\n        emit LogEndDateExtended(msg.sender, endDate);\n    }\n\n    function updateTimedStates() external {\n        if (isEndDateReached()) {\n            if (isSoftCapReached()) {\n                close(true);\n            } else {\n                close(false);\n            }\n        }\n        if(isStartRequired()){\n        \tstartInternal();\n        }\n    }\n\n    function closeManually() external onlyDirectorsBoard inState(States.Investment) {\n        require(isHardCapWithinCapThresholdReached(), \"Cap is not reached.\");\n        close(true);\n    }\n\n    /**\n     * Once the STO is in state Finalizing the directors board account has to finalize in order to make the tokens transferable\n     * @param _message An official statement why the STO is considered as successful\n     * \n     * Visibility: OK\n     */\n    function finalize(bytes32 _message) external onlyDirectorsBoard inState(States.Finalizing) {\n        // the directors board has to give an statement why the STO is successful\n        setBoardComment(_message);\n\n        // Make token transferable otherwise the transfer call used when granting vesting to teams will be rejected.\n        allocateTokens(AllocationActionType.POST_ALLOCATE);\n\n        // release the token so can be transfered or \n        token.unpause();\n\n        // finally the state of the STO is set to the final state \u0027Finalized\u0027 \n        updateState(States.Finalized);\n\n        emit LogFinalized(msg.sender);\n    }\n\n    // ============================================================================================================================================================================================================================   \n    // Public functions\n    // ============================================================================================================================================================================================================================v\n    function getInvestmentPhaseCount() public view returns(uint) {\n        return investmentPhases.length;\n    }\n\n    function  getTokenAllocationsCount() public view returns(uint) {\n        return tokenAllocations.length;\n    }\n\n    function validate() public view returns (uint) {\n        uint statusCode = 0;\n        if (address(token) == address(0)) {\n            statusCode = 1;\n        } else if (address(crowdliKycProvider) == address(0)) {\n            statusCode = 2;\n        } else if (softCapAmount == 0) {\n            statusCode = 3;\n        } else if (hardCapAmount == 0) {\n            statusCode = 4;\n        } else if (hardCapAmount \u003c softCapAmount) {\n            statusCode = 5;\n        } else if (minChfAmountPerInvestment == 0) {\n            statusCode = 6;\n        } else if (investmentPhases.length == 0) {\n            statusCode = 9;\n        }\n        return statusCode;\n    }\n\n    /**\n     * @dev there is no direct way to convert an enum to string\n     */\n    function resolvePaymentError(TokenStatementValidation validationCode) public pure returns(string memory) {\n        if (validationCode == TokenStatementValidation.BELOW_MIN_LIMIT) {\n            return \"BELOW_MIN_LIMIT\";\n        } else if (validationCode == TokenStatementValidation.ABOVE_MAX_LIMIT) {\n            return \"ABOVE_MAX_LIMIT\";\n        } else if (validationCode == TokenStatementValidation.EXCEEDS_HARD_CAP) {\n            return \"EXCEEDS_HARD_CAP\";\n        }\n    }\n\n    /**\n     * @dev access permissions (onlyPauser) is checked in super function\n     */\n    function pause() public {\n        super.pause();\n        crowdliExchangeVault.pause();\n        crowdliKycProvider.pause();\n    }\n\n    /**\n     * @dev access permissions (onlyPauser) is checked in super function\n     */\n    function unpause () public {\n        super.unpause();\n        crowdliExchangeVault.unpause();\n        crowdliKycProvider.unpause();\n    }\n\n    function setBoardComment(bytes32 _boardComment) public onlyDirectorsBoard {\n        boardComment = _boardComment;\n    }\n\n    function hasPendingVideoVerificationFees(address _investor, bool _hasRequestedBankPayments) private view returns (bool) {\n        return (crowdliKycProvider.hasVerificationLevel(_investor, CrowdliKYCProvider.VerificationTier.VideoVerified) \u0026\u0026 (!paidForVideoVerification[_investor]) \u0026\u0026 !hasUnconfirmedPayments(_investor, _hasRequestedBankPayments));\n    }\n\n    function isEntitledForEarlyBird(address _investor, uint tokenAmount, uint _investmentPhaseIndex) private view returns (bool) {\n        return ((tokenAmount \u003e= earlyBirdTokensThresholdAmount) \u0026\u0026 (currentEarlyBirdInvestorsCount \u003c earlyBirdInvestorsCount) \u0026\u0026 !investorsWithEarlyBird[_investor] \u0026\u0026 _investmentPhaseIndex \u003e= earlyBirdInvestmentPhase);\n    }\n\n    function hasPendingVouchers(address _investor, bool _hasRequestedBankPayments) private view returns (bool) {\n        return (investorsWithPendingVouchers[_investor] \u0026\u0026 !hasUnconfirmedPayments(_investor, _hasRequestedBankPayments));\n    }\n\n    function hasUnconfirmedPayments(address _investor, bool _hasRequestedBankPayments) private view returns (bool) {\n        return (_hasRequestedBankPayments || crowdliExchangeVault.hasRequestedPayments(_investor));\n    }\n\n    function isEndDateExtendable() public view returns (bool) {\n        return ((endDateExtensionDecissionDate \u003e= now) \u0026\u0026 (endDateExtensionOffset \u003e 0));\n    }\n\n    function isCurrentPhaseManuallySwitchable() public view returns(bool) {\n        return investmentPhases[investmentPhaseIndex].allowManualSwitch;\n    }\n\n    function isLastPhase() public view returns (bool) {\n        return (investmentPhaseIndex.add(1) \u003e= investmentPhases.length);\n    }\n\n    function isCurrentPhaseCapReached() public view returns(bool) {\n        InvestmentPhase memory investmentPhase = investmentPhases[investmentPhaseIndex];\n        return (investmentPhase.tokensSoldAmount \u003e= investmentPhase.capAmount);\n    }\n\n    function isHardCapWithinCapThresholdReached() public view returns (bool) {\n        return (isLastPhase() \u0026\u0026 (investmentPhases[investmentPhaseIndex].tokensSoldAmount \u003e= investmentPhases[investmentPhaseIndex].capAmount.sub(hardCapThresholdAmount)));\n    }\n\n \tfunction isHardCapReached() public view returns (bool) {\n        return (isLastPhase() \u0026\u0026 (investmentPhases[investmentPhaseIndex].tokensSoldAmount \u003e= investmentPhases[investmentPhaseIndex].capAmount));\n    }\n    \n    function isSoftCapReached() public view returns (bool) {\n        return (tokensSoldAmount \u003e= softCapAmount);\n    }\n\n    function isManuallyClosable() public view returns(bool) {\n        return(hasState(States.Investment) \u0026\u0026 isHardCapWithinCapThresholdReached());\n    }\n\n    function isEndDateReached() public view returns (bool) {\n        return (now \u003e endDate);\n    }\n\n    function hasState(States _state) public view returns (bool) {\n        return (state == _state);\n    }\n\n    /**\n     * Used by the STO user interface to retrieve the STO statistics with a single call\n     */\n    function getStatisticsData() public view returns(uint[] memory) {\n        uint[] memory result= new uint[](7);\n        result[0] = softCapAmount;\n        result[1] = hardCapAmount;\n        result[2] = weiInvested;\n        result[3] = chfOverallInvested;\n        result[4] = eurOverallInvested;\n        result[5] = tokensSoldAmount;\n        result[6] = numberOfInvestors;\n        return result;\n    }\n\n    // ============================================================================================================================================================================================================================   \n    // Private functions\n    // ============================================================================================================================================================================================================================v\n    function nextInvestmentPhase() private returns (bool) {\n        if (!isLastPhase()) {\n            // there is a next phase, so we can switch\n            investmentPhaseIndex = investmentPhaseIndex.add(1);\n            emit LogInvestmentPhaseSwitched(investmentPhaseIndex);\n            return false;\n\n        } else {\n            revert(\"payment exceeds hard cap\");\n        }\n    }\n\n    function confirmMintedTokensForPayment(uint _paymentId, uint tokenAmountToBuy, Currency _currency) private {\n        if (Currency.ETH == _currency) {\n            crowdliExchangeVault.confirmMintedTokensForPayment(_paymentId, tokenAmountToBuy);\n        }\n    }\n\n    function updateState(States _state) private {\n        require (_state \u003e state, \"the state can never transit backwards\");\n        state = _state;\n        emit LogStateChanged(state);\n    }\n\n    function close(bool stoSucessfull) private inState(States.Investment) {\n        require(hasState(States.Investment), \"Requires state Investment\");\n        updateState(States.Finalizing);\n        emit LogClosed(msg.sender, stoSucessfull);\n    }\n\n    function allocateTokens(AllocationActionType _actionType) private {\n        for (uint i = 0; i \u003c tokenAllocations.length;i++) {\n            if (tokenAllocations[i].actionType == _actionType) {\n                uint tokensToAllocate = 0;\n                if (tokenAllocations[i].valueType == AllocationValueType.BPS_OF_TOKENS_SOLD) {\n                    tokensToAllocate = tokensSoldAmount.mul(tokenAllocations[i].valueAmount).div(10000);\n                } else if (tokenAllocations[i].valueType == AllocationValueType.FIXED_TOKEN_AMOUNT) {\n                    tokensToAllocate = tokenAllocations[i].valueAmount;\n                }\n                token.mint(tokenAllocations[i].beneficiary, tokensToAllocate);\n                tokenAllocations[i].isAllocated = true;\n            }\n        }\n    }\n\n    function processPayment(address _investor, uint _paymentId, uint _currencyAmount, Currency _currency, uint _exchangeRate, uint _exchangeRateDecimals, bool _hasRequestedBankPayments, bool _isFirstPayment) private {\n        require(crowdliKycProvider.verificationTiers(_investor) \u003e CrowdliKYCProvider.VerificationTier.None, \"Verification tier not \u003e 0\");\n\n        InvestmentPhase storage investmentPhase = investmentPhases[investmentPhaseIndex];\n        // ============================================================================================\n        // Step 1: Calculate token statement\n        // ============================================================================================\n        TokenStatement memory tokenStatement = calculateTokenStatementStruct(_investor, _currencyAmount, _currency, _exchangeRate, _exchangeRateDecimals, _hasRequestedBankPayments, _isFirstPayment, 0);\n\n        // only process if validation code == OK\n        require(tokenStatement.validationCode == TokenStatementValidation.OK, resolvePaymentError(tokenStatement.validationCode));\n\n        // ============================================================================================\n        // Update the STO states and statistics\n        // ============================================================================================ \n        // sum up the tokens sold for the current investment phase\n        investmentPhase.tokensSoldAmount = investmentPhase.tokensSoldAmount.add(tokenStatement.currentPhaseTokenAmount);\n\n        // sum up the amount of tokens sold during the STO\n        tokensSoldAmount = tokensSoldAmount.add(tokenStatement.currentPhaseTokenAmount);\n\n        if (_isFirstPayment) {\n            allInvestmentsInChf[_investor] = allInvestmentsInChf[_investor].add(tokenStatement.requestedCHF);\n\n            if (tokenStatement.feesCHF \u003e gasCostAmount)\n\t        \tpaidForVideoVerification[_investor] = true;\n\n            if (Currency.CHF == _currency) {\n                chfPerInvestor[_investor] = chfPerInvestor[_investor].add(_currencyAmount);\n                chfOverallInvested = chfOverallInvested.add(_currencyAmount);\n            } else if (Currency.EUR == _currency) {\n                eurPerInvestor[_investor] = eurPerInvestor[_investor].add(_currencyAmount);\n                eurOverallInvested = eurOverallInvested.add(_currencyAmount);\n            } else if (Currency.ETH == _currency) {\n                weiPerInvestor[_investor] = weiPerInvestor[_investor].add(_currencyAmount);\n                weiInvested = weiInvested.add(_currencyAmount);\n            }\n\n            // update the statistic counting the number of investors involved in a token purchase\n            if (token.balanceOf(_investor) == 0) {\n                numberOfInvestors = numberOfInvestors.add(1);\n            }\n        }\n\n        if (tokenStatement.earlyBirdCreditTokenAmount \u003e 0) { // earlyBird         \n        // update early bird investor statistics\n            currentEarlyBirdInvestorsCount = currentEarlyBirdInvestorsCount.add(1);\n\n            // store flag that the investor has received early bird tokens\n            investorsWithEarlyBird[_investor] = true;\n        }\n\n        if (tokenStatement.voucherCreditTokenAmount \u003e 0) {\n            // mark voucher as redeemed for investor\n            investorsWithPendingVouchers[_investor] = false;\n        }\n\n\n        // ============================================================================================\n        // Mint the STO tokens\n        // ============================================================================================        \n        token.mint(_investor, tokenStatement.currentPhaseTokenAmount);\n\n        if (tokenStatement.nextPhaseBaseAmount \u003e 0) {\n            ExecutionType executionType;\n\n            executionType = ExecutionType.SplitPayment;\n\n            emit LogPaymentConfirmation(_investor, tokenStatement.requestedBase, convertTokenStatementToArray(tokenStatement), _paymentId, _currency, executionType);\n            confirmMintedTokensForPayment(_paymentId, tokenStatement.currentPhaseTokenAmount, _currency);\n\n            // switch to next phase\n            nextInvestmentPhase();\n\n            // process payment in the new phase\n            processPayment(_investor, _paymentId, tokenStatement.nextPhaseBaseAmount, _currency, _exchangeRate, _exchangeRateDecimals, _hasRequestedBankPayments, false);\n        } else {\n\n            // no further payments to process\n            emit LogPaymentConfirmation(_investor, tokenStatement.requestedBase, convertTokenStatementToArray(tokenStatement), _paymentId, _currency, ExecutionType.SinglePayment);\n            confirmMintedTokensForPayment(_paymentId, tokenStatement.currentPhaseTokenAmount, _currency);\n        }\n    }\n\n    function convertTokenStatementToArray(TokenStatement memory tokenStatement) private pure returns(uint[] memory) {\n        uint[] memory tokenStatementArray = new uint[](9);\n        tokenStatementArray[0] = tokenStatement.requestedBase;\n        tokenStatementArray[1] = tokenStatement.requestedCHF;\n        tokenStatementArray[2] = tokenStatement.feesCHF;\n        tokenStatementArray[3] = tokenStatement.currentPhaseDiscount;\n        tokenStatementArray[4] = tokenStatement.earlyBirdCreditTokenAmount;\n        tokenStatementArray[5] = tokenStatement.voucherCreditTokenAmount;\n        tokenStatementArray[6] = tokenStatement.currentPhaseTokenAmount;\n        tokenStatementArray[7] = tokenStatement.nextPhaseBaseAmount;\n        tokenStatementArray[8] = uint(tokenStatement.validationCode);\n        return tokenStatementArray;\n    }\n\n    function calculateDiscountUptick(uint _amount, InvestmentPhase memory investmentPhase) private pure returns (uint) {\n        uint currentRate = uint(10000).sub(investmentPhase.discountBPS);\n        return _amount.mul(investmentPhase.discountBPS).div(currentRate);\n    }\n\n    function calculateDiscount(uint _amount, InvestmentPhase memory investmentPhase) private pure returns (uint) {\n        return _amount.mul(investmentPhase.discountBPS).div(10000);\n    }\n\n    function calculateConversionFromBase(uint _currencyAmount, uint _exchangeRate, uint _exchangeRateDecimals) private pure returns (uint) {\n        return _currencyAmount.mul(_exchangeRate).div(_exchangeRateDecimals);\n    }\n\n    function calculateConversionToBase(uint _currencyAmount, uint _exchangeRate, uint _exchangeRateDecimals) private pure returns (uint) {\n        return _currencyAmount.mul(_exchangeRateDecimals).div(_exchangeRate);\n    }\n\n    function calculateTokenStatementStruct(address _investor, uint _currencyAmount, Currency _currency, uint256 _exchangeRate, uint256 _exchangeRateDecimals, bool _hasRequestedBankPayments, bool _isFirstPayment, uint _investmentPhaseOffset) private view returns(TokenStatement memory) {\n        TokenStatement memory tokenStatement;\n\n        // the struct containing the data for the current investment phase\n        uint investmentPhaseWithOffset = investmentPhaseIndex.add(_investmentPhaseOffset);\n        InvestmentPhase memory investmentPhase = investmentPhases[investmentPhaseWithOffset];\n\n        // the requested amount in the currency provided\n        tokenStatement.requestedBase = _currencyAmount;\n\n        // ============================================================================================\n        // Step 1: Convert requested payment to CHF\n        // ============================================================================================\n        if (Currency.CHF == _currency) {\n            tokenStatement.requestedCHF = tokenStatement.requestedBase;\n        } else if (Currency.EUR == _currency) {\n            tokenStatement.requestedCHF = calculateConversionFromBase(tokenStatement.requestedBase, _exchangeRate, _exchangeRateDecimals);\n        } else if (Currency.ETH == _currency) {\n            tokenStatement.requestedCHF = calculateConversionFromBase(tokenStatement.requestedBase, _exchangeRate, _exchangeRateDecimals);\n        } else revert(\"Currency not supported\");\n\n        // the requested amount in the currency provided\n        tokenStatement.requestedCHF = roundUp(tokenStatement.requestedCHF);\n\n        uint investmentNetCHF = tokenStatement.requestedCHF;\n\n        // calculate the fees (gas cost always, video verification once, if previously processed)\n        // we have to make sure that the credits are not recognized twice in case of a split payment\n        if (_isFirstPayment) {\n            // ============================================================================================\n\t        // Verify/validate investment thresholds\n\t        // ============================================================================================\n\t        tokenStatement.validationCode = validatePayment(_investor, tokenStatement);\n \n            tokenStatement.feesCHF = gasCostAmount;\n            if (hasPendingVideoVerificationFees(_investor, _hasRequestedBankPayments)) {\n                tokenStatement.feesCHF = tokenStatement.feesCHF.add(videoVerificationCostAmount);\n            }\n            investmentNetCHF = tokenStatement.requestedCHF.sub(tokenStatement.feesCHF);\n        }\n\n        // check whether the payment can be handled in the current phase OR we have to create a second payment to be executed in the next phase\n        uint phaseDeltaTokenAmount = investmentPhase.capAmount.sub(investmentPhase.tokensSoldAmount);\n        tokenStatement.currentPhaseDiscount = roundUp(calculateDiscountUptick(investmentNetCHF, investmentPhase));\n        uint tokenAmountWithCurrentPhaseDiscount = investmentNetCHF.add(tokenStatement.currentPhaseDiscount);\n\n\n\n        // create second payment (split) if tokens exceed current phase cap\n        if (tokenAmountWithCurrentPhaseDiscount \u003e phaseDeltaTokenAmount) {\n        \tif (isLastPhase())\n            \ttokenStatement.validationCode = TokenStatementValidation.EXCEEDS_HARD_CAP;\n        \n            tokenStatement.currentPhaseTokenAmount = roundUp(phaseDeltaTokenAmount);\n            tokenStatement.currentPhaseDiscount = roundUp(calculateDiscount(phaseDeltaTokenAmount, investmentPhase));\n            uint currentPhaseNetTokenAmount = phaseDeltaTokenAmount.sub(tokenStatement.currentPhaseDiscount);\n            tokenStatement.nextPhaseBaseAmount = calculateConversionToBase(investmentNetCHF.sub(currentPhaseNetTokenAmount), _exchangeRate, _exchangeRateDecimals);\n        } else {\n            tokenStatement.currentPhaseDiscount = tokenStatement.currentPhaseDiscount;\n            tokenStatement.currentPhaseTokenAmount = tokenAmountWithCurrentPhaseDiscount;\n            tokenStatement.nextPhaseBaseAmount = 0;\n\n            // we have to make sure that the credits are not recognized twice in case of a split payment\n            // the first x investors starting from phase y will receive some bonus tokens\n            if (isEntitledForEarlyBird(_investor, tokenStatement.currentPhaseTokenAmount, investmentPhaseWithOffset)) {\n                tokenStatement.earlyBirdCreditTokenAmount = earlyBirdAdditionalTokensAmount;\n                tokenStatement.currentPhaseTokenAmount = tokenStatement.currentPhaseTokenAmount.add(tokenStatement.earlyBirdCreditTokenAmount);\n            }\n            // investor receives some bonus tokens if he has previously redeemed a valid STO voucher\n            if (hasPendingVouchers(_investor, _hasRequestedBankPayments)) {\n                tokenStatement.voucherCreditTokenAmount = voucherTokensAmount;\n                tokenStatement.currentPhaseTokenAmount = tokenStatement.currentPhaseTokenAmount.add(tokenStatement.voucherCreditTokenAmount);\n            }\n        }\n        \n        // the STO requires to round up the decimals\n        tokenStatement.currentPhaseTokenAmount = roundUp(tokenStatement.currentPhaseTokenAmount);\n        return tokenStatement;\n    }\n\n    function validatePayment(address _investor, TokenStatement memory tokenStatement) private view returns(TokenStatementValidation) {\n        if (tokenStatement.requestedCHF \u003c minChfAmountPerInvestment) {\n            // a single investment (token purchase) musn\u0027t be below the defined min. token amount threshold\n            return TokenStatementValidation.BELOW_MIN_LIMIT; // a single investment (token purchase) musn\u0027t exceed the max token amount per KYC Verification Tier\n        } else if (allInvestmentsInChf[_investor].add(tokenStatement.requestedCHF) \u003e crowdliKycProvider.getMaxChfAmountForInvestor(_investor)) {\n            // a single investment (token purchase) musn\u0027t exceed the max token amount per KYC Verification Tier \n            return TokenStatementValidation.ABOVE_MAX_LIMIT;\n        } else return TokenStatementValidation.OK;\n\n    }\n    \n    function isStartRequired() private view returns(bool) {\n    \treturn ((now \u003e saleStartDate) \u0026\u0026 state == States.PrepareInvestment);\n    }\n    \n    function startInternal() private {\n    \trequire(validate() == 0, \"Start validation failed\");\n        saleStartDate = now;\n        updateState(States.Investment);\n        emit LogStarted(msg.sender);\n    }\n\n    function roundUp(uint amount) private pure returns(uint) {\n        uint decimals = 10 ** 18;\n        uint result = amount;\n        uint remainder = amount % decimals;\n        if (remainder \u003e 0) {\n            result = amount - remainder + decimals;\n        }\n        return result;\n    }\n}\n"},"CrowdliToken.sol":{"content":"pragma solidity 0.5.0;\n\nimport \"./Ownable.sol\";\nimport \"./ERC20Detailed.sol\";\nimport \"./ERC20Mintable.sol\";\nimport \"./ERC20Pausable.sol\";\n\n/**\n* @title CrowdliToken\n*/\ncontract CrowdliToken is ERC20Detailed, ERC20Mintable, ERC20Pausable, Ownable {\n\t/**\n\t * Holds the addresses of the investors\n\t */\n    address[] public investors;\n\n    constructor (string memory _name, string memory _symbol, uint8 _decimals) ERC20Detailed(_name,_symbol,_decimals) public {\n    }\n    \n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n         if (balanceOf(account) == 0) {\n            investors.push(account);\n         }\n         return super.mint(account, amount);\n    }\n    \n    \n    function initToken(address _directorsBoard,address _crowdliSTO) external onlyOwner{\n    \taddMinter(_directorsBoard);\n    \taddMinter(_crowdliSTO);\n    \taddPauser(_directorsBoard);\n    \taddPauser(_crowdliSTO);\n    }\n    \n}\n\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller\u0027s allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"},"ERC20Capped.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20Mintable.sol\";\n\n/**\n * @dev Extension of `ERC20Mintable` that adds a cap to the supply of tokens.\n */\ncontract ERC20Capped is ERC20Mintable {\n    uint256 private _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor (uint256 cap) public {\n        require(cap \u003e 0, \"ERC20Capped: cap is 0\");\n        _cap = cap;\n    }\n\n    /**\n     * @dev Returns the cap on the token\u0027s total supply.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See `ERC20Mintable.mint`.\n     *\n     * Requirements:\n     *\n     * - `value` must not cause the total supply to go over the cap.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(totalSupply().add(value) \u003c= _cap, \"ERC20Capped: cap exceeded\");\n        super._mint(account, value);\n    }\n}\n"},"ERC20Detailed.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * \u003e Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"},"ERC20Mintable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"./MinterRole.sol\";\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"},"ERC20Pausable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"./Pausable.sol\";\n\n/**\n * @title Pausable token\n * @dev ERC20 modified with pausable transfers.\n */\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"MinterRole.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Roles.sol\";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * \u003e Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"Pausable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./PauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"},"PauserRole.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Roles.sol\";\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"},"Roles.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address =\u003e bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account\u0027s access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"},"SafeERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"SignerRole.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Roles.sol\";\n\ncontract SignerRole {\n    using Roles for Roles.Role;\n\n    event SignerAdded(address indexed account);\n    event SignerRemoved(address indexed account);\n\n    Roles.Role private _signers;\n\n    constructor () internal {\n        _addSigner(msg.sender);\n    }\n\n    modifier onlySigner() {\n        require(isSigner(msg.sender), \"SignerRole: caller does not have the Signer role\");\n        _;\n    }\n\n    function isSigner(address account) public view returns (bool) {\n        return _signers.has(account);\n    }\n\n    function addSigner(address account) public onlySigner {\n        _addSigner(account);\n    }\n\n    function renounceSigner() public {\n        _removeSigner(msg.sender);\n    }\n\n    function _addSigner(address account) internal {\n        _signers.add(account);\n        emit SignerAdded(account);\n    }\n\n    function _removeSigner(address account) internal {\n        _signers.remove(account);\n        emit SignerRemoved(account);\n    }\n}\n"},"WhitelistAdminRole.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Roles.sol\";\n\n/**\n * @title WhitelistAdminRole\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n */\ncontract WhitelistAdminRole {\n    using Roles for Roles.Role;\n\n    event WhitelistAdminAdded(address indexed account);\n    event WhitelistAdminRemoved(address indexed account);\n\n    Roles.Role private _whitelistAdmins;\n\n    constructor () internal {\n        _addWhitelistAdmin(msg.sender);\n    }\n\n    modifier onlyWhitelistAdmin() {\n        require(isWhitelistAdmin(msg.sender), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\n        _;\n    }\n\n    function isWhitelistAdmin(address account) public view returns (bool) {\n        return _whitelistAdmins.has(account);\n    }\n\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n        _addWhitelistAdmin(account);\n    }\n\n    function renounceWhitelistAdmin() public {\n        _removeWhitelistAdmin(msg.sender);\n    }\n\n    function _addWhitelistAdmin(address account) internal {\n        _whitelistAdmins.add(account);\n        emit WhitelistAdminAdded(account);\n    }\n\n    function _removeWhitelistAdmin(address account) internal {\n        _whitelistAdmins.remove(account);\n        emit WhitelistAdminRemoved(account);\n    }\n}\n"},"WhitelistedRole.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Roles.sol\";\nimport \"./WhitelistAdminRole.sol\";\n\n/**\n * @title WhitelistedRole\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\n * it), and not Whitelisteds themselves.\n */\ncontract WhitelistedRole is WhitelistAdminRole {\n    using Roles for Roles.Role;\n\n    event WhitelistedAdded(address indexed account);\n    event WhitelistedRemoved(address indexed account);\n\n    Roles.Role private _whitelisteds;\n\n    modifier onlyWhitelisted() {\n        require(isWhitelisted(msg.sender), \"WhitelistedRole: caller does not have the Whitelisted role\");\n        _;\n    }\n\n    function isWhitelisted(address account) public view returns (bool) {\n        return _whitelisteds.has(account);\n    }\n\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\n        _addWhitelisted(account);\n    }\n\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n        _removeWhitelisted(account);\n    }\n\n    function renounceWhitelisted() public {\n        _removeWhitelisted(msg.sender);\n    }\n\n    function _addWhitelisted(address account) internal {\n        _whitelisteds.add(account);\n        emit WhitelistedAdded(account);\n    }\n\n    function _removeWhitelisted(address account) internal {\n        _whitelisteds.remove(account);\n        emit WhitelistedRemoved(account);\n    }\n}\n"}}