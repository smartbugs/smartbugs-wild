{"PLincGamesHub.sol":{"content":"pragma solidity 0.5.8;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract PLincGamesHub {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    constructor(address plicHubAddress)\r\n        public\r\n    {\r\n       plincHub = IPLincHub(plicHubAddress);\r\n       \r\n       plincHub.setAuto(9);\r\n    }\r\n    \r\n    function()\r\n        external\r\n        payable\r\n    {}\r\n    \r\n    address manager = address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\r\n    \r\n    event AddGame(address game);\r\n    event RemoveGame(address game);\r\n\r\n    modifier onlyManager()\r\n    {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    function addGame(address gameAddress)\r\n        external\r\n        onlyManager\r\n        isUnregisteredGame(gameAddress)\r\n    {\r\n        games[gameAddress] = Game(true, 0, 0);\r\n        numberOfGames++;\r\n        \r\n        emit AddGame(gameAddress);\r\n    }\r\n    \r\n    function removeGame(address gameAddress)\r\n        external\r\n        onlyManager\r\n        isRegisteredGame(gameAddress)\r\n    {\r\n        games[gameAddress].registered = false;\r\n        numberOfGames--;\r\n        \r\n        emit RemoveGame(gameAddress);\r\n    }\r\n    \r\n    //\r\n    //Players\r\n    //\r\n    \r\n    struct Player {\r\n        uint256 balance;\r\n        string name;\r\n        uint256 fundingBalance;\r\n    }\r\n    \r\n    mapping(address =\u003e Player) public players;\r\n    mapping(string =\u003e bool) public names;\r\n    uint256 public totalPlayerBalances;\r\n    uint256 public totalFundingBalances;\r\n    \r\n    event RegisterName(address indexed player, string indexed name);\r\n    event Withdraw(address indexed player, uint256 amount);\r\n    event Fund(address indexed funder, uint256 amount);\r\n    event WithdrawFunding(address indexed player, uint256 amount);\r\n\t\r\n\tfunction fund()\r\n\t    external\r\n\t    payable\r\n\t    withdrawPiggyBank\r\n\t{\r\n\t    players[msg.sender].fundingBalance = players[msg.sender].fundingBalance.add(msg.value);\r\n\t    \r\n\t    totalFundingBalances += msg.value;\r\n\t    \r\n\t    emit Fund(msg.sender, msg.value);\r\n\t}\r\n\t\r\n\tfunction playGame(bytes calldata data)\r\n\t    external\r\n\t    payable\r\n\t    withdrawPiggyBank\r\n\t{\r\n\t    (address gameAddress, bytes memory gameData) = abi.decode(data, (address, bytes));\r\n\t    \r\n\t    require(games[gameAddress].registered);\r\n\t    \r\n\t    games[gameAddress].amountGiven += msg.value;\r\n\t    \r\n\t    IHubGame(gameAddress).play(msg.sender, msg.value, gameData);\r\n\t    \r\n\t    buyBondsInternally(msg.value / plincDivisor);\r\n\t}\r\n\t\r\n\tfunction withdrawBalance()\r\n\t    external\r\n\t    withdrawPiggyBank\r\n\t{\r\n\t    uint256 amount = players[msg.sender].balance;\r\n\t    \r\n\t    players[msg.sender].balance = 0;\r\n\t    \r\n\t    totalPlayerBalances -= amount;\r\n\t   \r\n\t    msg.sender.transfer(amount);\r\n\t    \r\n\t    emit Withdraw(msg.sender, amount);\r\n\t}\r\n\t\r\n\tfunction withdrawBalancePartial(uint256 howMuch)\r\n\t    external\r\n\t    withdrawPiggyBank\r\n\t{\r\n\t    players[msg.sender].balance = players[msg.sender].balance.sub(howMuch);\r\n\t    \r\n\t    totalPlayerBalances -= howMuch;\r\n\t   \r\n\t    msg.sender.transfer(howMuch);\r\n\t    \r\n\t    emit Withdraw(msg.sender, howMuch);\r\n\t}\r\n\t\r\n\tfunction withdrawFundingBalance()\r\n\t    external\r\n\t    withdrawPiggyBank\r\n\t{\r\n\t    uint256 amount = players[msg.sender].fundingBalance;\r\n\t    \r\n\t    players[msg.sender].fundingBalance = 0;\r\n\t    \r\n\t    totalFundingBalances -= amount;\r\n\t   \r\n\t    msg.sender.transfer(amount);\r\n\t    \r\n\t    emit WithdrawFunding(msg.sender, amount);\r\n\t}\r\n\t\r\n\tfunction withdrawFundingBalancePartial(uint256 howMuch)\r\n\t    external\r\n\t    withdrawPiggyBank\r\n\t{\r\n\t    players[msg.sender].fundingBalance = players[msg.sender].fundingBalance.sub(howMuch);\r\n\t    \r\n\t    totalFundingBalances -= howMuch;\r\n\t   \r\n\t    msg.sender.transfer(howMuch);\r\n\t    \r\n\t    emit WithdrawFunding(msg.sender, howMuch);\r\n\t}\r\n\t\r\n\tfunction registerName(string calldata newName)\r\n\t    external\r\n\t    payable\r\n\t    withdrawPiggyBank\r\n\t{\r\n\t    require(msg.value \u003e= 0.01 ether);\r\n\t    require(bytes(newName).length \u003e 0 \u0026\u0026 bytes(newName).length \u003c= 32);\r\n\t    require(!names[newName]);\r\n\t    \r\n\t    players[msg.sender].name = newName;\r\n\t    names[newName] = true;\r\n\t    \r\n\t    emit RegisterName(msg.sender, newName);\r\n\t}\r\n\t\r\n\t//\r\n\t//Games\r\n\t//\r\n\t\r\n\tstruct Game {\r\n        bool registered;\r\n        uint256 amountGiven;\r\n        uint256 amountTaken;\r\n    }\r\n    \r\n    mapping(address =\u003e Game) public games;\r\n    uint256 public numberOfGames;\r\n\t\r\n\tmodifier isRegisteredGame(address gameAddress)\r\n    {\r\n        require(games[gameAddress].registered);\r\n        _;\r\n    }\r\n    \r\n    modifier isUnregisteredGame(address gameAddress)\r\n    {\r\n        require(!games[gameAddress].registered);\r\n        _;\r\n    }\r\n\t\r\n\tfunction addPlayerBalance(address playerAddress, uint256 value)\r\n\t    external\r\n\t    isRegisteredGame(msg.sender)\r\n\t{\r\n\t    players[playerAddress].balance = players[playerAddress].balance.add(value);\r\n\t    games[msg.sender].amountTaken += value;\r\n\t    \r\n\t    totalPlayerBalances += value;\r\n\t}\r\n\t\r\n\tfunction subPlayerBalance(address playerAddress, uint256 value)\r\n\t    external\r\n\t    isRegisteredGame(msg.sender)\r\n\t{\r\n\t    players[playerAddress].balance = players[playerAddress].balance.sub(value);\r\n\t    games[msg.sender].amountGiven += value;\r\n\t    \r\n\t    totalPlayerBalances -= value;\r\n\t}\r\n\t\r\n\t//\r\n\t//PLincHub integration\r\n\t//\r\n\t\r\n\tIPLincHub public plincHub;\r\n\tuint256 plincDivisor = 1;\r\n\t\r\n\tmodifier withdrawPiggyBank\r\n    {\r\n\t    if(plincHub.piggyBank(address(this)) \u003e 0) {\r\n\t        plincHub.piggyToWallet();\r\n\t    }\r\n\t    _;\r\n    }\r\n\t\r\n\tfunction setAuto(uint256 percentage)\r\n        external\r\n        onlyManager\r\n    {\r\n        plincHub.setAuto(percentage);\r\n    }\r\n    \r\n    function setPLincDivisor(uint256 value)\r\n        external\r\n        onlyManager\r\n    {\r\n        plincDivisor = value;\r\n    }\r\n    \r\n    function buyBonds(uint256 value)\r\n        external\r\n        onlyManager\r\n    {\r\n        buyBondsInternally(value);\r\n    }\r\n    \r\n    function fillBonds()\r\n        external\r\n        onlyManager\r\n    {\r\n        plincHub.fillBonds(address(this));\r\n    }\r\n    \r\n    function fetchBonds()\r\n        external\r\n        onlyManager\r\n    {\r\n        plincHub.fetchDivs(address(this));\r\n    }\r\n    \r\n    function piggyToWallet()\r\n        external\r\n    {\r\n        plincHub.piggyToWallet();\r\n    }\r\n    \r\n    function vaultToWallet()\r\n        external\r\n    {\r\n        plincHub.vaultToWallet();\r\n    }\r\n    \r\n    function bondsOutstanding()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n       return plincHub.bondsOutstanding(address(this));\r\n    }\r\n    \r\n    function buyBondsInternally(uint256 value)\r\n        private\r\n    {\r\n        plincHub.buyBonds.value(value)(manager);\r\n    }\r\n}\r\n\r\ninterface IHubGame {\r\n    function play(address playerAddress, uint256 value, bytes calldata gameData) external;\r\n}\r\n\r\ninterface IPLincHub {\r\n    function setAuto(uint256 percentage) external;\r\n    function buyBonds(address referral) external payable;\r\n    function piggyToWallet() external;\r\n    function vaultToWallet() external;\r\n    function fillBonds(address player) external;\r\n    function fetchDivs(address player) external;\r\n    function piggyBank(address player) external view returns (uint256);\r\n    function bondsOutstanding(address player) external view returns (uint256);\r\n}"},"PLincSlots.sol":{"content":"pragma solidity 0.5.8;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract PLincSlots {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    struct Spin {\r\n        uint256 value;\r\n        uint256 startBlock;\r\n        uint256 multiplier;\r\n        bool open;\r\n    }\r\n    \r\n    mapping(address =\u003e Spin) public playerSpin;\r\n    \r\n    uint256 public totalSpins;\r\n    \r\n    address private hubAddress;\r\n    IGamesHub private hubContract;\r\n    \r\n    uint256 public maxBet;\r\n    uint256 public maxMultiplier;\r\n    \r\n    event Win(address indexed player, uint256 amount, uint256 reel1, uint256 reel2, uint256 reel3);\r\n    event Loss(address indexed player, uint256 amount);\r\n    \r\n    constructor(address gameHubAddress)\r\n        public\r\n    {\r\n        hubAddress = gameHubAddress;\r\n        hubContract = IGamesHub(gameHubAddress);\r\n        \r\n        maxBet = 0.1 ether;\r\n        maxMultiplier = 20;\r\n    }\r\n    \r\n    modifier onlyHub(address sender)\r\n    {\r\n        require(sender == hubAddress);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDev()\r\n    {\r\n        require(msg.sender == address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef));\r\n        _;\r\n    }\r\n    \r\n    function play(address playerAddress, uint256 value, bytes calldata gameData)\r\n        external\r\n        onlyHub(msg.sender)\r\n    {\r\n        require(value \u003c= maxBet);\r\n        \r\n        playInternal(playerAddress, value);\r\n    }\r\n    \r\n    function playWithBalance(uint256 value)\r\n        external\r\n    {   \r\n        hubContract.subPlayerBalance(msg.sender, value);\r\n        playInternal(msg.sender, value);\r\n    }\r\n    \r\n    function resolveSpin()\r\n        external\r\n    {\r\n        Spin storage spin = getCurrentPlayerSpin(msg.sender);\r\n        require(spin.open);\r\n        \r\n        resolveInternal(msg.sender, spin);\r\n    }\r\n    \r\n    function setMaxBet(uint256 newMaxBet)\r\n        external\r\n        onlyDev\r\n    {\r\n        require(newMaxBet \u003e 0);\r\n        \r\n        maxBet = newMaxBet;\r\n    }\r\n    \r\n    function setMaxMultiplier(uint256 newMaxMultiplier)\r\n        external\r\n        onlyDev\r\n    {\r\n        require(newMaxMultiplier \u003e= 20);\r\n        \r\n        maxMultiplier = newMaxMultiplier;\r\n    }\r\n    \r\n    function hasActiveSpin()\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getCurrentPlayerSpin(msg.sender).open \r\n        \u0026\u0026 block.number - 256 \u003c= getCurrentPlayerSpin(msg.sender).startBlock;\r\n    }\r\n    \r\n    function mySpin()\r\n        external\r\n        view\r\n        returns(uint256 reel1, uint256 reel2, uint256 reel3)\r\n    {\r\n        Spin storage spin = getCurrentPlayerSpin(msg.sender);\r\n        \r\n        require(block.number - 256 \u003c= spin.startBlock);\r\n        \r\n        reel1 = reel2 = reel3 = 42;\r\n        \r\n        bytes20 senderXORcontract = bytes20(msg.sender) ^ bytes20(address(this));\r\n        \r\n        if(block.number \u003e spin.startBlock) {\r\n            reel1 = uint256(blockhash(spin.startBlock) ^ senderXORcontract) % 5;\r\n        }\r\n        \r\n        if(block.number \u003e spin.startBlock + 1) {\r\n            reel2 = uint256(blockhash(spin.startBlock + 1) ^ senderXORcontract) % 5;\r\n        }\r\n        \r\n        if(block.number \u003e spin.startBlock + 2) {\r\n            reel3 = uint256(blockhash(spin.startBlock + 2) ^ senderXORcontract) % 5;\r\n        }\r\n    }\r\n    \r\n    function getCurrentPlayerSpin(address playerAddress)\r\n        private\r\n        view\r\n        returns (Spin storage)\r\n    {\r\n        return playerSpin[playerAddress];\r\n    }\r\n    \r\n    function playInternal(address playerAddress, uint256 value)\r\n        private\r\n    {\r\n        Spin storage spin = getCurrentPlayerSpin(playerAddress);\r\n        \r\n        if(spin.open) {\r\n            resolveInternal(playerAddress, spin);\r\n        }\r\n        \r\n        playerSpin[playerAddress] = Spin(value, block.number, 0, true);\r\n        \r\n        totalSpins++;\r\n    }\r\n    \r\n    function resolveInternal(address playerAddress, Spin storage spin)\r\n        private\r\n    {\r\n        require(block.number \u003e spin.startBlock + 2);\r\n        \r\n        spin.open = false;\r\n        \r\n        if(block.number - 256 \u003e spin.startBlock) {\r\n            emit Loss(playerAddress, spin.value);\r\n            return;\r\n        }\r\n        \r\n        bytes20 senderXORcontract = bytes20(playerAddress) ^ bytes20(address(this));\r\n        \r\n        uint256 reel1 = uint256(blockhash(spin.startBlock) ^ senderXORcontract) % 5;\r\n        uint256 reel2 = uint256(blockhash(spin.startBlock + 1) ^ senderXORcontract) % 5;\r\n        uint256 reel3 = uint256(blockhash(spin.startBlock + 2) ^ senderXORcontract) % 5;\r\n        \r\n        if(reel1 + reel2 + reel3 == 0) {\r\n            spin.multiplier = maxMultiplier;\r\n        } else if(reel1 == reel2 \u0026\u0026 reel1 == reel3) {\r\n            spin.multiplier = 7;\r\n        } else if(reel1 + reel2 == 0 || reel1 + reel3 == 0 || reel2 + reel3 == 0) {\r\n            spin.multiplier = 2;\r\n        } else if(reel1 == 0 || reel2 == 0 || reel3 == 0) {\r\n            spin.multiplier = 1;\r\n        }\r\n        \r\n        if(spin.multiplier \u003e 0) {\r\n            uint256 amountWon = spin.value.mul(spin.multiplier);\r\n            hubContract.addPlayerBalance(playerAddress, amountWon);\r\n            \r\n            emit Win(playerAddress, amountWon, reel1, reel2, reel3);\r\n        } else {\r\n            emit Loss(playerAddress, spin.value);\r\n        }\r\n    }\r\n}\r\n\r\ninterface IGamesHub {\r\n    function addPlayerBalance(address playerAddress, uint256 value) external;\r\n    function subPlayerBalance(address playerAddress, uint256 value) external;\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.8;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b \u003c= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c \u003e= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n}"}}