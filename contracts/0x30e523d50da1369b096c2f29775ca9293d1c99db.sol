{"destructible.sol":{"content":"pragma solidity ^0.4.25;\n\nimport \"./ownable.sol\";\n\n/**\n * @title Destructible\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n */\ncontract Destructible is Ownable {\n\n    constructor() public payable { }\n\n    /**\n     * @dev Transfers the current balance to the owner and terminates the contract.\n     */\n    function destroy() public onlyOwner {\n        selfdestruct(owner);\n    }\n\n    function destroyAndSend(address _recipient) public onlyOwner {\n        selfdestruct(_recipient);\n    }\n}"},"ownable.sol":{"content":"pragma solidity ^0.4.25;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n\n    address public owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        owner = newOwner;\n    }\n\n}"},"pausable.sol":{"content":"pragma solidity ^0.4.25;\n\nimport \"./ownable.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor() internal {\n        _paused = false;\n    }\n\n    /**\n     * @return true if the contract is paused, false otherwise.\n     */\n    function paused() public view returns(bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"},"repayable.sol":{"content":"pragma solidity ^0.4.25;\n\nimport \"./SafeMath.sol\";\n\ncontract Repaying {\n    using SafeMath for uint256;\n    bool repayLock;\n    uint256 maxGasPrice = 4000000000;\n    event Repaid(address user, uint256 amt);\n\n    modifier repayable {\n        if(!repayLock) {\n            repayLock = true;\n            uint256 startGas = gasleft();\n            _;\n            uint256 gasUsed = startGas.sub(gasleft());\n            uint256 gasPrice = maxGasPrice.min256(tx.gasprice);\n            uint256 repayal = gasPrice.mul(gasUsed.add(41761));\n            tx.origin.send(repayal);\n            emit Repaid(tx.origin, repayal);\n            repayLock = false;\n        }\n        else {\n            _;\n        }\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.4.25;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c \u003e= a);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n        return a \u003e= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n        return a \u003c b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    function abs128(int128 a) internal constant returns (int128) {\n        return a \u003c 0 ? a * -1 : a;\n    }\n}"},"tokenInterfaces.sol":{"content":"pragma solidity ^0.4.25;\n\n//for any ERC20 token\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n//WednesdayCoin Interface\ncontract WednesdayCoin is ERC20Interface {\n    /* Approves and then calls the receiving contract */\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success);\n}"},"WednesdayClub.sol":{"content":"pragma solidity ^0.4.25;\n\nimport \"./ownable.sol\";\nimport \"./pausable.sol\";\nimport \"./destructible.sol\";\nimport \"./tokenInterfaces.sol\";\nimport \"./repayable.sol\";\nimport \"./WednesdayClubPost.sol\";\nimport \"./WednesdayClubComment.sol\";\nimport \"./WednesdayClubUser.sol\";\n\ncontract WednesdayClub is Ownable, Destructible, Pausable, Repaying, WednesdayClubPost, WednesdayClubComment, WednesdayClubUser {\n\n    //onlyWednesdays Modifier\n    modifier onlyWednesdays() {\n        //require true only for testing\n        //require(true);\n        uint8 dayOfWeek = uint8((now / 86400 + 4) % 7);\n        require(dayOfWeek == 3);\n        _;\n    }\n\n    // WednesdayCoin contract being held\n    WednesdayCoin public wednesdayCoin;\n\n    //constructor\n    constructor() public {\n        //for testing -- 0xEDFc38FEd24F14aca994C47AF95A14a46FBbAA16\n        //for prod -- 0x7848ae8F19671Dc05966dafBeFbBbb0308BDfAbD\n        wednesdayCoin = WednesdayCoin(0x7848ae8F19671Dc05966dafBeFbBbb0308BDfAbD);\n        amountForPost = 10000000000000000000000; //10k\n        amountForComment = 1000000000000000000000; //1k\n        postInterval = 10 minutes;\n        commentInterval = 5 minutes;\n        minimumToLikePost = 1000000000000000000000; //1k\n        minimumToLikeComment = 100000000000000000000; //100\n        minimumForFollow = 100000000000000000000; //100\n        minimumForReporting = 100000000000000000000; //100\n        minimumForUpdatingProfile = 100000000000000000000; //100\n        minimumForBlockingUser = 100000000000000000000; //100\n        reportInterval = 10 minutes;\n    }\n\n    function () public payable {}\n\n    /*****************************************************************************************\n     * Posts logic - add, like, report, delete\n     * ***************************************************************************************/\n    // Adds a new post\n    function writePost(uint256 _id, uint256 _value, string _content, string _media) public onlyWednesdays repayable whenNotPaused whenNotSuspended whenTimeElapsedPost {\n        require(amountForPost == _value);\n        require(bytes(_content).length \u003e 0 || bytes(_media).length \u003e 0);\n        _id = uint256(keccak256(_id, now, blockhash(block.number - 1), block.coinbase));\n        //ensure that post doesnot exists\n        require(posts[_id].id != _id);\n        //for create\n        if (wednesdayCoin.transferFrom(msg.sender, this, _value)) {\n            emit PostContent(_id, _content, _media);\n            Post memory post = Post(_id, msg.sender, 0, 0, now, 0);\n            userPosts[msg.sender].push(_id);\n            posts[_id] = post;\n            postIds.push(_id);\n            postTime[msg.sender] = now;\n        } else {\n            revert();\n        }\n    }\n\n    function likePost(uint256 _id, uint256 _value) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(_value \u003e= minimumToLikePost);\n        //ensure that post exists\n        if (posts[_id].id == _id) {\n            //shouldnt be able to like your own post\n            require(posts[_id].poster != msg.sender);\n            if (wednesdayCoin.transferFrom(msg.sender, posts[_id].poster, _value)) {\n                posts[_id].value += _value;\n                posts[_id].likes++;\n            } else {\n                revert();\n            }\n        }\n    }\n\n    function reportPost(uint256 _id, uint256 _value) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(hasElapsedReport());\n        //ensure that post exists\n        if (posts[_id].id == _id) {\n            //shouldnt be able to report your own post\n            require(posts[_id].poster != msg.sender);\n            if (wednesdayCoin.transferFrom(msg.sender, this, _value)) {\n                posts[_id].reportCount++;\n                reportTime[msg.sender] = now;\n            } else {\n                revert();\n            }\n        }\n    }\n\n    //delete a user post\n    function deleteUserPost(address _user, uint256 _id) public onlyOwner {\n        for(uint i = 0; i \u003c userPosts[_user].length; i++) {\n            if(userPosts[_user][i] == _id){\n                delete userPosts[_user][i];\n            }\n        }\n    }\n\n    //delete a public post\n    function deletePublicPost(uint256 _id) public onlyOwner {\n        if(posts[_id].id == _id){\n            delete posts[_id];\n        }\n    }\n\n    function deleteIdFromPostIds(uint256 _id) public onlyOwner  {\n        uint256 indexToDelete;\n        for(uint i = 0; i \u003c postIds.length; i++) {\n            if(postIds[i] == _id) {\n                indexToDelete = i;\n            }\n        }\n        delete postIds[indexToDelete];\n    }\n    // deleteAllPosts from PostIds\n    function deleteAllPosts() public onlyOwner {\n        deleteAllPosts(postIds.length);\n    }\n\n    // deleteAllPosts in groups i.e. delete 100, then 100 again, etc - for saving on gas and incase to many\n    function deleteAllPosts(uint256 _amountToDelete) public onlyOwner {\n        for(uint i = 0; i \u003c _amountToDelete; i++) {\n            address poster = posts[postIds[i]].poster;\n            deleteUserPost(poster, posts[postIds[i]].id);\n            deletePublicPost(posts[postIds[i]].id);\n            deleteIdFromPostIds(posts[postIds[i]].id);\n        }\n    }\n\n    //to make it easier this one calls all delete functions\n    function deletePost(address _user, uint256 _id) public onlyOwner {\n        deleteUserPost(_user, _id);\n        deletePublicPost(_id);\n        deleteIdFromPostIds(_id);\n    }\n\n    /*****************************************************************************************\n     * Comments logic - add, like, report, delete\n     * ***************************************************************************************/\n    // Adds a new comment\n    function writeComment(uint256 _id, uint256 _parentId, uint256 _value, string _content, string _media) public onlyWednesdays repayable whenNotPaused whenNotSuspended whenTimeElapsedComment {\n        require(amountForComment == _value);\n        require(bytes(_content).length \u003e 0 || bytes(_media).length \u003e 0);\n        _id = uint256(keccak256(_id, now, blockhash(block.number - 1), block.coinbase));\n        //require post exists\n        require(posts[_parentId].id == _parentId);\n        require(comments[_id].id != _id);\n        //for create\n        if (wednesdayCoin.transferFrom(msg.sender, posts[_parentId].poster, _value)) {\n            emit CommentContent(_id, _content, _media);\n            Comment memory comment = Comment(_id, _parentId, msg.sender, 0, 0, now, 0);\n            userComments[msg.sender].push(_id);\n            comments[_id] = comment;\n            postComments[_parentId].push(_id);\n            commentTime[msg.sender] = now;\n        } else {\n            revert();\n        }\n    }\n\n    function likeComment(uint256 _id, uint256 _value) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(_value \u003e= minimumToLikeComment);\n        //ensure that comment exists\n        if (comments[_id].id == _id) {\n            //shouldnt be able to like your own comment\n            require(comments[_id].commenter != msg.sender);\n            if (wednesdayCoin.transferFrom(msg.sender, comments[_id].commenter, _value)) {\n                comments[_id].value += _value;\n                comments[_id].likes++;\n            } else {\n                revert();\n            }\n        }\n    }\n\n    function reportComment(uint256 _id, uint256 _value) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(hasElapsedReport());\n        //ensure that post exists\n        if (comments[_id].id == _id) {\n            //shouldnt be able to report your own post\n            require(comments[_id].commenter != msg.sender);\n            if (wednesdayCoin.transferFrom(msg.sender, this, _value)) {\n                comments[_id].reportCount++;\n                reportTime[msg.sender] = now;\n            } else {\n                revert();\n            }\n        }\n    }\n\n    //delete a user comment\n    function deleteUserComment(address _user, uint256 _id) public onlyOwner {\n        for(uint i = 0; i \u003c userComments[_user].length; i++) {\n            if(userComments[_user][i] == _id){\n                delete userComments[_user][i];\n            }\n        }\n    }\n\n    //delete a public comment\n    function deletePublicComment(uint256 _id) public onlyOwner {\n        if(comments[_id].id == _id){\n            delete comments[_id];\n        }\n    }\n\n    //to make it easier this one calls all delete functions\n    function deleteComment(address _user, uint256 _id) public onlyOwner {\n        deleteUserComment(_user, _id);\n        deletePublicComment(_id);\n    }\n\n    /*****************************************************************************************\n     * User logic - add/update profile info\n     * ***************************************************************************************/\n\n    function updateProfile(string _username, string _about, string _profilePic, string _site, uint256 _value) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(_value \u003e= minimumForUpdatingProfile);\n        if (wednesdayCoin.transferFrom(msg.sender, this, _value)) {\n            if (users[msg.sender].id != msg.sender) {\n                User memory user = User(msg.sender, \u0027\u0027, \u0027\u0027, \u0027\u0027, \u0027\u0027);\n                users[msg.sender] = user;\n            }\n            if (bytes(_username).length \u003e 0) {\n                users[msg.sender].username = _username;\n            }\n            if (bytes(_about).length \u003e 0) {\n                users[msg.sender].about = _about;\n            }\n            if (bytes(_profilePic).length \u003e 0) {\n                users[msg.sender].profilePic = _profilePic;\n            }\n            if (bytes(_site).length \u003e 0) {\n                users[msg.sender].site = _site;\n            }\n        } else {\n            revert();\n        }\n    }\n\n\n    /*****************************************************************************************\n     * Following/Followers logic\n     * ***************************************************************************************/\n\n    function follow(address _address, uint256 _value) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(_value \u003e= minimumForFollow);\n        require(msg.sender != _address);\n        // update that user is following address\n        if (wednesdayCoin.transferFrom(msg.sender, _address, _value)) {\n            following[msg.sender].push(_address);\n            // update address followers\n            followers[_address].push(msg.sender);\n        } else {\n            revert();\n        }\n    }\n\n    function unfollow(address _address) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(msg.sender != _address);\n        // delete that user is folowing address\n        for(uint i = 0; i \u003c following[msg.sender].length; i++) {\n            if(following[msg.sender][i] == _address){\n                delete following[msg.sender][i];\n            }\n        }\n        // delete address followers\n        for(i = 0; i \u003c followers[_address].length; i++) {\n            if(followers[_address][i] == msg.sender){\n                delete followers[_address][i];\n            }\n        }\n    }\n\n    /*****************************************************************************************\n     * Blocking/Unblocking users logic\n     * ***************************************************************************************/\n\n    function blockUser(address _address, uint256 _value) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(_value \u003e= minimumForBlockingUser);\n        require(msg.sender != _address);\n        // update that user is following address\n        if (wednesdayCoin.transferFrom(msg.sender, this, _value)) {\n            blockedUsers[msg.sender].push(_address);\n        } else {\n            revert();\n        }\n    }\n\n    function unblockUser(address _address) public onlyWednesdays repayable whenNotPaused whenNotSuspended {\n        require(msg.sender != _address);\n        // delete that user is folowing address\n        for(uint i = 0; i \u003c blockedUsers[msg.sender].length; i++) {\n            if(blockedUsers[msg.sender][i] == _address){\n                delete blockedUsers[msg.sender][i];\n            }\n        }\n    }\n\n    /*****************************************************************************************\n     * Just in case logic\n     * ***************************************************************************************/\n\n    // Used for transferring any accidentally sent ERC20 Token by the owner only\n    function transferAnyERC20Token(address _tokenAddress, uint _tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(_tokenAddress).transfer(owner, _tokens);\n    }\n\n    // Used for transferring any accidentally sent Ether by the owner only\n    function transferEther(address _dest, uint _amount) public onlyOwner {\n        _dest.transfer(_amount);\n    }\n\n    // Used if a user wants to delete all their data\n    function nukeMe() public {\n        nukePosts();\n        nukeComments();\n        nukeUser();\n    }\n\n    function nukePosts() public {\n        for (uint i = 0; i \u003c userPosts[msg.sender].length; i++) {\n            uint256 id = userPosts[msg.sender][i];\n            delete posts[id];\n            delete postIds[id];\n        }\n        delete userPosts[msg.sender];\n    }\n\n    function nukeComments() public {\n        for (uint i = 0; i \u003c userComments[msg.sender].length; i++) {\n            uint256 id = userComments[msg.sender][i];\n            delete comments[id];\n        }\n        delete userComments[msg.sender];\n    }\n\n    function nukeUser() public {\n        delete users[msg.sender];\n        delete blockedUsers[msg.sender];\n        delete followers[msg.sender];\n        delete following[msg.sender];\n    }\n}"},"WednesdayClubComment.sol":{"content":"pragma solidity ^0.4.25;\n\nimport \"./ownable.sol\";\n\ncontract WednesdayClubComment is Ownable {\n    //Structure of a comment\n    struct Comment {\n        uint256 id;\n        uint256 parentId;\n        address commenter;\n        uint256 value;\n        uint256 likes;\n        uint256 timestamp;\n        uint256 reportCount;\n    }\n\n    modifier whenTimeElapsedComment() {\n        require(hasElapsedComment());\n        _;\n    }\n\n    event CommentContent(uint256 indexed id, string content, string media);\n\n    // list of ids of all comments\n    mapping(uint256 =\u003e Comment) public comments;\n\n    // The comments that each user has commented\n    mapping(address =\u003e uint256[]) public userComments;\n\n    // list of comments for each post id\n    mapping(uint256 =\u003e uint256[]) public postComments;\n\n    // amountForComment\n    uint256 public amountForComment;\n\n    //ensure that each user can only post once at everyinterval\n    mapping(address =\u003e uint) public commentTime;\n\n    //interval user has to wait to be able to post\n    uint public commentInterval;\n\n    // minimum amount For likes\n    uint256 public minimumToLikeComment;\n\n    function hasElapsedComment() public view returns (bool) {\n        if (now \u003e= commentTime[msg.sender] + commentInterval) {\n            //has elapsed from postTime[msg.sender]\n            return true;\n        }\n        return false;\n    }\n\n    function setMinimumToLikeComment(uint _minimumToLikeComment) public onlyOwner {\n        minimumToLikeComment = _minimumToLikeComment;\n    }\n\n    function postCommentsLength(uint256 _postId) public view returns (uint256) {\n        return postComments[_postId].length;\n    }\n}"},"WednesdayClubPost.sol":{"content":"pragma solidity ^0.4.25;\n\nimport \"./ownable.sol\";\n\ncontract WednesdayClubPost is Ownable {\n    // The structure of a post\n    struct Post {\n        uint256 id;\n        address poster;\n        uint256 value;\n        uint256 likes;\n        uint256 timestamp;\n        uint256 reportCount;\n    }\n\n    modifier whenTimeElapsedPost() {\n        require(hasElapsedPost());\n        _;\n    }\n\n    event PostContent(uint256 indexed id, string content, string media);\n\n    // The posts that each address has written\n    mapping(address =\u003e uint256[]) public userPosts;\n\n    // All the posts ever written by ID\n    mapping(uint256 =\u003e Post) public posts;\n\n    // Keep track of all IDs - use for loading\n    uint256[] public postIds;\n\n    // amountForPost\n    uint256 public amountForPost;\n\n    //ensure that each user can only post once at everyinterval\n    mapping(address =\u003e uint) public postTime;\n\n    //interval user has to wait to be able to post\n    uint public postInterval;\n\n    // minimum amount For likes\n    uint256 public minimumToLikePost;\n\n    // minimum amount For reporting\n    uint256 public minimumForReporting;\n\n    //ensure that each user can only post once at everyinterval\n    mapping(address =\u003e uint) public reportTime;\n\n    //interval user has to wait to be able to post\n    uint public reportInterval;\n\n    function getUserPostLength(address _user) public view returns (uint256){\n        return userPosts[_user].length;\n    }\n\n    function hasElapsedPost() public view returns (bool) {\n        if (now \u003e= postTime[msg.sender] + postInterval) {\n            //has elapsed from postTime[msg.sender]\n            return true;\n        }\n        return false;\n    }\n\n    function hasElapsedReport() public view returns (bool) {\n        if (now \u003e= reportTime[msg.sender] + reportInterval) {\n            //has elapsed from reportTime[msg.sender]\n            return true;\n        }\n        return false;\n    }\n\n    function getPostIdsLength() public view returns (uint256){\n        return postIds.length;\n    }\n\n    function setAmountForPost(uint256 _amountForPost) public onlyOwner {\n        amountForPost = _amountForPost;\n    }\n\n    function setPostInterval(uint _postInterval) public onlyOwner {\n        postInterval = _postInterval;\n    }\n\n    function setReportingInterval(uint _reportInterval) public onlyOwner {\n        reportInterval = _reportInterval;\n    }\n\n    function setMinimumForReporting(uint _minimumForReporting) public onlyOwner {\n        minimumForReporting = _minimumForReporting;\n    }\n\n    function setMinimumToLikePost(uint _minimumToLikePost) public onlyOwner {\n        minimumToLikePost = _minimumToLikePost;\n    }\n}"},"WednesdayClubUser.sol":{"content":"pragma solidity ^0.4.25;\n\nimport \"./ownable.sol\";\n\ncontract WednesdayClubUser is Ownable {\n\n    struct User {\n        address id;\n        string username;\n        string about;\n        string profilePic;\n        string site;\n    }\n\n    modifier whenNotSuspended() {\n        require(hasSuspensionElapsed());\n        _;\n    }\n\n    mapping(address =\u003e User) public users;\n\n    // banned users\n    mapping (address =\u003e uint) public suspendedUsers;\n\n    // blocked users\n    mapping (address =\u003e address[]) public blockedUsers;\n\n    // followers: list of who is following\n    mapping(address =\u003e address[]) public followers;\n\n    // following: list of who you are following\n    mapping(address =\u003e address[]) public following;\n\n    // minimum amount For following\n    uint256 public minimumForFollow;\n\n    // minimum amount For updating profile\n    uint256 public minimumForUpdatingProfile;\n\n    // minimum amount For blocking user\n    uint256 public minimumForBlockingUser;\n\n    function hasSuspensionElapsed() public view returns (bool) {\n        if (now \u003e= suspendedUsers[msg.sender]) {\n            //has elapsed from suspendedUsers[msg.sender]\n            return true;\n        }\n        return false;\n    }\n\n    function suspendUser(address _user, uint _time) public onlyOwner {\n        suspendedUsers[_user] = now + _time;\n    }\n\n    function setMinimumForFollow(uint _minimumForFollow) public onlyOwner {\n        minimumForFollow = _minimumForFollow;\n    }\n\n    function getFollowersLength(address _address) public view returns (uint256){\n        return followers[_address].length;\n    }\n\n    function getFollowingLength(address _address) public view returns (uint256){\n        return following[_address].length;\n    }\n}"}}